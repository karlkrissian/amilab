%{
// Projet de Conception des systemes a base de connaissances
// binome :     Galindo Diana
//              Krissian Karl
//
// Realisation d'un moteur d'inference
// fichier :    "analyse.l"
//
// analyse lexicale de la base de regles et
// commandes de l'utilisateur.
//

#include "fonctions.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <locale.h>
#include "messages.h"
#include "improcess_bison.tab.hpp"
#include "VarContexts.hpp"
#include "ami_function.h"
#include <string>
#include <boost/format.hpp>
#include <boost/shared_ptr.hpp>

#define LEX_DEBUG(expr) if (GB_debug) {expr}


int          yyiplineno = 0;
std::string  GB_current_file;

int yycharno = 0;
bool LexError = 0;

extern  void yyiperror(const char*);
extern  VarContexts  Vars;

int checkvar( const char* varname, int context=-1);
using namespace std;


string* cpp_string;
//char string_buf[256];
//char *string_buf_ptr;

//#define MAXSIZE_BLOCK 10000
//char block_buf[MAXSIZE_BLOCK];
//char *block_buf_ptr;


AmiInstructionBlock* ami_block;

int  block_level = 0;
int comment_caller;

// flag for accepting variable names as identifiers
// when declaring the parameters of a function
int  procedure_declaration = 0;

extern char  tmp_string[255];
extern FILE_ptr gr_output; // grammar
extern FILE_ptr err_output; // errors
extern FILE_ptr res_output; // result

extern void init_gr_output();
extern void gr_print(char* st);
//extern void close_gr_output();

extern void init_err_output();
extern void err_print(const char* st);
//extern void close_err_output();

extern void init_res_output();
extern void res_print(const char* st);
//extern void close_res_output();

extern int       GB_argc;
extern char**    GB_argv;
extern int       GB_num_arg_parsed;


%}

%option prefix="yyip"
%option noyywrap
%option verbose

WS      [ \t]

%x str
%x block
%x comment
%%


">>="                   return(RIGHT_ASSIGN);   /*  >>=,RIGHT_ASSIGN  got rid of all tokens with special characters because of windows installer*/
"<<="                   return(LEFT_ASSIGN);    /*  <<=,LEFT_ASSIGN  */
"+="                    return(ADD_ASSIGN);     /*  +=,ADD_ASSIGN  */
"-="                    return(SUB_ASSIGN);     /*  -=,SUB_ASSIGN  */
"*="                    return(MUL_ASSIGN);     /*  *=,MUL_ASSIGN}*/
"/="                    {  return(DIV_ASSIGN); } /*  /=,DIV_ASSIGN}*/
"%="                    {  return(MOD_ASSIGN); } /*  %=,MOD_ASSIGN}*/
"&="                    {  return(AND_ASSIGN); } /*  &=,AND_ASSIGN}*/
"^="                    {  return(XOR_ASSIGN); } /*   ^=,XOR_ASSIGN}*/
"|="                    {  return(OR_ASSIGN); } /*  |=,OR_ASSIGN}*/
">>"                    {  return(RIGHT_OP); } /*  >>,RIGHT_OP}*/
"++"                    {  return(INC_OP); } /*  ++,INC_OP}*/
"--"                    {  return(DEC_OP); } /*  --,DEC_OP}*/
"->"                    {  return(PTR_OP); } /*  ->,PTR_OP}*/
"&&"                    {  return(AND_OP); } /*  &&,AND_OP}*/
"||"                    {  return(OR_OP); } /*  ||,OR_OP}*/
"<="                    {  return(LE_OP); } /*  <=,LE_OP}*/
">="                    {  return(GE_OP); } /*  >=,GE_OP}*/
"=="                    {  return(EQ_OP); } /*  ==,EQ_OP}*/
"!="                    {  return(NE_OP); } /*  !=,NE_OP}*/


"'"  return(TRANSPOSE_OP); /*  ',TRANSPOSE_OP}*/
"^"  return('^'); /*  ^,'^'}*/
">"  return('>'); /*  >,'>'}*/
"<"  return('<'); /*  <,'<'}*/
"*"  return('*'); /*  *,'*'}*/
".*"  return(POINTWISE_MULT);
"/"  return('/'); /*  /,'/'}*/
"!"  return('!'); /*  !,'!'}*/
"+"  return('+'); /*  +,'+'}*/
"-"  return('-'); /*  -,'-'}*/
"="  return(ASSIGN_OP); /*{=,ASSIGN_OP}*/
"("  return('('); /*  (,'('}*/
")"  return(')'); /*  ),')'}*/
"["  return('['); /*  [,'['}*/
"]"  return(']'); /*  ],']'}*/
"&"  return('&'); /*  &,'&'}*/
"|"  return('|'); /*  |,'|'}*/

"."  return('.'); /*  .,'.'}*/
","  return(',');
"?"  return('?'); /*  ?,'?'}*/
":"  return(':'); /*  :,':'}*/


";"           return(';');      /*  ;,';'}*/


LineNumber      return(T_LineNumber); /*{LineNumber,T_LineNumber}*/

update           return(UPDATE);            /*{update,UPDATE}*/
set              return(SET);               /*{set,SET}*/
setpos           return(SETPOS);            /*{setpos,SETPOS}*/
initvalue        return(T_initvalue);       /*{initvalue,T_initvalue}*/
showcursor       return(SHOWCURSOR);        /*{showcursor,SHOWCURSOR}*/
compare          return(COMPARE);           /*{compare,COMPARE}*/
SetCompareDisplacement return(T_SetCompareDisplacement); /*{SetCompareDisplacement,T_SetCompareDisplacement}*/
setvector        return(SETVECTOR);         /*{setvector,SETVECTOR}*/
DrawVector       return(T_DrawVector);      /*{DrawVector,T_DrawVector}*/
DisplayVectors   return(T_DisplayVectors);  /*{DisplayVectors,T_DisplayVectors}*/
SetVectParam     return(T_SetVectParam);    /*{SetVectParam,T_SetVectParam}*/
SetVectColor     return(T_SetVectColor);    /*{SetVectColor,T_SetVectColor}*/
SetVectStyle     return(T_SetVectStyle);    /*{SetVectStyle,T_SetVectStyle}*/
SetLineThickness return(T_SetLineThickness); /*{SetLineThickness,T_SetLineThickness}*/
normalize        return(T_normalize); /*{normalize,T_normalize}*/
setGLwin         return(T_setGLwin); /*{setGLwin,T_setGLwin}*/
drawcircle       return(T_drawcircle); /*{drawcircle,T_drawcircle}*/
ShowSection      return(T_ShowSection); /*{ShowSection,T_ShowSection}*/
HideSection      return(T_HideSection); /*{HideSection,T_HideSection}*/
SetColormap      return(T_SetColormap); /*{SetColormap,T_SetColormap}*/

itk               return(T_itk); /*{itk,T_itk}*/
CannyEdgeDetector return(T_CannyEdgeDetector); /*{CannyEdgeDetector,T_CannyEdgeDetector}*/

GetOutput      return(T_GetOutput); /*{GetOutput,T_GetOutput}*/
GetDiffCoeff   return(T_GetDiffCoeff); /*{GetDiffCoeff,T_GetDiffCoeff}*/
GetName        return(T_GetName); /*{GetName,T_GetName}*/
SetName        return(T_SetName); /*{SetName,T_SetName}*/


CHAR          return(T_CHAR); /*{CHAR,T_CHAR}*/
UCHAR         return(T_UCHAR); /*{UCHAR,T_UCHAR}*/
SHORT         return(T_SHORT); /*{SHORT,T_SHORT}*/
USHORT        return(T_USHORT); /*{USHORT,T_USHORT}*/
INT           return(T_INT); /*{INT,T_INT}*/
UINT          return(T_UINT); /*{UINT,T_UINT}*/
FLOAT         return(T_FLOAT); /*{FLOAT,T_FLOAT}*/
DOUBLE        return(T_DOUBLE); /*{DOUBLE,T_DOUBLE}*/
RGB           return(T_RGB); /*{RGB,T_RGB}*/
FLOAT_VECTOR  return(T_FLOAT_VECTOR); /*{FLOAT_VECTOR,T_FLOAT_VECTOR}*/
GetFormat     return(T_GetFormat); /*{GetFormat,T_GetFormat}*/

SURFACE       return(T_SURFACE); /*{SURFACE,T_SURFACE}*/
IMAGE         return(T_IMAGE); /*{IMAGE,T_IMAGE}*/
IMAGEDRAW     return(T_IMAGEDRAW); /*{IMAGEDRAW,T_IMAGEDRAW}*/
NUM           return(T_NUM); /*{NUM,T_NUM}*/
STRING        return(T_STRING); /*{STRING,T_STRING}*/
TRANSFORM     return(T_TRANSFORM); /*{TRANSFORM,T_TRANSFORM}*/

atof          return(T_atof); /*{atof,T_atof}*/

global        return(T_global);     /*{global,T_global}*/
global_new    return(T_global_new); /*{global_new,T_global_new}*/
local_new     return(T_local_new); /*{local_new,T_local_new}*/
local         return(T_local);      /*{local,T_local}*/
wait          return(T_wait);       /*{wait,T_wait}*/
schedule      return(T_schedule);   /*{schedule,T_schedule}*/

Pi    {
//
//============================ Parse constants ====================
//
 return(CONST_PI);
} /*{Pi,CONST_P}*/


sin    {
//
//============================ Parse Math functions ====================
//
return(SIN);
} /*{sin,SIN}*/
cos    return(COS); /*{cos,COS}*/
tan    return(TAN); /*{tan,TAN}*/
asin   return(ASIN); /*{asin,ASIN}*/
acos   return(ACOS); /*{acos,ACOS}*/
atan   return(ATAN); /*{atan,ATAN}*/
exp    return(EXP); /*{exp,EXP}*/
ln     return(LN); /*{ln,LN}*/
log    return(LOG); /*{log,LOG}*/
cosh   return(COSH); /*{cosh,COSH}*/
sinh   return(SINH); /*{sinh,SINH}*/
sqrt   return(SQRT); /*{sqrt,SQRT}*/
abs    return(ABS); /*{abs,ABS}*/
norm   return(NORM); /*{norm,NORM}*/
round  return(ROUND); /*{round,ROUND}*/
floor  return(FLOOR); /*{floor,FLOOR}*/

open       return(T_OPEN); /*{open,T_OPEN}*/
close      return(T_CLOSE); /*{close,T_CLOSE}*/
scan_float return(T_scan_float); /*{scan_float,T_scan_float}*/
read       return(T_read); /*{read,T_read}*/
rewind     return(T_rewind); /*{rewind,T_rewind}*/

proc {
//============================ Parse Procedure ===============
//
  procedure_declaration = 1;
  return(T_PROC);

}  /*{proc,T_PROC}*/

for    {
//
//============================ Parse Loops and Conditions ===============
//
return(FOR);
} /*{for,FOR}*/
to     return(TO); /*{to,TO}*/
step     return(STEP); /*{step,STEP}*/
endfor return(ENDFOR); /*{endfor,ENDFOR}*/

repeat return(T_REPEAT); /*{repeat,T_REPEAT}*/
until  return(T_UNTIL); /*{until,T_UNTIL}*/
break  return(T_BREAK); /*{break,T_BREAK}*/

if      return(IF); /*{if,IF}*/
else    return(ELSE); /*{else,ELSE}*/

sh                {
//
//============================ Parse Commands ===============
//
return(ASHELL);
} /*{sh,ASHELL}*/
SetDebugOn         return(T_SetDebugOn); /*{SetDebugOn,T_SetDebugOn}*/
SetDebugOff        return(T_SetDebugOff); /*{SetDebugOff,T_SetDebugOff}*/
SetVerboseOn       return(T_SetVerboseOn); /*{SetVerboseOn,T_SetVerboseOn}*/
SetVerboseOff      return(T_SetVerboseOff); /*{SetVerboseOff,T_SetVerboseOff}*/
SetProgress        return(T_SetProgress); /*{SetProgress,T_SetProgress}*/
Quit               return(QUIT); /*{Quit,QUIT}*/
quit               return(QUIT);
Image              return(T_Image); /*{Image,T_Image}*/
ReadRawImages      return(T_ReadRawImages); /*{ReadRawImages,T_ReadRawImages}*/
Transform          return(T_Transform); /*{Transform,T_Transform}*/
Show               return(SHOW); /*{Show,SHOW}*/
show               return(SHOW);
Remove             return(T_Remove); /*{Remove,T_Remove}*/
SwapBuffers        return(T_SwapBuffers); /*{SwapBuffers, T_SwapBuffers}*/
Hide               return(T_HIDE); /*{Hide,T_HIDE}*/
hide               return(T_HIDE);
Help               return(HELP); /*{Help,HELP}*/
help               return(HELP);
ls                 return(LS); /*{ls,LS}*/
print              return(PRINT); /*{print,PRINT}*/
printn             return(PRINTN); /*{printn,PRINTN}*/
sprint             return(T_SPRINT); /*{sprint,T_SPRINT}*/
vars               return(VARIABLES); /*{vars,VARIABLES}*/
func               return(FUNCTION); /*{func,FUNCTION}*/
filter             return(FILTER); /*{filter,FILTER}*/
vtkMedian3D        return(T_vtkMedian3D); /*{vtkMedian3D,T_vtkMedian3D}*/
normgrad           return(NormGrad); /*{normgrad,NormGrad}*/
discnormgrad       return(T_DiscNormGrad); /*{discnormgrad,T_DiscNormGrad}*/
gradient           return(T_gradient); /*{gradient,T_gradient}*/
secdergrad         return(SecDerGrad); /*{secdergrad,SecDerGrad}*/
secdergrad2        return(SecDerGrad2); /*{secdergrad2,SecDerGrad2}*/
discsecdergrad     return(T_DiscSecDerGrad); /*{discsecdergrad,T_DiscSecDerGrad}*/
OpImage            return(OpImage); /*{OpImage,OpImage}*/
subimage           return(SubImage); /*{subimage,SubImage}*/
autocrop           return(T_AutoCrop); /*{autocrop,T_AutoCrop}*/
putimage           return(PutImage); /*{putimage,PutImage}*/
rot2D              return(T_rot2D); /*{rot2D,T_rot2D}*/
rotate             return(T_rotate); /*{rotate,T_rotate}*/
mean               return(T_mean); /*{mean,T_mean}*/
localmean          return(T_localmean); /*{localmean,T_localmean}*/
localmean2         return(T_localmean2); /*{localmean2,T_localmean2}*/
localSD            return(T_localSD); /*{localSD,T_localSD}*/
localSD2           return(T_localSD2); /*{localSD2,T_localSD2}*/
StructTensor       return(T_struct_tensor); /*{StructTensor,T_struct_tensor}*/
StructTensorH      return(T_StructTensorH); /*{StructTensorH,T_StructTensorH}*/
HessianMatrix      return(T_HessianMatrix); /*{HessianMatrix,T_HessianMatrix}*/
HessianEVal        return(T_HessianEVal); /*{HessianEVal,T_HessianEVal}*/
Derivatives        return(T_Derivatives); /*{Derivatives,T_Derivatives}*/
Curvatures         return(T_curvatures); /*{Curvatures,T_curvatures}*/
DiscMeanCurvature  return(T_DiscMeanCurvature); /*{DiscMeanCurvature,T_DiscMeanCurvature}*/
Laplacian          return(T_Laplacian); /*{Laplacian,T_Laplacian}*/
setvoxelsize       return(T_setvoxelsize); /*{setvoxelsize,T_setvoxelsize}*/
settranslation     return(T_settranslation); /*{settranslation,T_settranslation}*/
setendianness      return(T_setendianness);  /*{setendianness,T_setendianness}*/

threscross         return(T_threscross); /*{threscross,T_threscross}*/
IsocontourPoints   return(T_IsocontourPoints); /*{IsocontourPoints,T_IsocontourPoints}*/
IsosurfDist        return(T_IsosurfDist); /*{IsosurfDist,T_IsosurfDist}*/
vtkIsoContourDist  return(T_vtkIsoContourDist); /*{vtkIsoContourDist,T_vtkIsoContourDist}*/

SetIsoContour      return(T_SetIsoContour); /*{SetIsoContour,T_SetIsoContour}*/
SetIsoContourParam return(T_SetIsoContourParam); /*{SetIsoContourParam,T_SetIsoContourParam}*/
DrawIsoContour     return(T_DrawIsoContour); /*{DrawIsoContour,T_DrawIsoContour}*/
SetIsoContourColor return(T_SetIsoContourColor);  /*{SetIsoContourColor,T_SetIsoContourColor}*/
DrawAllContours    return(T_DrawAllContours);     /*{DrawAllContours,T_DrawAllContours}*/
AllContoursParam   return(T_AllContoursParam);    /*{AllContoursParam,T_AllContoursParam}*/

GetZmin            return(T_GetZmin); /*{GetZmin,T_GetZmin}*/
GetZmax            return(T_GetZmax); /*{GetZmax,T_GetZmax}*/
GetYmin            return(T_GetYmin); /*{GetYmin,T_GetYmin}*/
GetYmax            return(T_GetYmax); /*{GetYmax,T_GetYmax}*/
GetXmin            return(T_GetXmin); /*{GetXmin,T_GetXmin}*/
GetXmax            return(T_GetXmax); /*{GetXmax,T_GetXmax}*/

GetXPos            return(T_GetXPos); /*{GetXPos,T_GetXPos}*/
GetYPos            return(T_GetYPos); /*{GetYPos,T_GetYPos}*/
GetZPos            return(T_GetZPos); /*{GetZPos,T_GetZPos}*/

SetZoom            return(T_SetZoom); /*{SetZoom,T_SetZoom}*/
SetWindowSize      return(T_SetWindowSize); /*{SetWindowSize,T_SetWindowSize}*/

Convolve           return(T_Convolve); /*{Convolve,T_Convolve}*/
ConvolveMask       return(T_ConvolveMask); /*{ConvolveMask,T_ConvolveMask}*/
Pad                return(T_Pad); /*{Pad,T_Pad}*/
Eigen2D            return(T_Eigen2D); /*{Eigen2D,T_Eigen2D}*/
Eigen3D            return(T_Eigen3D); /*{Eigen3D,T_Eigen3D}*/
ChamferDT          return(T_ChamferDT); /*{ChamferDT,T_ChamferDT}*/
Chamfer2DT         return(T_Chamfer2DT); /*{Chamfer2DT,T_Chamfer2DT}*/
BorgeforsDT        return(T_BorgeforsDT); /*{BorgeforsDT,T_BorgeforsDT}*/
BorgeforsSDT       return(T_BorgeforsSDT); /*{BorgeforsSDT,T_BorgeforsSDT}*/
vtkSignedBorgefors return(T_vtkSignedBorgefors); /*{vtkSignedBorgefors,T_vtkSignedBorgefors}*/
vtkSignedFMDist    return(T_vtkSignedFMDist); /*{vtkSignedFMDist,T_vtkSignedFMDist}*/
PropagationDist    return(T_PropagationDist); /*{PropagationDist,T_PropagationDist}*/
PropagationDist2   return(T_PropagationDist2); /*{PropagationDist2,T_PropagationDist2}*/
PropDanielsson     return(T_PropDanielsson); /*{PropDanielsson,T_PropDanielsson}*/
vtkPropDanielsson  return(T_vtkPropDanielsson); /*{vtkPropDanielsson,T_vtkPropDanielsson}*/
vtkPropDaniel2     return(T_vtkPropDaniel2); /*{vtkPropDaniel2,T_vtkPropDaniel2}*/
CC                 return(T_CC); /*{CC,T_CC}*/

ConvexHull        return(T_ConvexHull); /*{ConvexHull,T_ConvexHull}*/

MeanHalfSize      return(T_MeanHalfSize); /*{MeanHalfSize,T_MeanHalfSize}*/
Resize            return(T_Resize); /*{Resize,T_Resize}*/
ReSlice           return(T_ReSlice); /*{ReSlice,T_ReSlice}*/
Flip              return(T_Flip);  /*{Flip,T_Flip}*/// flips image in one of the main axis direction

SetCompTransf     return(T_SetCompTransf); /*{SetCompTransf,T_SetCompTransf}*/

InitTime          return(T_InitTime); /*{InitTime,T_InitTime}*/
TimeSpent         return(T_TimeSpent); /*{TimeSpent,T_TimeSpent}*/
EndTime           return(T_EndTime); /*{EndTime,T_EndTime}*/

NULL              return(T_NULL); /*{NULL,T_NULL}*/


ProcessXEvents    return(T_ProcessXEvents); /*{ProcessXEvents,T_ProcessXEvents}*/
ProcessEvents    return(T_ProcessEvents); /*{ProcessEvents,T_ProcessEvents}*/

count             return(T_COUNT); /*{count,T_COUNT}*/
max               return(T_MAX); /*{max,T_MAX}*/
argmax            return(T_argmax); /*{argmax,T_argmax}*/
min               return(T_MIN); /*{min,T_MIN}*/
median            return(T_MEDIAN); /*{median,T_MEDIAN}*/
sum               return(T_SUM); /*{sum,T_SUM}*/

info              return(T_info); /*{info,T_info}*/
NbPoints          return(T_NbPoints); /*{NbPoints,T_NbPoints}*/
NbPolys           return(T_NbPolys); /*{NbPolys,T_NbPolys}*/


Xpos              return(T_Xpos); /*{Xpos,T_Xpos}*/
Ypos              return(T_Ypos); /*{Ypos,T_Ypos}*/
Zpos              return(T_Zpos); /*{Zpos,T_Zpos}*/
SpacePos          return(T_SpacePos); /*{SpacePos,T_SpacePos}*/

del               return(T_del); /*{del,T_del}*/

EDPdilate         return(T_EDPdilate); /*{EDPdilate,T_EDPdilate}*/
EDPerode          return(T_EDPerode); /*{EDPerode,T_EDPerode}*/
EDPopen           return(T_EDPopen); /*{EDPopen,T_EDPopen}*/
EDPclose          return(T_EDPclose); /*{EDPclose,T_EDPclose}*/

AnisoGS           return(AnisoGS); /*{AnisoGS,AnisoGS}*/


LevelSetsCURV     return(T_LevelSetsCURV); /*{LevelSetsCURV,T_LevelSetsCURV}*/
UpdateResult      return(T_UpdateResult); /*{UpdateResult,T_UpdateResult}*/
SetMeanCurv       return(T_SetMeanCurv); /*{SetMeanCurv,T_SetMeanCurv}*/
SetAffineCurv     return(T_SetAffineCurv); /*{SetAffineCurv,T_SetAffineCurv}*/
SetDistMethod     return(T_SetDistMethod); /*{SetDistMethod,T_SetDistMethod}*/
SetAdvectionField return(T_SetAdvectionField); /*{SetAdvectionField,T_SetAdvectionField}*/
SetCurvWeights    return(T_SetCurvWeights); /*{SetCurvWeights,T_SetCurvWeights}*/
GetAttachVect     return(T_GetAttachVect); /*{GetAttachVect,T_GetAttachVect}*/
SetVelocity       return(T_SetVelocity); /*{SetVelocity,T_SetVelocity}*/
SetExpansion      return(T_SetExpansion); /*{SetExpansion,T_SetExpansion}*/
SetExpansionImage return(T_SetExpansionImage); /*{SetExpansionImage,T_SetExpansionImage}*/
SetParam          return(T_SetParam); /*{SetParam,T_SetParam}*/
SetIsoContourBin  return(T_SetIsoContourBin); /*{SetIsoContourBin,T_SetIsoContourBin}*/
SetBandTube       return(T_SetBandTube); /*{SetBandTube,T_SetBandTube}*/
SetThreads        return(T_SetThreads); /*{SetThreads,T_SetThreads}*/
SetDistMap        return(T_SetDistMap); /*{SetDistMap,T_SetDistMap}*/
SetBalloonScheme  return(T_SetBalloonScheme); /*{SetBalloonScheme,T_SetBalloonScheme}*/


vtkFastMarching   return(T_vtkFastMarching); /*{vtkFastMarching,T_vtkFastMarching}*/
vtkFastMarchingTarget   return(T_vtkFastMarchingTarget); /*{vtkFastMarchingTarget,T_vtkFastMarchingTarget}*/

SetNumGaussians   return(T_SetNumGaussians); /*{SetNumGaussians,T_SetNumGaussians}*/
SetGaussian       return(T_SetGaussian); /*{SetGaussian,T_SetGaussian}*/
SetProbThreshold  return(T_SetProbThreshold); /*{SetProbThreshold,T_SetProbThreshold}*/

SetILowTh         return(T_SetILowTh); /*{SetILowTh,T_SetILowTh}*/
SetIHighTh        return(T_SetIHighTh); /*{SetIHighTh,T_SetIHighTh}*/
SetProbHighTh     return(T_SetProbHighTh); /*{SetProbHighTh,T_SetProbHighTh}*/

SetNumInitPoints   return(T_SetNumInitPoints); /*{SetNumInitPoints,T_SetNumInitPoints}*/
SetInitPoint       return(T_SetInitPoint); /*{SetInitPoint,T_SetInitPoint}*/

GetCurvature      return(T_GetCurvature); /*{GetCurvature,T_GetCurvature}*/
GetAdvection      return(T_GetAdvection); /*{GetAdvection,T_GetAdvection}*/
GetVelocity       return(T_GetVelocity); /*{GetVelocity,T_GetVelocity}*/
GetExpansion      return(T_GetExpansion); /*{GetExpansion,T_GetExpansion}*/
GetSkeleton       return(T_GetSkeleton); /*{GetSkeleton,T_GetSkeleton}*/
GetDistMap        return(T_GetDistMap); /*{GetDistMap,T_GetDistMap}*/

SaveDistMap       return(T_SaveDistMap); /*{SaveDistMap,T_SaveDistMap}*/
SaveSecDerGrad    return(T_SaveSecDerGrad); /*{SaveSecDerGrad,T_SaveSecDerGrad}*/

FluxDiffusion     return(T_FluxDiffusion); /*{FluxDiffusion,T_FluxDiffusion}*/
vtkAnisoGS        return(T_vtkAnisoGS); /*{vtkAnisoGS,T_vtkAnisoGS}*/
AnisoSmoothGS     return(AnisoSmoothGS); /*{AnisoSmoothGS,AnisoSmoothGS}*/
init              return(TInit); /*{init,TInit}*/
setcoeff          return(TSetCoeff); /*{setcoeff,TSetCoeff}*/
iterate           return(TIterate); /*{iterate,TIterate}*/
SetNoiseType      return(T_SetNoiseType); /*{SetNoiseType,T_SetNoiseType}*/
SetNoiseSD        return(T_SetNoiseSD); /*{SetNoiseSD,T_SetNoiseSD}*/
GetNoiseSD        return(T_GetNoiseSD); /*{GetNoiseSD,T_GetNoiseSD}*/
GetDAcoeff        return(T_GetDAcoeff); /*{GetDAcoeff,T_GetDAcoeff}*/
SetMask           return(T_SetMask); /*{SetMask,T_SetMask}*/
SetSRADROI        return(T_SetSRADROI); /*{SetSRADROI,T_SetSRADROI}*/
SetRNRADROI       return(T_SetRNRADROI); /*{SetRNRADROI,T_SetRNRADROI}*/
SetRNRADROI_NEW   return(T_SetRNRADROI_NEW); /*{SetRNRADROI_NEW,T_SetRNRADROI_NEW}*/
SetLocalStruct    return(T_SetLocalStruct); /*{SetLocalStruct,T_SetLocalStruct}*/
SetEigenMode      return(T_SetEigenMode); /*{SetEigenMode,T_SetEigenMode}*/
Setdt             return(T_Setdt); /*{Setdt,T_Setdt}*/
Setneighborhood   return(T_Setneighborhood); /*{Setneighborhood,T_Setneighborhood}*/
end               return(TEnd); /*{end,TEnd}*/

AnisoWeickert     return(T_AnisoWeickert); /*{AnisoWeickert,T_AnisoWeickert}*/
AnisoCW           return(T_AnisoCW); /*{AnisoCW,T_AnisoCW}*/

SRAD_qcoeff       return(T_SRAD_qcoeff); /*{SRAD_qcoeff,T_SRAD_qcoeff}*/
AnisoSRAD         return(T_AnisoSRAD); /*{AnisoSRAD,T_AnisoSRAD}*/
AnisoSRAD2        return(T_AnisoSRAD2); /*{AnisoSRAD2,T_AnisoSRAD2}*/
AnisoDPAD         return(T_AnisoDPAD); /*{AnisoDPAD,T_AnisoDPAD}*/
AnisoDPAD2        return(T_AnisoDPAD2); /*{AnisoDPAD2,T_AnisoDPAD2}*/
AnisoNRAD         return(T_AnisoNRAD); /*{AnisoNRAD,T_AnisoNRAD}*/
AnisoLeeAdd2      return(T_AnisoLeeAdd2); /*{AnisoLeeAdd2,T_AnisoLeeAdd2}*/

AnisoRudinMult    return(T_AnisoRudinMult); /*{AnisoRudinMult,T_AnisoRudinMult}*/

AddGaussNoise     return(TAddGaussNoise); /*{AddGaussNoise,TAddGaussNoise}*/

SNR               return(T_SNR); /*{SNR,T_SNR}*/

save              return(T_save); /*{save,T_save}*/

eccentricity      return(T_eccentricity); /*{eccentricity,T_eccentricity}*/

getimage          return(T_getimage); /*{getimage,T_getimage}*/
GetImageFromX     return(T_GetImageFromX); /*{GetImageFromX,T_GetImageFromX}*/

isoarea2D         return(T_isoarea2D); /*{isoarea2D,T_isoarea2D}*/
posarea           return(T_posarea); /*{posarea,T_posarea}*/

ReadCTALine      return(T_ReadCTALine); /*{ReadCTALine,T_ReadCTALine}*/
ReadCTALineRadii return(T_ReadCTALineRadii); /*{ReadCTALineRadii,T_ReadCTALineRadii}*/
WriteCTALine     return(T_WriteCTALine); /*{WriteCTALine,T_WriteCTALine}*/

isosurf           return(T_isosurf); /*{isosurf,T_isosurf}*/
isosurf_inv       return(T_isosurf_inv); /*{isosurf_inv,T_isosurf_inv}*/
isosurf_ijk       return(T_isosurf_ijk); /*{isosurf_ijk,T_isosurf_ijk}*/
isosurf_ras       return(T_isosurf_ras); /*{isosurf_ras,T_isosurf_ras}*/
Surface           return(T_Surface); /*{Surface,T_Surface}*/
vtkDecimate       return(T_vtkDecimate); /*{vtkDecimate,T_vtkDecimate}*/
vtkMarchingCubes  return(T_vtkMarchingCubes); /*{vtkMarchingCubes,T_vtkMarchingCubes}*/
vtkSmooth         return(T_vtkSmooth); /*{vtkSmooth,T_vtkSmooth}*/
vtkWindowedSinc   return(T_vtkWindowedSinc); /*{vtkWindowedSinc,T_vtkWindowedSinc}*/

isoline           return(T_isoline); /*{isoline,T_isoline}*/

AddPoint           return(T_AddPoint); /*{AddPoint,T_AddPoint}*/
NewLine            return(T_NewLine); /*{NewLine,T_NewLine}*/
EndLine            return(T_EndLine); /*{EndLine,T_EndLine}*/
LineAddPointNumber return(T_LineAddPointNumber); /*{LineAddPointNumber,T_LineAddPointNumber}*/

vtkDist           return(T_vtkDist); /*{vtkDist,T_vtkDist}*/
AndreDist         return(T_AndreDist); /*{AndreDist,T_AndreDist}*/

OutFlux           return(T_OutFlux); /*{OutFlux,T_OutFlux}*/
OutFluxScalar     return(T_OutFluxScalar); /*{OutFluxScalar,T_OutFluxScalar}*/
2DFlux            return(T_2DFlux); /*{2DFlux,T_2DFlux}*/
OrientationRatio  return(T_OrientationRatio); /*{OrientationRatio,T_OrientationRatio}*/

computeCC         return(T_computeCC); /*{computeCC,T_computeCC}*/
drawCC            return(T_drawCC); /*{drawCC,T_drawCC}*/
setminCC          return(T_setminCC); /*{setminCC,T_setminCC}*/
Paint             return(T_Paint); /*{Paint,T_Paint}*/
SetLight          return(T_SetLight); /*{SetLight,T_SetLight}*/
SetLightPos       return(T_SetLightPos); /*{SetLightPos,T_SetLightPos}*/
SetLightAmbient   return(T_SetLightAmbient); /*{SetLightAmbient,T_SetLightAmbient}*/
SetLightDiffuse   return(T_SetLightDiffuse); /*{SetLightDiffuse,T_SetLightDiffuse}*/
SetLightSpecular  return(T_SetLightSpecular); /*{SetLightSpecular,T_SetLightSpecular}*/
SetBackground     return(T_SetBackground); /*{SetBackground,T_SetBackground}*/

OwnMaterial         return(T_OwnMaterial); /*{OwnMaterial,T_OwnMaterial}*/
SetColor            return(T_SetColor); /*{SetColor,T_SetColor}*/
SetColorOpacity     return(T_SetColorOpacity); /*{SetColorOpacity,T_SetColorOpacity}*/
SetColors           return(T_SetColors); /*{SetColors,T_SetColors}*/
SetPointsColors     return(T_SetPointsColors); /*{SetPointsColors,T_SetPointsColors}*/
GetLinesLength      return(T_GetLinesLength); /*{GetLinesLength,T_GetLinesLength}*/
GetLinesExtremities return(T_GetLinesExtremities); /*{GetLinesExtremities,T_GetLinesExtremities}*/
GetConnections      return(T_GetConnections); /*{GetConnections,T_GetConnections}*/
SelectLines         return(T_SelectLines); /*{SelectLines,T_SelectLines}*/
RemoveSelection     return(T_RemoveSelection); /*{RemoveSelection,T_RemoveSelection}*/
GetIntensities      return(T_GetIntensities); /*{GetIntensities,T_GetIntensities}*/
Statistics          return(T_Statistics); /*{Statistics,T_Statistics}*/

SetAmbient          return(T_SetAmbient); /*{SetAmbient,T_SetAmbient}*/
SetDiffuse          return(T_SetDiffuse); /*{SetDiffuse,T_SetDiffuse}*/
SetSpecular         return(T_SetSpecular); /*{SetSpecular,T_SetSpecular}*/
SetShininess        return(T_SetShininess); /*{SetShininess,T_SetShininess}*/
SetOpacity          return(T_SetOpacity); /*{SetOpacity,T_SetOpacity}*/
SetOpacityImage     return(T_SetOpacityImage); /*{SetOpacityImage,T_SetOpacityImage}*/
SetColorMaterial    return(T_SetColorMaterial); /*{SetColorMaterial,T_SetColorMaterial}*/
SetVisible          return(T_SetVisible); /*{SetVisible,T_SetVisible}*/

penguin           return(T_penguin); /*{penguin,T_penguin}*/

PrintMatrices     return(T_PrintMatrices); /*{PrintMatrices,T_PrintMatrices}*/ // print the matrices of Viewer3D class

AddObject         return(T_addobj); /*{AddObject,T_addobj}*/
SetCurrentObj     return(T_setcurrentobj); /*{SetCurrentObj,T_setcurrentobj}*/

SetLineWidth      return(T_SetLineWidth); /*{SetLineWidth,T_SetLineWidth}*/

MergePoints       return(T_mergepoints); /*{MergePoints,T_mergepoints}*/
Triangulate       return(T_Triangulate); /*{Triangulate,T_Triangulate}*/
Displace          return(T_Displace); /*{Displace,T_Displace}*/
Translate         return(T_Translate); /*{Translate,T_Translate}*/
Scale             return(T_Scale); /*{Scale,T_Scale}*/
Normals           return(T_Normals); /*{Normals,T_Normals}*/
InvertNormals     return(T_InvertNormals); /*{InvertNormals,T_InvertNormals}*/
Recompute         return(T_Recompute); /*{Recompute,T_Recompute}*/
GetTransform      return(T_GetTransform); /*{GetTransform,T_GetTransform}*/
SetTransform      return(T_SetTransform); /*{SetTransform,T_SetTransform}*/

Interpolate       return(T_Interpolate); /*{Interpolate,T_Interpolate}*/

Skeleton          return(T_Skeleton); /*{Skeleton,T_Skeleton}*/
SimplePoints      return(T_SimplePoints); /*{SimplePoints,T_SimplePoints}*/

NormalField       return(T_NormalField); /*{NormalField,T_NormalField}*/
DirConnectivity   return(T_DirConnectivity); /*{DirConnectivity,T_DirConnectivity}*/
OrientField       return(T_OrientField); /*{OrientField,T_OrientField}*/
OrientPositive    return(T_OrientPositive); /*{OrientPositive,T_OrientPositive}*/

Skeleton2lines    return(T_Skeleton2lines); /*{Skeleton2lines,T_Skeleton2lines}*/
SmoothLines       return(T_SmoothLines);  /*{SmoothLines,T_SmoothLines}*/
RemoveLine        return(T_RemoveLine);   /*{RemoveLine,T_RemoveLine}*/
ConnectLines      return(T_ConnectLines); /*{ConnectLines,T_ConnectLines}*/
ResampleLines     return(T_ResampleLines); /*{ResampleLines,T_ResampleLines}*/
ShortestPath      return(T_ShortestPath); /*{ShortestPath,T_ShortestPath}*/
ShortestPathImage return(T_ShortestPathImage); /*{ShortestPathImage,T_ShortestPathImage}*/
PathFromDispl     return(T_PathFromDispl); /*{PathFromDispl, T_PathFromDispl}*/
PathFromVectField return(T_PathFromVectField); /*{PathFromVectField, T_PathFromVectField}*/
LineRecons        return(T_LineRecons); /*{LineRecons,T_LineRecons}*/

CircleInt         return(T_CircleIntegral); /*{CircleInt,T_CircleIntegral}*/
CircleIntExc      return(T_CircleIntegralExc); /*{CircleIntExc,T_CircleIntegralExc}*/
CircleIntSdExc    return(T_CircleIntSdExc); /*{CircleIntSdExc,T_CircleIntSdExc}*/
CircleMinIntSdExc    return(T_CircleMinIntSdExc); /*{CircleMinIntSdExc,T_CircleMinIntSdExc}*/
LocalExtrema      return(T_LocalExtrema); /*{LocalExtrema,T_LocalExtrema}*/


gnuplot           return(T_gnuplot); /*{gnuplot,T_gnuplot}*/
histo             return(T_histo); /*{histo,T_histo}*/
cumhisto          return(T_cumhisto); /*{cumhisto,T_cumhisto}*/
DisplayHisto      return(T_DisplayHisto); /*{DisplayHisto,T_DisplayHisto}*/

GenRead           return(T_GenRead); /*{GenRead,T_GenRead}*/


Matrix            return(T_Matrix); /*{Matrix,T_Matrix}*/
Invert            return(T_Invert); /*{Invert,T_Invert}*/

SaveStructuredGrid return(T_SaveStructuredGrid); /*{SaveStructuredGrid,T_SaveStructuredGrid}*/

ParamWin          {
//
//============================== PARAMWIN options ====================
//
                  return(T_ParamWin);
} /*{ParamWin,T_ParamWin}*/
BeginBook         return(T_BeginBook); /*{BeginBook,T_BeginBook}*/
EndBook           return(T_EndBook);   /*{EndBook,T_EndBook}*/
AddPage           return(T_AddPage); /*{AddPage,T_AddPage}*/
BeginPanel          return(T_BeginPanel); /*{BeginPanel,T_BeginPanel}*/
EndPanel          return(T_EndPanel); /*{EndPanel,T_EndPanel}*/
AddFloat          return(T_AddFloat); /*{AddFloat,T_AddFloat}*/
AddInt            return(T_AddInt); /*{AddInt,T_AddInt}*/
AddButton         return(T_AddButton); /*{AddButton,T_AddButton}*/
AddBoolean        return(T_AddBoolean); /*{AddBoolean,T_AddBoolean}*/
AddEnum           return(T_AddEnum); /*{AddEnum,T_AddEnum}*/
AddEnumChoice     return(T_AddEnumChoice); /*{AddEnumChoice,T_AddEnumChoice}*/
AddString         return(T_AddString); /*{AddString,T_AddString}*/
AddFilename       return(T_AddFilename); /*{AddFilename,T_AddFilename}*/
SetCallback       return(T_SetCallback); /*{SetCallback,T_SetCallback}*/
SetDragCallback   return(T_SetDragCallback); /*{SetDragCallback,T_SetDragCallback}*/
ShowSlider        return(T_ShowSlider); /*{ShowSlider,T_ShowSlider}*/
CreateWin         return(T_CreateWin); /*{CreateWin,T_CreateWin}*/
Display           return(T_Display); /*{Display,T_Display}*/
BeginBox          return(T_BeginBox); /*{BeginBox,T_BeginBox}*/
EndBox            return(T_EndBox); /*{EndBox,T_EndBox}*/
BeginHorizontal   return(T_BeginHorizontal); /*{BeginHorizontal,T_BeginHorizontal}*/
EndHorizontal     return(T_EndHorizontal); /*{EndHorizontal,T_EndHorizontal}*/
redraw            return(T_redraw); /*{redraw,T_redraw}*/

CreateFlatMesh    return(T_CreateFlatMesh);    /*{CreateFlatMesh,T_CreateFlatMesh}*/
CreateVolume      return(T_CreateVolume);      /*{CreateVolume,T_CreateVolume}*/
vtkCreateFlatMesh return(T_vtkCreateFlatMesh); /*{vtkCreateFlatMesh,T_vtkCreateFlatMesh}*/
Altitude2Position return(T_Altitude2Position); /*{Altitude2Position,T_Altitude2Position}*/
Temp2Altitudes    return(T_Temp2Altitudes);    /*{Temp2Altitudes,T_Temp2Altitudes}*/
GeoCoordinates    return(T_GeoCoordinates);    /*{GeoCoordinates,T_GeoCoordinates}*/
ElevateMesh       return(T_ElevateMesh);       /*{ElevateMesh,T_ElevateMesh}*/
Set3DArrowParam   return(T_Set3DArrowParam); /*{Set3DArrowParam,T_Set3DArrowParam}*/
CreateVectors     return(T_CreateVectors); /*{CreateVectors,T_CreateVectors}*/
ComputeAltitudes  return(T_ComputeAltitudes); /*{ComputeAltitudes,T_ComputeAltitudes}*/
ReadFlow          return(T_ReadFlow); /*{ReadFlow,T_ReadFlow}*/
SetFluidNavFile   return(T_SetFluidNavFile); /*{SetFluidNavFile,T_SetFluidNavFile}*/
DrawEarthCoord    return(T_DrawEarthCoord); /*{DrawEarthCoord,T_DrawEarthCoord}*/

PaintCallback     return(T_PaintCallback); /*{PaintCallback,T_PaintCallback}*/

CreateEllipsoids  return(T_CreateEllipsoids); /*{CreateEllipsoids,T_CreateEllipsoids}*/

import_ami        return(T_import_ami);     /*{import_ami,T_import_ami}*/

import_vtk        return(T_import_vtk);     /*{import_vtk,T_import_vtk}*/
import_itk        return(T_import_itk);     /*{import_itk,T_import_itk}*/
import_wii        return(T_import_wii);     /*{import_wii,T_import_wii}*/
import_filters    return(T_import_filters); /*{import_filters,T_import_filters}*/

amiOFCorr2D       return(T_amiOFCorr2D);  /*{amiOFCorr2D,T_amiOFCorr2D}*/
amiOFVar2D        return(T_amiOFVar2D);   /*{amiOFVar2D,T_amiOFVar2D}*/

vtkDicomRead      return(T_vtkDicomRead); /*{vtkDicomRead,T_vtkDicomRead}*/
vtkMINCRead       return(T_vtkMINCRead);  /*{vtkMINCRead,T_vtkMINCRead}*/

exists            return(T_exists);       /*{exists,T_exists}*/

slice             return(T_slice);        /*{slice,T_slice}*/

argc              return(T_argc);         /*{argc,T_argc}*/
emptyargs         return(T_emptyargs);    /*{emptyargs,T_emptyargs}*/

[0-9]+"."[0-9]+   {
//
//============================ Parse float ====================
//
//  setlocale(LC_NUMERIC,"C");
  setlocale(LC_NUMERIC, "C");
 yyiplval.adouble=atof(yyiptext);
  return(NUMBER);
}


[0-9]+   {
//
//============================ Parse interger ====================
//
//  setlocale(LC_NUMERIC,"C");
  setlocale(LC_NUMERIC, "C");
  yyiplval.adouble=atof(yyiptext);
  return(NUMBER);
}




\"          {
//
//
//============================ Parse string ====================
//
 cpp_string = new string();
 BEGIN(str);
 }

<str>\"      {
  // end of string
  // Not thread safe ...
  BEGIN(0);
  // add the \0 character, why ???...
  cpp_string->append(1,'\0');

  if((yyiplval.astring = new char[cpp_string->length()+1])==NULL) {
    yyiperror(E_MEM);
    return LEX_ERROR;
  }
  // first conversion, we keep char* for astring for now
  strcpy(yyiplval.astring, cpp_string->c_str());
  delete cpp_string;
  cpp_string = NULL;
  return(ASTRING);
}

<str>\n  {
  yyiperror(E_UNTERM_STRING);
}

<str>\\n cpp_string->append(1,'\n');
<str>\\t cpp_string->append(1,'\t');
<str>\\r cpp_string->append(1,'\r');
<str>\\b cpp_string->append(1,'\b');
<str>\\f cpp_string->append(1,'\f');

<str>\\(.|\n) cpp_string->append(1,yyiptext[1]);
#<str>\\(\n) cpp_string->append(1,yyiptext[1]);

<str>[^\\\n\"]+ {
  cpp_string->append(yyiptext);
/*
  char *yptr = yyiptext;

  while (*yptr)
    *string_buf_ptr++ = *yptr++;
*/
}


"$#"  {
  yyiplval.adouble=GB_argc-GB_num_arg_parsed;
  return(NUMBER);
}

\$[0-9]   {
  // TODO allow more than 10 arguments!!
  int n,pos;
  n = yyiptext[1]-'0';
  // TODO: check the position, improve the code here
  pos = n+GB_num_arg_parsed-1;

  if ((pos>=GB_argc)||(pos<0)) {
    boost::format fmt = 
        boost::format("improcess.l \t invalid argument number %d / %d\n");
#ifdef str
  #undef str
      yyiperror( str(fmt % n % (GB_argc-GB_num_arg_parsed)).c_str() );
  #define str 1
#else
      yyiperror( str(fmt % n % (GB_argc-GB_num_arg_parsed)).c_str() );
#endif
    return LEX_ERROR;
//myss1.c_str() );
  }

  // we use GB_argv[n+1] because the first two arguments are the program and the script file
  if((yyiplval.astring = new char[strlen(GB_argv[pos])+1])==NULL) {
    yyiperror(E_MEM);
    return LEX_ERROR;
  }

  strcpy(yyiplval.astring,GB_argv[pos]);

  return(ASTRING);

}

\{          {
//============================ Parse block ====================
//
  if (block_level==0) {
    ami_block = new AmiInstructionBlock();
    ami_block->SetStartingLine(yyiplineno);
    if (GB_debug )cerr << "Starting block at " << yyiplineno << endl;
    block_level++;
    BEGIN(block);
  }
}

<block>\# {
//============================ Parse comment ====================
//
    comment_caller = block;
    BEGIN(comment);
//    printf("begin comment in block \n");
}

<block>"//"  {
    comment_caller = block;
    BEGIN(comment);
//    printf("begin comment in block \n");
}

<block>\n {
  yyiplineno++;
  ami_block->GetBody().append(yyiptext);
}


<block>\{      {
  block_level++;
  ami_block->GetBody().append(1,'{');
}

<block>\}      {

  block_level--;
  if (block_level>0)
    ami_block->GetBody().append(1,'}');
  else {
    BEGIN(0);
    ami_block->GetBody().append(3,'\0');
//    cpp_block->append(1,YY_END_OF_BUFFER_CHAR);

//     printf("block = *%s*\n",block_buf);

/*
    length=ami_block->GetBody().length();

    if((yyiplval.astring = new char[length+3])==NULL)
      yyiperror(E_MEM);
    strcpy(yyiplval.astring,
            ami_block->GetBody().c_str());
    // why add those 3 characters ...??? lex is looking ahead several characters
    // risky in memory ...
    yyiplval.astring[length  ]=YY_END_OF_BUFFER_CHAR;
    yyiplval.astring[length+1]=YY_END_OF_BUFFER_CHAR;
    yyiplval.astring[length+2]=YY_END_OF_BUFFER_CHAR;
*/
    yyiplval.ablock = ami_block;
    // cannot use smart pointers in union ...
    // needs to be freed after use ...

    //ami_block = AmiInstructionBlock_ptr();
    return(ABLOCK);
  }
}


<block>[^\{\}] {
//  char *yptr = yyiptext;
//  while (*yptr)
//    *block_buf_ptr++ = *yptr++;
  ami_block->GetBody().append(yyiptext);
}


\# {
//============================ Parse comment ====================
//
    comment_caller = INITIAL;
    BEGIN(comment);
//  printf("begin comment \n");
}

"//"  {
    comment_caller = INITIAL;
    BEGIN(comment);
//  printf("begin comment \n");
}


<comment>\n {
  //yyiplineno++;
//  printf("end comment from %d \n",comment_caller);
  // use unput to accept the end of the command if any
  unput('\n');
  BEGIN(comment_caller);
}

<comment>.                 {
  // on ecrit ce qu'on veut dans un commentaire ...
}

local::([A-Za-z0-9_])*   {
//
//============================ Parse variable ====================
//
  int context = Vars.GetCurrentContextNumber();
  string text(yyiptext);
  string varname = text.substr(7);
  int result = checkvar(varname.c_str(),context);
  // force next variable to be global
  if (result==IDENTIFIER)
    Vars.SetNextVarContext(context);
  return result;
}

global::([A-Za-z0-9_])*   {
//
//============================ Parse variable ====================
//
  string text(yyiptext);
  string varname = text.substr(8);
  int result = checkvar(varname.c_str(),0);
  // force next variable to be global
  if (result==IDENTIFIER)
    Vars.SetNextVarContext(0);
  return result;
}


([A-Za-z0-9_])*   {
//
//============================ Parse variable ====================
//
   return checkvar(yyiptext);
}


[[:blank:]]       {}

\\\n              {}

\n                {
                      return(END_INSTRUCTION);
                  } /* \n,END_INSTRUCTION */

.                 {

    std::string error_string =" lex error \t invalid characters ";
    yyiperror(error_string.c_str());

  }




%%

//class Variables;
//static Variable* Variables::_vars[MAX_VARS];

//--------------------------------------------------
//       checkvar()
//--------------------------------------------------
//
int checkvar(const char* varname, int context)
//
{

  Variable* var;

//  sprintf(tmp_string,"checkvar()  %s \n",yyiptext);
//  err_print(tmp_string);

//fprintf(stderr,"%s procdecl %d \n",yyiptext,procedure_declaration);

  // the first identifier is the procedure name and must be checked
  if (procedure_declaration==1)
    procedure_declaration++;

  if  ((procedure_declaration!=2)&&
      (Vars.GetVar(varname,&var,context)))   {

    yyiplval.variable = var;
    switch(yyiplval.variable->Type()) {
      case type_image:            return VAR_IMAGE;
        /*{$variable_image,VAR_IMAGE}*/
      case type_imagedraw:        return VAR_IMAGEDRAW;
        /*{$variable_imagedraw,VAR_IMAGEDRAW}*/
      case type_float:            return VAR_FLOAT;
        /*{$variable_float,VAR_FLOAT}*/
      case type_int:              return VAR_INT;
        /*{$variable_int,VAR_INT}*/
      case type_uchar:            return VAR_UCHAR;
        /*{$variable_uchar,VAR_UCHAR}*/
      case type_surface:          return VAR_SURFACE;
        /*{$variable_surface,VAR_SURFACE}*/
      case type_surfdraw:         return VAR_SURFDRAW;
        /*{$variable_surfdraw,VAR_SURFDRAW}*/
      case type_file:             return VAR_FILE;
        /*{$variable_file,VAR_FILE}*/
      case type_c_procedure:      return VAR_C_PROCEDURE;
        /*{$variable_c_procedure,VAR_C_PROCEDURE}*/
      case type_c_image_function: return VAR_C_IMAGE_FUNCTION;
        /*{$variable_c_image_function,VAR_C_IMAGE_FUNCTION}*/
      case type_c_function: return VAR_C_FUNCTION;
        /*{$variable_c_function,VAR_C_FUNCTION}*/
      case type_ami_function:     return VAR_AMI_FUNCTION;
        /*{$variable_ami_function,VAR_AMI_FUNCTION}*/
      case type_string:           return VAR_STRING;
        /*{$variable_string,VAR_STRING}*/
      case type_paramwin:         return VAR_PARAMWIN;
        /*{$variable_paramwin,VAR_PARAMWIN}*/
      case type_matrix:           return VAR_MATRIX;
        /*{$variable_matrix,VAR_MATRIX}*/
      case type_gltransform:      return VAR_GLTRANSFORM;
        /*{$variable_gltransform,VAR_GLTRANSFORM}*/
      case type_array:       {
         VarArray::ptr array =  *(VarArray::ptr*)yyiplval.variable->Pointer();
         switch(array->Type()) {
            case type_surface:    return VAR_ARRAY_SURFACE;
            /*{$variable_surface_array,VAR_ARRAY_SURFACE}*/
            case type_image:      return VAR_ARRAY_IMAGE;
            /*{$variable_image_array,VAR_ARRAY_IMAGE}*/
           default:
              err_print("Array type not available \n");
         }
         break;
      }
      default:
        err_print("Variable type still not available \n");
    }

  }

  if (strlen(varname)+1>IDENT_MAX_SIZE)   {
    fprintf(stderr,"checkvar() identifier too long %s \n",varname);
  }
  strcpy(yyiplval.ident,varname);
  return(IDENTIFIER);
}










