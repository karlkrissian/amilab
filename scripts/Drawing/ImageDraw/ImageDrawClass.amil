
func "Common/ScriptGui"

if (!exists(ImageDrawClass)) {

  Class ImageDrawClass : public ScriptGui \
  {
    func "Segmentation/RegionGrowing/RegionGrowingClass"
    RegionGrowingClass ::rg

    func "Denoising/AnisoGS_NRAD/AnisoGS_NRADClass"
    ::AnisoGS_NRADClass = &AnisoGS_NRADClass 

    Class ::backup_voxel {
      ::x   = 0
      ::y   = 0
      ::z   = 0
      ::val = 0
      ::newval = 0
    }


    #---------------------------------------------------------------------------
    proc ::Init() \
    {
      
      ::input_name   = "","Name of the input image variable"
      ::mask_name    = "", "Name of an input mask image"
      ::last_input_name = ""

      ::mask_color  = wx.wxColour(250,10,10,255)
      Comments( ::mask_color, "Displayed color of the manually segmented image")
      ::mask_opacity = INT(150), "mask opacity (alpha component)" 
      ::enable_mask  = UCHAR(1), "enable/disable mask"

      ::mask_color.Set(   ::mask_color.Red(),::mask_color.Green()\
                         ,::mask_color.Blue(),::mask_opacity)

      ::html_filename = GetScriptsDir+"/ImageDraw/Doc/ImageDraw/index.html"

      ::options = VarVector()
        ::options.push_back("Draw")
        ::options.push_back("Erase")
      ::draw_value = VarVector()
        ::draw_value.push_back(255)
        ::draw_value.push_back(0)
      mess = ""
      for n=0 to ::options.size()-1 { mess += "'%1%' " % ::options[n]; }
      ::paint_option = INT(0), "Painting options (%1%)" % mess

      ::enable_draw = UCHAR(1), "Enable/Disable drawing"

      ::pencil_thickness = INT(1), "Pencil thickness"

      ::in_update = 0

      ::x = INT(0)
      ::y = INT(0)
      ::z = INT(0)
      ::_slice = INT(0)
      
      ::enable_draw_range = UCHAR(0), "Enable/disable drawing intensity range"
      ::draw_range_min = INT(0   ),   "Minimal intensity for drawing"
      ::draw_range_max = INT(1000),   "Maximal intensity for drawing"
      
      ::rg_current_slice = UCHAR(1),  "Apply Region Growing on current slice"
      ::rg_current_zoom  = UCHAR(1),  "Apply Region Growing on zoom"
      ::rg_min_intensity = 0,         "minimal intensity for Region Growing"
      ::rg_max_intensity = 0,         "maximal intensity for Region Growing"
      ::rg_thickness     = INT(0),    "Grow in (2n+1) slices"

      ::STD_winsize      = INT(40),   "Window radius to estimate the noise STD (2n+1)^3"
      ::localstats_winsize = INT(1),  "Window radius to estimate the local statistics" +\
                                      " for the 3D region growing"
                                      
      ::blood_contrast_change = INT(20), "Allow mean intensity changes +/- this value"

      ::show_local_denoising  = UCHAR(1), "Show denoising locally"

      ::allow_undo = UCHAR(1),            "Enable Undo/Redo"
      
      ::denoise_thickness = INT(3),       "Denoising ROI will include the current XY slice +/- this value"
      
      # TODO: backups
      ::backup_actions = VarVector()
      ::max_backups = 50
      # add 10 backups
      for n=0 to ::max_backups-1 {
        del ptlist
        ptlist = VarVector()
        ::backup_actions.push_back( &ptlist)
      }
      ::first_backup   = 0
      ::last_backup    = 0
      ::current_backup = 0
    }

    #---------------------------------------------------------------------------
    proc ::load_input() {

      if (::input_name!=::last_input_name) { 
        del ::input_draw; 
        del ::input; 
      }
      eval "::input = &"+::input_name+";"
      ::last_input_name = ::input_name
      if (::input_name=="BrowseImage") {
        ::input_name = "::input"
        ::win.Update(-1)
      }

      # Create mask image from input
      ::mask_image <<= (UCHAR) ::input
      ::mask_image = 0
      ::mask_backup <<= ::mask_image
      if (exists(::win)) {
        m = min(::input)
        M = max(::input)
        # Region Growing Intensity Range
        ::win.FloatConstraints(::rgminint_id,m,M,m)
        ::win.FloatConstraints(::rgmaxint_id,m,M,M)

        # Drawing Intensity Range
        ::draw_range_min = m
        ::draw_range_max = M
        ::win.FloatConstraints(::rangemin_id,m,M,m)
        ::win.FloatConstraints(::rangemax_id,m,M,M)
        ::win.Update(-1)
      }
    }
    Comments( ::load_input, "References the input image in a local image "+\
                            "member named 'input'")

    #---------------------------------------------------------------------------
    proc ::CB_mask_image() {
      if (!exists(::mask_image)) {
        ::load_input()
      }
      eval "::mask_image = %1%;" % ::mask_name
    }

    
    #printn "%1%: " % ::_slice  + "( %1% , " % ::x + "%1%, " % ::y + "%1%)" % ::z
    #---------------------------------------------------------------------------
    proc ::ApplyPencil() \
    {
      ::input_draw.CursorToImage( ::mouse_x,::mouse_y,\
                                  &::x,&::y,&::z,&::_slice)
      if ::_slice!=-1 {
        ::DrawFast(::x,::y,::z)
      }
      ::input_draw.update()
    }

    #---------------------------------------------------------------------------
    proc ::OnMouseDraw( OBJECT event) \
    {
      ::mouse_x = event.GetX()
      ::mouse_y = event.GetY()
      #printn " %1%, " % ::mouse_x + "%1%" % ::mouse_y
      dopaint = ::enable_draw \
                && event.LeftIsDown() \
                && !event.ShiftDown() \
                && !event.AltDown()   \
                && !event.ControlDown() 
      if dopaint {
        ::ApplyPencil()
      }
      event.Skip(); 
    }

    #---------------------------------------------------------------------------
    proc ::OnMotion( OBJECT event) \
    {
      ::OnMouseDraw(&event)
      ::DrawPencilLimits()
    }

    #---------------------------------------------------------------------------
    proc ::OnEraseBg( OBJECT event) \
    {
      #printn "::OnEraseBg"
      event.GetDC().GradientFillLinear(::win.GetClientRect(), \
            wx.wxColour(200,200,200), wx.wxColour(150,150,255), wx.wxRIGHT)
    }

    #---------------------------------------------------------------------------
    proc ::OnLeftDown( OBJECT event) \
    {
      if ::enable_draw {
        #printn "backup"
        # Add a new backup if the current one is not empty
        # or if there is only one left
        if (::backup_actions[::current_backup].size() != 0) ||\
            (::first_backup==::last_backup) {
          ::current_backup = (::current_backup+1) % ::max_backups
          if (::first_backup==::current_backup) {
            ::first_backup = (::first_backup+1) % ::max_backups
          }
          ::last_backup = ::current_backup
          ::backup_actions[::current_backup].clear()
        }
        #::mask_backup = ::mask_image
      }
      ::OnMouseDraw(&event)
    }


    #---------------------------------------------------------------------------
    proc ::BackupInfo() \
    {
      printn "------------------------------------"
      n = ::first_backup
      ok =  true
      while ok {
        mess = " saved points for %1%: " % n + \
                 "%1%" % ::backup_actions[n].size()
        if n==::current_backup {
          mess += "*** current ***"
        }
        printn mess
        n = (n+1) % ::max_backups
        ok = (n != ((::last_backup+1)%::max_backups))
      }
      printn "------------------------------------"
    }

    #---------------------------------------------------------------------------
    proc ::OnLeftUp( OBJECT event) \
    {
      #::BackupInfo()
      event.Skip()
    }

    #---------------------------------------------------------------------------
    proc ::OnWheel( OBJECT event) \
    {
      if event.ShiftDown() {
        rot = event.GetWheelRotation()
        if rot>0 {
          if (::pencil_thickness<20) { ::pencil_thickness++;}
        }
        if rot<0 {
          if (::pencil_thickness>1) { ::pencil_thickness--;}
        }
        ::input_draw.update()
        ::win.Update(::pencil_thickness_id)
        #event.Skip()
      } else {
        event.Skip()
      }
    }

    #---------------------------------------------------------------------------
    proc ::DrawPencilLimits() \
    {
      if (exists(::mouse_x)) {
        ::input_draw.CursorToImage( ::mouse_x,::mouse_y,\
                                    &::x,&::y,&::z,&::_slice)
        if ::enable_draw && (::_slice==0) {
          ::input_draw.SetPenColor(&wx.wxColour(173,216,30))
          if ::pencil_thickness % 2 ==1 {
            d = (FLOAT)::pencil_thickness/2
            #printn "impar "+ "%1%," % (::x-d) + "%1%," % (::x+d)
            # put d first to get float result
            ::input_draw.DrawLineZ(-d+::x,-d+::y, d+::x,-d+::y)
            ::input_draw.DrawLineZ( d+::x,-d+::y, d+::x, d+::y)
            ::input_draw.DrawLineZ( d+::x, d+::y,-d+::x, d+::y)
            ::input_draw.DrawLineZ(-d+::x, d+::y,-d+::x,-d+::y)
          } else {
            d = (FLOAT)::pencil_thickness/2
            #printn "par"+ "%1%," % (::x-d+0.5) + "%1%," % (::x+d+0.5)
            ::input_draw.DrawLineZ(0.5+::x-d,0.5+::y-d,0.5+::x+d,0.5+::y-d)
            ::input_draw.DrawLineZ(0.5+::x+d,0.5+::y-d,0.5+::x+d,0.5+::y+d)
            ::input_draw.DrawLineZ(0.5+::x+d,0.5+::y+d,0.5+::x-d,0.5+::y+d)
            ::input_draw.DrawLineZ(0.5+::x-d,0.5+::y+d,0.5+::x-d,0.5+::y-d)
          }
          ::input_draw.update()
        }
      }
      
    }

    #---------------------------------------------------------------------------
    proc ::Display() \
    {
      if (!exists(::input) || (::input_name!=::last_input_name)) { 
        ::load_input(); 
      }
      show ::input
      ::input_draw.PaintCallback(&::DrawPencilLimits);
      ::input_draw.SetMaskImage(  &::mask_image)
      ::input_draw.SetMaskColor(  &::mask_color)
      ::input_draw.SetUseMask(    ::enable_mask)
      #::input_draw.PaintCallback( &::Draw)

      # test bg of ::win
      del ::evh_win_erasebg
      ::evh_win_erasebg = wx.wxAmiEventHandler(::OnEraseBg)
      ::win.Connect(wx.wxEVT_ERASE_BACKGROUND, \
                    ::evh_win_erasebg.GetEraseEventFunction(),\
                    NULL,::evh_win_erasebg)
      
      # Set Mouse Motion Event
      del ::evh_mouse_motion
      ::evh_mouse_motion     = wx.wxAmiEventHandler(&::OnMotion)
      ::input_draw.GetDrawingWindow().Connect( wx.wxEVT_MOTION,\
                      &::evh_mouse_motion.GetMouseEventFunction(),\
                      &NULL,&::evh_mouse_motion)

      # Set Mouse Left Button
      del ::evh_mouse_left
      ::evh_mouse_left     = wx.wxAmiEventHandler(&::OnLeftDown)
      ::input_draw.GetDrawingWindow().Connect( wx.wxEVT_LEFT_DOWN,\
                      &::evh_mouse_left.GetMouseEventFunction(),\
                      &NULL,&::evh_mouse_left)

      del ::evh_mouse_left_up
      ::evh_mouse_left_up   = wx.wxAmiEventHandler(&::OnLeftUp)
      ::input_draw.GetDrawingWindow().Connect( wx.wxEVT_LEFT_UP,\
                      &::evh_mouse_left_up.GetMouseEventFunction(),\
                      &NULL,&::evh_mouse_left_up)

      del ::evh_mouse_wheel
      ::evh_mouse_wheel   = wx.wxAmiEventHandler(&::OnWheel)
      ::input_draw.GetDrawingWindow().Connect( wx.wxEVT_MOUSEWHEEL,\
                      &::evh_mouse_wheel.GetMouseEventFunction(),\
                      &NULL,&::evh_mouse_wheel)

      # Set Char Event
      del ::evh_char
      ::evh_char     = wx.wxAmiEventHandler(&::OnChar)
      ::input_draw.GetDrawingWindow().Connect( wx.wxEVT_CHAR,\
                      &::evh_char.GetKeyEventFunction(),\
                      &NULL,&::evh_char)

      del ::initial_cursor
      ::initial_cursor = ::input_draw.GetDrawingWindow().GetCursor()

    }
    Comments(::Display, "Display the current image")
    
    #---------------------------------------------------------------------------
    proc ::OnChar( OBJECT event) \
    {
      printn "OnChar '%1%'" %  event.GetUnicodeKey()
      event.Skip()
    }

    #---------------------------------------------------------------------------
    proc ::Update() {
      if (!::in_update) {
        ::in_update = 1
        #printn "::Update"
        ::input_draw.update()
        ::in_update = 0
      }
    }


    #---------------------------------------------------------------------------
    # take care of backups
    proc ::DrawPoint( NUM x, NUM y, NUM z, NUM val) \
    {
      if (::enable_draw_range) {
        inval = ::input(x,y,z)
        ok = (inval>=::draw_range_min) && (inval<=::draw_range_max) 
      } else { ok = true; }
      if (ok) {
        ::backup_voxel v
        current_val = ::mask_image(x,y,z)
        if val!=current_val {
          v.x = x; v.y = y; v.z = z; v.val = current_val; v.newval = val
          ::backup_actions[::current_backup].push_back(&v)
          ::mask_image.setpos(x,y,z)
          ::mask_image.set(val)
        }
      }
      #printn " saved points : %1%" % ::backup_actions[::current_backup].size()
    }


    #---------------------------------------------------------------------------
    proc ::DrawFast( NUM x, NUM y, NUM z) \
    {
      if ::pencil_thickness==1 {
        if (::allow_undo) {
          ::DrawPoint( x,y,z, ::draw_value[::paint_option])
        } else {
          ::mask_image.setpos(x,y,z)
          ::mask_image.set(::draw_value[::paint_option])
        }
      } else {
        min_t = floor((FLOAT)::pencil_thickness/2-0.1)
        max_t = floor((FLOAT)::pencil_thickness/2)
        val = ::draw_value[::paint_option]
        if ::_slice == 0 {
          min_x = max(0,x-min_t)
          max_x = min(::input.tx-1,x+max_t)
          min_y = max(0,y-min_t)
          max_y = min(::input.ty-1,y+max_t)
          if (::allow_undo) {
            for i=min_x to max_x {
              for j=min_y to max_y {
                ::DrawPoint(i,j,z,val)
              }
            }
          } else {
            subim = ::mask_image[min_x:max_x,min_y:max_y,z:z]
            subim = val
            ::mask_image.putimage(subim)
          }
        } else {
          if ::_slice == 1 {
            min_x = max(0,x-min_t)
            max_x = min(::input.tx-1,x+max_t)
            min_z = max(0,z-min_t)
            max_z = min(::input.tz-1,z+max_t)
            for i=min_x to max_x {
              for j=min_z to max_z {
                ::DrawPoint(i,y,j,val)
              }
            }
          } else {
            if ::_slice == 2 {
              min_y = max(0,y-min_t)
              max_y = min(::input.ty-1,y+max_t)
              min_z = max(0,z-min_t)
              max_z = min(::input.tz-1,z+max_t)
              for i=min_y to max_y {
                for j=min_z to max_z {
                  ::DrawPoint(x,i,j,val)
                }
              }
            }
          }
        }
      }
    }

    #---------------------------------------------------------------------------
    proc ::Draw() {
      if (!::in_update) {
        if (!exists(::input_draw)) { ::load_input(); }
        if (::enable_draw)&&(exists(::input_draw)) {
          x = ::input_draw.GetXPos()
          y = ::input_draw.GetYPos()
          z = ::input_draw.GetZPos()
          ::DrawFast(x,y,z)
        }
      }
    }
    

    #---------------------------------------------------------------------------
    proc ::OnColor() \
    {
      ::input_draw.SetMaskColor(&::mask_color)
      ::Update()
    }

    #---------------------------------------------------------------------------
    proc ::OnOpacity() \
    {
      ::mask_color.Set(   ::mask_color.Red(),::mask_color.Green()\
                         ,::mask_color.Blue(),::mask_opacity)
      ::input_draw.SetMaskColor(&::mask_color)
      ::Update()
    }

    #---------------------------------------------------------------------------
    proc ::OnEnableMask() \
    {
      ::input_draw.SetUseMask(&::enable_mask)
      ::Update()
    }

    #---------------------------------------------------------------------------
    proc ::OnPencil() \
    {
      #tb_item = ::tb.FindToolByIndex(0)
      #checked = tb_item.GetState() & wx.wxAUI_BUTTON_STATE_CHECKED
      ::paint_option = 0
      ::enable_draw  = 1
      ::win.Update(-1)

      if (exists(::input_draw)) {
        im = ::icons._Pencil.Mirror(false).Rescale(16,16)
        im.ConvertAlphaToMask()
        ::input_draw.GetDrawingWindow().SetCursor(\
            &wx.wxCursor(&im))
      }
    }

    #---------------------------------------------------------------------------
    proc ::OnEraser() \
    {
      ::paint_option = 1
      ::enable_draw  = 1
      ::win.Update(-1)

      if (exists(::input_draw)) {
        im = ::icons._Eraser.Mirror(false).Rescale(16,16)
        im.ConvertAlphaToMask()
        ::input_draw.GetDrawingWindow().SetCursor(\
            &wx.wxCursor(&im))
      }
    }

    #---------------------------------------------------------------------------
    proc ::OnTarget() \
    {
      ::enable_draw = 0
      ::win.Update(-1)

      if (exists(::input_draw)) {
        ::input_draw.GetDrawingWindow().SetCursor(\
            &wx.wxCursor(&::initial_cursor))
      }
    }

    #---------------------------------------------------------------------------
    proc ::OnUndo() \
    {
      if (::current_backup!=::first_backup) {
        # revert current last backup
        vlist = &::backup_actions[::current_backup]
        for n = 0 to vlist.size()-1 {
          del v
          v = &vlist[n]
          ::mask_image.setpos(v.x,v.y,v.z)
          ::mask_image.set(v.val)
        }
        # decrement current_backup
        ::current_backup = (::current_backup+::max_backups-1) % ::max_backups
        ::input_draw.update()
        ::BackupInfo()
      }
    }

    #---------------------------------------------------------------------------
    proc ::OnRedo() \
    {
      if (::current_backup!=::last_backup) {
        ::current_backup = (::current_backup+1) % ::max_backups
        vlist = &::backup_actions[::current_backup]
        for n = 0 to vlist.size()-1 {
          del v
          v = &vlist[n]
          ::mask_image.setpos(v.x,v.y,v.z)
          ::mask_image.set(v.newval)
        }
        ::input_draw.update()
      }
      ::BackupInfo()
    }
    
    #---------------------------------------------------------------------------
    # link the tool with index id to the method ::On+${toolname}
    # for example toolname="Pencil", will use ::OnPencil
    #
    proc ::SetToolbarCommand( NUM id, STRING toolname) \
    {
      eval "::evh_On%1% = wx.wxAmiEventHandler(&::On%1%);" % toolname 
      eval "::tb.Connect( id, wx.wxEVT_COMMAND_MENU_SELECTED"+\
                         ",&::evh_On%1%.GetEventFunction()" % toolname +\
                         ",&NULL,&::evh_On%1%);" % toolname
    }

    #---------------------------------------------------------------------------
    # Add a tool to the toolbar
    # @param id tool id
    # @param tooliconname is the tool filename
    # @param toolname is the name of the tool image variable
    # @param toolhelp is the tooltip associated with the new tool
    #
    proc ::AddToolbarCommand(  NUM id \
                              ,STRING tooliconname \
                              ,STRING toolname \
                              ,STRING toolhelp \
                              ,NUM kind \
                            ) \
    {
      eval "icon_ok = exists(::icons->_%1%);" % toolname
      if !icon_ok { 
        ::icons.LoadIconPNG2(tooliconname,toolname)
      }
      eval "iconimage = &::icons._%1%;" % toolname
      bm = wx.wxBitmap(&iconimage.Copy().Rescale(16,16))
      ::tb.AddTool( id, toolname, &bm, toolhelp, kind)
      ::SetToolbarCommand( id, toolname)
    }

    #---------------------------------------------------------------------------
    proc ::AddToolbar() \
    {
      ::mgr = &ami.MainFrame.GetAuiManager()
      #del ::tb
      ::tb = wx.wxAuiToolBar(&ami.MainFrame, wx.wxID_ANY);
      ::tb.SetToolBitmapSize(wx.wxSize(16,16));

      tb_id = 20000+::tb.GetToolCount()

      #--------------------------------------------------
      ::tb.AddSeparator()
      #
      # Radio items : drawing mode
      #
      # Add Pencil icon
      id=0
      ::AddToolbarCommand(  tb_id+id,"Pencil","Pencil","Draw with the pencil"\
                            ,wx.wxITEM_RADIO)
      # Eraser icon
      id++
      ::AddToolbarCommand(  tb_id+id,"Eraser","Eraser","Erase with the pencil"\
                            ,wx.wxITEM_RADIO)

      # Standard cursor icon
      id++
      ::AddToolbarCommand(  tb_id+id,"Target","Target"\
                            ,"Standard features, drawing disabled"\
                            ,wx.wxITEM_RADIO)

      #--------------------------------------------------
      ::tb.AddSeparator()
      # Undo/Redo
      id++
      ::AddToolbarCommand(  tb_id+id,"Undo","Undo"\
                            ,"Undo last draw"\
                            ,wx.wxITEM_NORMAL)
      id++
      ::AddToolbarCommand(  tb_id+id,"Redo","Redo"\
                            ,"Redo last undo"\
                            ,wx.wxITEM_NORMAL)

      #id=id+1
      #icon_32=GetScriptsDir+"/Icons/png/32x32/Preview.png"
      #wxim = wx.wxImage(icon_32)
      #bm = wx.wxBitmap(&wxim.Rescale(16,16))
      #::tb.AddTool( tb_id+id, "Preview", &bm,"Preview of the current volume")


      ::tb.Realize()

      #add the toolbars to the manager
      pi = wx.wxAuiPaneInfo().\
                  Name("ImageDraw").Caption("Image Drawing Tools").\
                  ToolbarPane().Top().Position(2).\
                  LeftDockable(false).RightDockable(false)
      ::mgr.AddPane(&::tb, &pi);
      ::mgr.Update()

    }



    #---------------------------------------------------------------------------
    proc ::GetMaskFilename( ) \
    {
      return =::GetParamFilename()

      ## Use input image if available
      #if exists(::input_name) {
        ## make replacements to have a valid name
        #wx_name = wx.wxString(::input_name)
        #wx_name.Replace("/","_")
        #wx_name.Replace("::","_")
        #wx_name.Replace(" ", "_")
        #wx_name.Replace(".", "_")
        #wx_name.Replace("(", "_")
        #wx_name.Replace(")", "_")
        #wx_name.Replace("[", "_")
        #wx_name.Replace("]", "_")
        #wx_name.Replace("-", "_")
        #wx_name.Replace("+", "_")
        #return = wx.FromWxString(wx_name)
      #} else {
        #return = ::classname
      #}
    }

    #---------------------------------------------------------------------------
    proc ::SaveImage() \
    {
      if exists(::mask_image) {
        n=0
        fileexists=true
        filename0 = ::GetMaskFilename()

#now = wx.wxDateTime.Now()
#> printn now.GetDay()
#> printn now.GetMonth()
#> printn now.GetHour()
#> printn now.GetMinute()

        while fileexists {
          n++
          filename = ::scriptdata_path+"/"+filename0+"_manual%1%.ami.gz" % n
          fileexists=wx.wxFileName.FileExists(filename)
        }
        SetStatusText("Saving %1%" % filename)
        printn "min = %1%" % min(::mask_image)
        printn "max = %1%" % max(::mask_image)
        printn "mean = %1%" % mean(::mask_image)
        ::mask_image.save filename
        ::maskimagelistgui.Scan()
      }
    }

    #---------------------------------------------------------------------------
    proc ::ScanMasks() \
    {
      ::maskimagelistgui.Scan()
    }

    #---------------------------------------------------------------------------
    proc ::ReadImage() \
    {
      selection = ::maskimagelistgui.GetSelected()
      # keep only the last selected file for the moment
      if selection.size()>0 {
        ::mask_filename = selection.back()
        eval "::mask_image <<= Image \"%1%\";" % ::mask_filename
      }
    }

    #---------------------------------------------------------------------------
    proc ::MaskFilterAll() \
    {
      ::maskimagelistgui.ClearFileSpecs()
      ::maskimagelistgui.AddFileSpec("*_manual*.ami.gz")
      ::ScanMasks()
    }

    #---------------------------------------------------------------------------
    proc ::MaskFilterCurrent() \
    {
      ::maskimagelistgui.ClearFileSpecs()
      filename = ::GetMaskFilename()
      ::maskimagelistgui.AddFileSpec(filename+"_manual*.ami.gz")
      ::ScanMasks()
    }

    #---------------------------------------------------------------------------
    proc ::ReadMASK() \
    {
      selection = ::maskimagelistgui.GetSelected()

      # keep only the last selected file for the moment
      if selection.size()>0 {
        input_file = selection.back()
        # TODO: need to have the constant wxRICHTEXT_TYPE_ANY ..., 
        # using value 1 here
        # could give information about the file ...
        #::txtctrl.DoLoadFile(param_file,1)
      }
    }

    #---------------------------------------------------------------------------
    #
    proc ::AddIOPage( OBJECT win) \
    {
      # using alWxFileList
      func "WxUtils/alWxFileList"
      alWxFileList ::maskimagelistgui

      # Setup ::filelistgui
      ::maskimagelistgui.AddFileSpec("*.ami.gz")
      #::ROIfilelistgui.SetSelectionCommand(&::OnSelection)

      ::maskimagelistgui.ClearPaths()
      ::InitUserScriptData()
      printn "::scriptdata_path %1%" % ::scriptdata_path
      ::maskimagelistgui.AddPath(::scriptdata_path)
      ::maskimagelistgui.SetSelectionCommand(&::ReadMASK)

      win.AddPage("Disk")
        win.BeginHorizontal()
          win.AddButton("Save",&::SaveImage)
          win.SetPositionProp(1,2)
          win.AddButton("Read",&::ReadImage)
          win.SetPositionProp(1,2)
          #win.AddButton("Scan",&::ScanParameters)
          win.SetPositionProp(1,2)
        win.EndHorizontal()

        win.BeginBoxPanel("Filter")
          win.BeginHorizontal()
            win.AddButton("All",&::MaskFilterAll)
            win.SetPositionProp(1,2)
            win.AddButton("Current",&::MaskFilterCurrent)
            win.SetPositionProp(1,2)
          win.EndHorizontal()
        win.EndBoxPanel()

        ::maskimagelistgui.AddGui(&win)
        ::txtctrl = wx.wxRichTextCtrl(&win.CurrentParent())
        win.AddWidget(&::txtctrl,1)
      ::ScanMasks()
    }

    #---------------------------------------------------------------------------
    proc ::AutoRangeRegGrow() {
      z = ::input_draw.GetZPos()
      ::rg_input = ::input[:,:,z:z]
      # extract slice from mask
      ::rg_init  = ::mask_image[:,:,z:z]
      ::rg_min_intensity = min[::rg_init>0](::rg_input)
      ::rg_max_intensity = max[::rg_init>0](::rg_input)
      ::win.Update(-1)
    }

    #---------------------------------------------------------------------------
    proc ::TryRegGrow() {
      # extract current slice and zoom from display
      if (exists(::input_draw)) {
        z = ::input_draw.GetZPos()
        if (exists(::rg_z)) {
          if (z!=::rg_z)||(::rg_thick!=::rg_thickness) {
            printn "Deleting..."
            del ::rg_input
            del ::rg_init
            del ::rg_res_draw
            del ::rg_res
          }
        }
        ::rg_z     = z
        ::rg_thick = ::rg_thickness

        zmin = z-::rg_thickness
        zmax = z+::rg_thickness
        # extract slice from input
        ::rg_input = ::input[:,:,zmin:zmax]
        # extract slice from mask
        ::rg_init  = ::mask_image[:,:,zmin:zmax]

        rg = Algorithms.algorithms.ami_IntensityBasedRegionGrowing\
            .IntensityBasedRegionGrowing(&::rg_input,&::rg_init)
        rg.SetMin(::rg_min_intensity)
        rg.SetMax(::rg_max_intensity)
        rg.Evolve()
        #return = initmask
        ::rg_res = (rg.ami_RegionGrowingBase.GetStateImage()==2)*255
        show ::rg_res
      }
    }

    #---------------------------------------------------------------------------
    proc ::ApplyRegGrow() {
      if (exists(::rg_res)) {
        ::mask_image.putimage(::rg_res)
        show ::input
      }
    }

    #---------------------------------------------------------------------------
    proc ::UndoRegGrow() {
      if (exists(::rg_init)) {
        ::mask_image.putimage(::rg_init)
        show ::input
      }
    }

    #---------------------------------------------------------------------------
    proc ::EstimateNoiseSTD() {
      # extract current slice and zoom from display
      if (exists(::input_draw)) {
        
        x = ::input_draw.GetXPos()
        y = ::input_draw.GetYPos()
        z = ::input_draw.GetZPos()

        bsize = ::STD_winsize // box size
        xmin = x - bsize
        xmax = x + bsize
        ymin = y - bsize
        ymax = y + bsize
        zmin = z - bsize
        zmax = z + bsize
        
        # extract slice from input
        b_input = ::input[xmin:xmax,ymin:ymax,zmin:zmax]

        ::estimated_noise_var = Func_Compute_sigma2_Gaussian_mode(::input,b_input)
        printn "estimated STD = %1%" % sqrt(::estimated_noise_var)
      }
    }

    #---------------------------------------------------------------------------
    proc ::EstimateNoiseSTDAll() {
    
        bsize = (FLOAT) ::STD_winsize // box size
        vol_std = Resize(::input,\
                         (FLOAT)::input.tx/bsize,\
                         (FLOAT)::input.ty/bsize,\
                         (FLOAT)::input.tz/bsize,1)

        for x=0 to vol_std.tx-1 {
          printn "x=%1%" % x + "/%1%" % (vol_std.tx-1)
          percent = (FLOAT)x/(vol_std.tx-1)*100
          SetProgress(percent)
          for y=0 to vol_std.ty-1 {
            for z=0 to vol_std.tz-1 {
              x1 = (vol_std.trx+x*vol_std.vx-::input.trx)/::input.vx
              y1 = (vol_std.try+y*vol_std.vy-::input.try)/::input.vy
              z1 = (vol_std.trz+z*vol_std.vz-::input.trz)/::input.vz
              xmin = max(0           ,x1 - bsize)
              xmax = min(::input.tx-1,x1 + bsize)
              ymin = max(0           ,y1 - bsize)
              ymax = min(::input.ty-1,y1 + bsize)
              zmin = max(0           ,z1 - bsize)
              zmax = min(::input.tz-1,z1 + bsize)
        
              # extract slice from input
              b_input <<= ::input[xmin:xmax,ymin:ymax,zmin:zmax]

              noise_var = Func_Compute_sigma2_Gaussian_mode(::input,b_input)
              vol_std.setpos(x,y,z)
              vol_std.set(sqrt(noise_var))
              
            }
          }
        }
        ::vol_std <<= vol_std
        SetProgress(0)
    }

    #---------------------------------------------------------------------------
    proc ::PrecomputeStats() \
    {
      # ignore weights for the moment
      ::weights = (UCHAR) ((::input>-100)*(::input<700))
      ::min_weight = 0.01
      
      SetStatusText("::PrecomputeStats init")
      # compute weighted local mean intensity
      ::lm    = localmean2(::input*::weights,::localstats_winsize)
      w_lm    = localmean2(::weights        ,::localstats_winsize)

      SetStatusText("::PrecomputeStats local mean")
      # set minimal weight, and divide by weights
      w_lm = (w_lm>::min_weight)*w_lm+(w_lm<=::min_weight)*::min_weight
      ::lm = ::lm/w_lm
      ::lm = (w_lm>2*::min_weight)*::lm

      SetStatusText("::PrecomputeStats local std")
      # compute weighted local standard deviation of intensity
      var = localmean2(::input*::input*::weights,::localstats_winsize)
      var = var/w_lm 
      var = (w_lm>2*::min_weight)*var
      var = var-::lm*::lm
      ::sd = sqrt(var)
      SetStatusText("::PrecomputeStats done")
    }

    #---------------------------------------------------------------------------
    proc ::Grow3D() {
      ok = (exists(::estimated_noise_var)||exists(::vol_std))&&exists(::lm)&&exists(::sd)
      printn "ok = %1%" % ok
      if (ok) {

        # get local mean at current point
        x = ::input_draw.GetXPos()
        y = ::input_draw.GetYPos()
        z = ::input_draw.GetZPos()
        current_localmean = ::lm(x,y,z)
        printn "current_localmean = %1%" % current_localmean
      
      
        # create condition image
        if exists(::vol_std) {
          vol_std2 = Resize(::vol_std,::lm.tx,::lm.ty,::lm.tz,1)
          evolveim = abs(::lm-current_localmean) < (::blood_contrast_change+3*vol_std2)
          evolveim = evolveim*(::sd<sqrt(2)*vol_std2)
          del vol_std2
        } else {
          evolveim = abs(::lm-current_localmean) < (3*sqrt(::estimated_noise_var))
          evolveim = evolveim*(::sd<sqrt(2)*sqrt(::estimated_noise_var))
        }
        
        if (exists(::rg_z)) {
          if (z!=::rg_z)||(::rg_thick!=::rg_thickness) {
            printn "Deleting..."
            del ::rg_input
            del ::rg_init
            del ::rg_res_draw
            del ::rg_res
          }
        }
        ::rg_z     = z
        ::rg_thick = ::rg_thickness

        zmin = max(0,z-::rg_thickness)
        zmax = min(::lm.tz-1,z+::rg_thickness)
        # extract slice from input
        ::rg_input = evolveim[:,:,zmin:zmax]

        # extract slice from mask
        ::rg_init  = ::mask_image[:,:,zmin:zmax]
        # start only from current point
        ::rg_init = 0
        ::rg_init.setpos(x,y,z-zmin)
        ::rg_init.set(255)

        rg = Algorithms.algorithms.ami_IntensityBasedRegionGrowing\
            .IntensityBasedRegionGrowing(&::rg_input,&::rg_init)
        rg.SetMin(0.5)
        rg.SetMax(1.5)
        rg.Evolve()
        #return = initmask
        ::rg_res = (rg.ami_RegionGrowingBase.GetStateImage()==2)*255
        if !exists(::rg_res_draw) {
          ::rg_res <<= autocrop(::rg_res,2)
        }
        show ::rg_res
      }
    }

    #---------------------------------------------------------------------------
    proc ::ApplyGrow3D() {
      if (exists(::rg_res)) {
        rg_mask = ::mask_image[::rg_res]
        ::rg_res = (((::rg_res>0)+(rg_mask>0))>0)*255
        ::mask_image.putimage(::rg_res)
        show ::input
      }
    }

    #---------------------------------------------------------------------------
    proc ::ShowLocalDenoising() \
    {
      if (::show_local_denoising) {
        if (exists(::input_denoising_res)) {
          ::input.putimage(::input_denoising_res)
          show ::input
        }
      } else {
        if (exists(::input_denoising_ROI)) {
          ::input.putimage(::input_denoising_ROI)
          show ::input
        }
      }
    }

    #---------------------------------------------------------------------------
    proc ::ComputeLocalDenoising() \
    {
      if (exists(::input_denoising_ROI)) {
        ::input.putimage(::input_denoising_ROI)
      }
      # Get current XY zoom
      xmin = ::input_draw.GetXmin()
      xmax = ::input_draw.GetXmax()
      ymin = ::input_draw.GetYmin()
      ymax = ::input_draw.GetYmax()
      z = ::input_draw.GetZPos()
      # set small Z interval
      zmargin=::denoise_thickness
      # save original data
      del ::input_denoising_ROI
      ::input_denoising_ROI <<= ::input[xmin:xmax,ymin:ymax,\
                                      (z-zmargin):(z+zmargin)]
      ::input_denoising_ROI.info
      del ::denoise
      # call denoising
      ::AnisoGS_NRADClass ::denoise
      ::denoise.set_input(::input_denoising_ROI)
      ::denoise.SetRoi(::input_denoising_ROI)
      ::denoise.params.noise_model = 1 # Gaussian
      ::denoise.params.noise_estim_neigh = 2 # small to avoid problems
      ::denoise.params.use_new_convolution_filter = true
      ::denoise.params.eigendecomp_mode = 1 # new faster code
      ::denoise.params.display_evolution = false # avoid own display
      ::denoise.Filter()
      del ::input_denoising_res
      ::input_denoising_res <<= ::denoise->res
      # replace original by denoised
      ::input.putimage(::input_denoising_res)
      del ::denoise
      show ::input
    }

    #---------------------------------------------------------------------------
    # Redefinition of Close to close the toolbar
    #
    proc ::Close() \
    {
      # restore denoised ROI
      ::show_local_denoising = false
      ::ShowLocalDenoising()
      ::win.HidePanel()
      ::mgr.DetachPane(&::tb)
      ::tb.Destroy()
      del ::tb
      ::mgr.Update()

      delvars GetObjectName(::Close)
    }
    Comments( ::Close,  "Will close the interface and delete the "+\
                        "corresponding "+\
                        "object named '"+GetObjectName(::Close)+"'.")

    #---------------------------------------------------------------------------
    proc ::Gui() {
    
      ::AddToolbar()

      if (exists(::parent_panel)) {
        ::win = ParamPanel("ImageDraw",&::parent_panel)
      } else {
        ::win = ParamPanel("ImageDraw")
      }
      
      #::win.AddLabel("Info:","Press the 'Alt' Key to draw")
      ::win.BeginBook()
    
        ::win.AddPage("Param")

          ::win.AddImageChoice( &::input_name, "input")
          ::win.SetCallback(::MaskFilterCurrent)

          ::win.BeginBoxPanel("Mask Image (optional)")
            ::win.AddImageChoice( &::mask_name, "mask input")
            ::win.SetCallback(::CB_mask_image)
          ::win.EndBoxPanel()

          ::win.BeginHorizontal()
            ::win.AddButton("Display",    &::Display)

            ::win.AddColor( "Mask color", &::mask_color)
            ::win.SetCallback(&::OnColor)
          ::win.EndHorizontal()
            

          ::win.AddInt(&::mask_opacity,"Opacity",0,255)
          ::win.SetCallback(&::OnOpacity)

          ::win.BeginHorizontal()
            ::win.AddBoolean(&::enable_mask, "Mask")
            ::win.SetCallback(&::OnEnableMask)

            ::win.AddBoolean(&::enable_draw, "Draw")
            ::win.SetCallback(&::Display)
            
            ::win.AddBoolean(&::allow_undo, "Undo")
          ::win.EndHorizontal()
          
          ::win.BeginBoxPanel("Drawing intensity range")
            ::win.AddBoolean(::enable_draw_range,"Enable")
            ::rangemin_id = ::win.AddInt(::draw_range_min,"min",-1000,3000)
            ::rangemax_id = ::win.AddInt(::draw_range_max,"max",-1000,3000)
          ::win.EndBoxPanel()

 
          ::options_id  = ::win.AddEnum( &::paint_option,"Paint")
          for n=0 to ::options.size()-1 { 
            ::win.AddEnumChoice(::options_id,::options[n])
          }
          ::win.SetCallback(&::Display)

          ::pencil_thickness_id = ::win.AddInt( &::pencil_thickness,\
                                                "Thickness",1,20)

        ::win.AddPage("Tools")
          ::win.BeginBoxPanel("RegionGrowing")
            ::rgminint_id = ::win.AddFloat( ::rg_min_intensity,\
                                            "min intensity",0,100)
            ::rgmaxint_id = ::win.AddFloat( ::rg_max_intensity,\
                                            "max intensity",0,100)

            ::rgthick_id = ::win.AddInt( ::rg_thickness,\
                                            "slice thickness",0,250)
            ::win.AddButton("Auto-range", ::AutoRangeRegGrow)
            ::win.BeginHorizontal()
              ::win.AddButton("Try",    ::TryRegGrow)
              ::win.AddButton("Apply",  ::ApplyRegGrow)
              ::win.AddButton("Undo",   ::UndoRegGrow)
            ::win.EndHorizontal()
          ::win.EndBoxPanel()

          ::win.BeginBoxPanel("Noise STD estimation")
            ::cc_id = ::win.AddInt( ::blood_contrast_change, \
                                    "Blood contrast changes", 0, 100)
            ::stdws_id = ::win.AddInt( ::STD_winsize,\
                                            "window radius",0,50)
            ::stdws_id = ::win.AddInt( ::localstats_winsize,\
                                            "localstats winsize",0,5)
            ::win.BeginHorizontal()
              ::win.AddButton("Noise STD",         ::EstimateNoiseSTD)
              ::win.AddButton("Noise STD all",     ::EstimateNoiseSTDAll)
            ::win.EndHorizontal()
            ::win.BeginHorizontal()
              ::win.AddButton("Comp. stats",       ::PrecomputeStats)
              ::win.AddButton("Grow3D",            ::Grow3D)
              ::win.AddButton("Apply",             ::ApplyGrow3D)
            ::win.EndHorizontal()
          ::win.EndBoxPanel()
          
          ::win.BeginBoxPanel("Denoising")
            ::win.BeginHorizontal()
              ::win.AddBoolean(&::show_local_denoising, "Local denoising")
              ::win.SetCallback(::ShowLocalDenoising)
              ::win.AddButton("Compute",::ComputeLocalDenoising)
            ::win.EndHorizontal()
            ::win.AddInt(::denoise_thickness,"Thickness",1,10)
          ::win.EndBoxPanel()
 
          ::AddIOPage(::win)

        #::rg.SetParentPanel(&::win)
        #::rg.Gui()
        #::win.AddPage("RegGrow",&::rg.win)

        if wx.wxFileName(::html_filename).FileExists() {
          ::AddHelpPage(&::win)
        }
    
      ::win.EndBook()
    
      ::AddStandardButtons(&::win)

      if (exists(::parent_panel)) {
        ::win.ShowPanel()
      } else {
        ::win.Display()
      }
      ::win.Update(-1)


    }
    ::Init()
    
  }
  # End of class
  
} 
# End of If
