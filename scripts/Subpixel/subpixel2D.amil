#Interface for sub-pixel 2D detection

func "Common/ScriptGui"

if (!exists(Subpixel2DClass)){

	#Import filters
  ami_import->Filters()

	Class Subpixel2DClass : public ScriptGui{
  
    ::filters = &global::filters
    
    #-----------------------
    proc ::Init(){
      ::class_name = "global::Subpixel2DClass"
      ::input_name = "", "Input image"
      ::output_name = "subpixel2D_edge", "Output image name"
      ::threshold = 25, "Gradient threshold"
      ::lineal = UCHAR(0), "First or second order"
      ::reload = UCHAR(0), "Reload automatically"
      ::CreateGui()
    }
    

    #-----------------------
    
    proc ::load_input() {
      eval "::input <<="+::input_name+";"
      if (::input_name=="BrowseImage") {
        ::input_name = "::input"
        ::win.Update(-1)
      }
    }
    Comments(::load_input, "Load the input image")
    
    #-----------------------
    
    proc ::drawBorder() {
      ::norm_input_draw.SetPenColor(wx.wxColour(255,0,0))
      delta = 0.4
      xmin = ::norm_input_draw.GetXmin()
      xmax = ::norm_input_draw.GetXmax()
      ymin = ::norm_input_draw.GetYmin()
      ymax = ::norm_input_draw.GetYmax()
      for i=0 to ::res->xpos.tx-1 {
        x = ::res->xpos(i,0)
        y = ::res->ypos(i,0)
        #Only paint on visualization region
        if(x>=xmin && x<=xmax) {
          if(y>=ymin && y<=ymax) {
            a = ::res->acoef(i,0)
            b = ::res->bcoef(i,0)
            c = ::res->ccoef(i,0)
            #YMAX
            #Equation --> y = a + b*x + c*x^2
            #Partiendo del código de Agustín:
            #dx = 0.0
            #dy = 0.0
            #if (::res->border(i,0) == 2) {
            #  dx = 0
            #  dy = ::res->des(i,0)
            #} else {
            #  dx = ::res->des(i,0)
            #  dy = 0
            #}
            
            #cx = 1.0
            #cy = 1.0
            
            #if (abs(::res->gy(i,0)) > abs(::res->gx(i,0))) {
            #  cy = (-1 * ::res->gx(i,0)) / ::res->gy(i,0)
            #} else {
            #  cx = (-1 * ::res->gy(i,0)) / ::res->gx(i,0)
            #}
            
            #px = dx - delta * cx
            #py = dy - delta * cy
            #qx = dx + delta * cx
            #qy = dy + delta * cy
            
            #x1 = x + px
            #y1 = y + py
            #x2 = x + qx
            #y2 = y + qy
            
            #::norm_input_draw.DrawLineZ(x1,y1,x2,y2)
            
            if(::res->border(i,0) == 2) {
              ::norm_input_draw.SetPenColor(wx.wxColour(255,0,0))
              x1 = -0.4
              y1 = a + b*x1 + c*x1*x1
              y1 = -y1
              x2 = 0.4
              y2 = a + b*x2 + c*x1*x2
              y2 = -y2
              ::norm_input_draw.DrawLineZ(x+x1,y+y1,x+x2,y+y2)
            } else {
              ::norm_input_draw.SetPenColor(wx.wxColour(0,255,0))
              dx1 = -0.4
              dy1 = a + b*dx1 + c*dx1*dx1
              di1 = -dy1
              dj1 = dx1
              dx2 = 0.4
              dy2 = a + b*dx2 + c*dx2*dx2
              di2 = -dy2
              dj2 = dx2
              #::norm_input_draw.DrawLineZ(x+x1,y-y1,x+x2,y-y2)
              ::norm_input_draw.DrawLineZ(x+di1,y+dj1,x+di2,y+dj2)
            }
            
            #if(::res->border(i,0) == 2) {
              #printn "tipo de borde 2"
              #printn b
              #::norm_input_draw.SetPenColor(wx.wxColour(255,0,0))
              #dx1 = -delta
              #dy1 = a+b*dx1
              #dx2 = delta
              #dy2 = a+b*dx2
              #::norm_input_draw.DrawLineZ(x,y-a,x+dx2,y-dy2)
              #::norm_input_draw.DrawLineZ(x-dx1, y+dy1, x+dx2, y-dy2)
              #if(b<0){
              #  ::norm_input_draw.DrawLineZ(x+delta, y-(a+b*delta), x-delta, y-(a-b*delta))
              #} else {
              #  ::norm_input_draw.DrawLineZ(x-delta, y-(a-b*delta), x+delta, y-(a+b*delta))
              #}
              #x1 = x-delta
              #x2 = x+delta
              #y1 = a + b*x1 + c*x1*x1
              #y2 = a + b*x2 + c*x2*x2
              #::norm_input_draw.DrawLineZ(x1,y1,x2,y2)
            #} else {
              #XMAX
              #Equation --> x = a + b*y + c*y^2
              #printn "tipo de borde 1"
              #printn b
              #::norm_input_draw.SetPenColor(wx.wxColour(0,255,0))
              #::norm_input_draw.DrawLineZ(x-delta,y-(a-b*delta),x+delta,y-(a+b*delta))
              #dy1 = delta
              #dx1 = a+b*dy1
              #dy2 = -delta
              #dx2 = a+b*dy2
              #::norm_input_draw.DrawLineZ(x+a, y, x+dx2, y-dy2)
              #::norm_input_draw.DrawLineZ(x-dx1, y+dy1, x+dx2, y+dy2)
              #if(b<0 || b==1){
              #  ::norm_input_draw.DrawLineZ(x-(a-b*delta), y-delta, x-(a+b*delta), y+delta)
              #} else {
              #  ::norm_input_draw.DrawLineZ(x-(a-b*delta), y+delta, x-(a+b*delta), y-delta)
              #}
              #::norm_input_draw.DrawLineZ(delta-(a-b*x), y-delta, delta-(a+b*x), y+delta)
              #::norm_input_draw.DrawLineZ((y-delta)-a-b*x, y-delta, (y+delta)-a-b*x, y+delta)
              #y1 = y-delta
              #y2 = y+delta
              #x1 = a + b*y1 + c*y1*y1
              #x2 = a + b*y2 + c*y2*y2
              #::norm_input_draw.DrawLineZ(x1,y1,x2,y2)
            #}
          }
        }
      }
      ::norm_input_draw.DrawingAreaDisplay()
    }
    Comments(::drawBorder, "Draw the sub-pixel border")
    
    #-----------------------
    
    proc ::Run() {
    	::load_input()
    	::norm_input <<= norm(::input)
      if (exists(::res)) { del ::res; }
			::res = ::filters->Subpixel2D(&::norm_input, ::threshold, ::lineal)
      
      ::Display
      ::drawBorder
      
      ::norm_input_draw.PaintCallback(&::drawBorder)
    }
    Comments(::Run, "Detects edges with Subpixel2D method")
    
    #-----------------------
    
    proc ::Display() {
      global
      if (exists(::norm_input)) {
        show ::norm_input
      }
    }
    Comments(::Display, "Show the result image")
    
    #-----------------------
    
    proc ::AutoRun() {
      if(::reload) {
        ::Run
      }
    }
    Comments(::AutoRun, "Updates image automatically when parameters change.")
    
    #-----------------------
    
    proc ::Save() {
      eval "global::" + ::output_name + "<<=::res;"
    }
    Comments(::Save, "Save output image as global variable")
    
    #-----------------------
    
    proc ::CreateGui() {
      import = &global::ami_import;
      ::win = import->ParamPanel("Subpixel 2D")
      
      ::win.BeginBook()
        ::win.AddPage("Parameters")
          ::win.BeginBoxPanel("Sub-pixel2D parameters")
            ::win.BeginHorizontal()
              ::win.AddImageChoice(&::input_name, "Input")
              ::AddBitmapButton(&::win, &::icons._New_image, 16, "load_input")
            ::win.EndHorizontal()
            ::win.AddString(&::output_name, "Output")
            #Edge detection parameters
            ::win.AddFloat(&::threshold, "Thres.", 0, 25)
            ::win.SetCallback(&::AutoRun)
            ::win.AddBoolean(&::lineal, "Lineal Case")
            ::win.SetCallback(&::AutoRun)
          ::win.EndBoxPanel()
          ::win.BeginHorizontal
          	::win.AddBoolean(&::reload, "Reload")
            #::win.AddButton("Detect edge",     ::Run)
            ::icons.LoadIconPNG("Play")
            ::AddBitmapButton(&::win, &::icons._Play, 16, "Run")
          ::win.EndHorizontal
      ::win.EndBook()

      ::AddStandardButtons(&::win)
      ::win.Update(-1)
      ::win.Display
    }
    
    ::Init

  } #end Class

} #end If


#----------------
# Main
#----------------
if (!exists(subp2D)) {
  Subpixel2DClass subp2D
} else {
  InfoDialog "The script for subpixel edge detection in 2D images seems to be already loaded."
}
