#Interface for sub-pixel 2D detection

func "Common/ScriptGui"

if (!exists(Subpixel2DClass)){

	#Import filters
  ami_import->Filters()

	Class Subpixel2DClass : public ScriptGui{
  
    ::filters = &global::filters
    
    #-----------------------
    proc ::Init(){
      ::class_name = "global::Subpixel2DClass"
      ::input_name = "", "Input image"
      ::output_name = "subpixel2D_edge", "Output image name"
      ::threshold = 25, "Gradient threshold"
      ::lineal = UCHAR(0), "First or second order"
      ::reload = UCHAR(0), "Reload automatically"
      ::CreateGui()
    }
    

    #-----------------------
    
    proc ::load_input() {
      eval "::input <<="+::input_name+";"
      if (::input_name=="BrowseImage") {
        ::input_name = "::input"
        ::win.Update(-1)
      }
    }
    Comments(::load_input, "Load the input image")
    
    #-----------------------
    
    proc ::drawBorder() {
      ::norm_input_draw.SetPenColor(wx.wxColour(255,0,0))
      delta = 0.4
      xmin = ::norm_input_draw.GetXmin()
      xmax = ::norm_input_draw.GetXmax()
      ymin = ::norm_input_draw.GetYmin()
      ymax = ::norm_input_draw.GetYmax()
      for i=0 to ::res->xpos.tx-1 {
        x = ::res->xpos(i,0)
        y = ::res->ypos(i,0)
        #Only paint on visualization region
        if(x>=xmin && x<=xmax) {
          if(y>=ymin && y<=ymax) {
            a = ::res->acoef(i,0)
            b = ::res->bcoef(i,0)
            c = ::res->ccoef(i,0)
            #print "a = "
            #print a
            #print " b = "
            #print b
            #print " c = "
            #print c
            #hay que usar a como desplazamiento dentro del pixel
            #YMAX
            if(::res->border(i,0) == 2) {
              #printn "tipo de borde 2"
              #printn b
              ::norm_input_draw.SetPenColor(wx.wxColour(255,0,0))
              dx1 = -delta
              dy1 = a+b*dx1
              dx2 = delta
              dy2 = a+b*dx2
              #::norm_input_draw.DrawLineZ(x,y-a,x+dx2,y-dy2)
              #::norm_input_draw.DrawLineZ(x-dx1, y+dy1, x+dx2, y-dy2)
              if(b<0){
                ::norm_input_draw.DrawLineZ(x+delta, y-(a+b*delta), x-delta, y-(a+b*delta))
              } else {
                ::norm_input_draw.DrawLineZ(x-delta, y-(a-b*delta), x+delta, y-(a+b*delta))
              }
            } else {
              #XMAX
              #printn "tipo de borde 1"
              #printn b
              ::norm_input_draw.SetPenColor(wx.wxColour(0,255,0))
              #::norm_input_draw.DrawLineZ(x-delta,y-(a-b*delta),x+delta,y-(a+b*delta))
              dy1 = delta
              dx1 = a+b*dy1
              dy2 = -delta
              dx2 = a+b*dy2
              #::norm_input_draw.DrawLineZ(x+a, y, x+dx2, y-dy2)
              #::norm_input_draw.DrawLineZ(x-dx1, y+dy1, x+dx2, y+dy2)
              if(b<0 || b==1){
                ::norm_input_draw.DrawLineZ(x-(a-b*delta), y-delta, x-(a+b*delta), y+delta)
              } else {
                ::norm_input_draw.DrawLineZ(x-(a-b*delta), y+delta, x-(a+b*delta), y-delta)
              }
              #::norm_input_draw.DrawLineZ(delta-(a-b*x), y-delta, delta-(a+b*x), y+delta)
              #::norm_input_draw.DrawLineZ((y-delta)-a-b*x, y-delta, (y+delta)-a-b*x, y+delta)
            }
          }
        }
      }
      ::norm_input_draw.DrawingAreaDisplay()
    }
    Comments(::drawBorder, "Draw the sub-pixel border")
    
    #-----------------------
    
    proc ::Run() {
    	::load_input()
    	::norm_input <<= norm(::input)
      if (exists(::res)) { del ::res; }
			::res = ::filters->Subpixel2D(&::norm_input, ::threshold, ::lineal)
      
      ::Display
      ::drawBorder
      
      ::norm_input_draw.PaintCallback(&::drawBorder)
    }
    Comments(::Run, "Detects edges with Subpixel2D method")
    
    #-----------------------
    
    proc ::Display() {
      global
      if (exists(::norm_input)) {
        show ::norm_input
      }
    }
    Comments(::Display, "Show the result image")
    
    #-----------------------
    
    proc ::AutoRun() {
      if(::reload) {
        ::Run
      }
    }
    Comments(::AutoRun, "Updates image automatically when parameters change.")
    
    #-----------------------
    
    proc ::Save() {
      eval "global::" + ::output_name + "<<=::res;"
    }
    Comments(::Save, "Save output image as global variable")
    
    #-----------------------
    
    proc ::CreateGui() {
      import = &global::ami_import;
      ::win = import->ParamPanel("Subpixel 2D")
      
      ::win.BeginBook()
        ::win.AddPage("Parameters")
          ::win.BeginBoxPanel("Sub-pixel2D parameters")
            ::win.BeginHorizontal()
              ::win.AddImageChoice(&::input_name, "Input")
              ::AddBitmapButton(&::win, &::icons._New_image, 16, "load_input")
            ::win.EndHorizontal()
            ::win.AddString(&::output_name, "Output")
            #Edge detection parameters
            ::win.AddFloat(&::threshold, "Thres.", 0, 25)
            ::win.SetCallback(&::AutoRun)
            ::win.AddBoolean(&::lineal, "Lineal Case")
            ::win.SetCallback(&::AutoRun)
          ::win.EndBoxPanel()
          ::win.BeginHorizontal
          	::win.AddBoolean(&::reload, "Reload")
            #::win.AddButton("Detect edge",     ::Run)
            ::icons.LoadIconPNG("Play")
            ::AddBitmapButton(&::win, &::icons._Play, 16, "Run")
          ::win.EndHorizontal
      ::win.EndBook()

      ::AddStandardButtons(&::win)
      ::win.Update(-1)
      ::win.Display
    }
    
    ::Init

  } #end Class

} #end If


#----------------
# Main
#----------------
if (!exists(subp2D)) {
  Subpixel2DClass subp2D
} else {
  InfoDialog "The script for subpixel edge detection in 2D images seems to be already loaded."
}
