#Interface for sub-pixel 2D detection

func "Common/ScriptGui"

if (!exists(Subpixel2DClass)){

	#Import filters
  ami_import->Filters()

	Class Subpixel2DClass : public ScriptGui{
  
    ::filters = &global::filters
    
    #-----------------------
    proc ::Init(){
      ::class_name = "global::Subpixel2DClass"
      ::input_name = "", "Input image"
      ::output_name = "subpixel2D_edge", "Output image name"
      ::threshold = 25, "Gradient threshold"
      ::lineal = UCHAR(0), "First or second order"
      ::reload = UCHAR(0), "Reload automatically"
      ::alg_type = INT(0), "Sub-pixel 2D algorithm type"
      ::CreateGui()
    }
    

    #-----------------------
    
    proc ::load_input() {
      eval "::input <<="+::input_name+";"
      if (::input_name=="BrowseImage") {
        ::input_name = "::input"
        ::win.Update(-1)
      }
    }
    Comments(::load_input, "Load the input image")
    
    #-----------------------
    
    proc ::drawBorder() {
      #::norm_input_draw.SetPenColor(wx.wxColour(255,0,0))
      delta = 0.4
      xmin = ::norm_input_draw.GetXmin()
      xmax = ::norm_input_draw.GetXmax()
      ymin = ::norm_input_draw.GetYmin()
      ymax = ::norm_input_draw.GetYmax()
      #Create four new images for displacements inside pixel
      dx1 = Image(DOUBLE,::res->xpos.tx,1,1)
      dy1 = Image(DOUBLE,::res->xpos.tx,1,1)
      dx2 = Image(DOUBLE,::res->xpos.tx,1,1)
      dy2 = Image(DOUBLE,::res->xpos.tx,1,1)
      dx1 = -0.4
      dy1 = ::res->acoef + ::res->bcoef*dx1 + ::res->ccoef*dx1*dx1
      dy1 = -dy1
      dx2 = 0.4
      dy2 = ::res->acoef + ::res->bcoef*dx2 + ::res->ccoef*dx2*dx2
      dy2 = -dy2
      #Create images for draw points
      x1pos = (::res->xpos+dx1)*(::res->border==2)+(::res->xpos+dy1)*(::res->border!=2)
      y1pos = (::res->ypos+dy1)*(::res->border==2)+(::res->ypos+dx1)*(::res->border!=2)
      x2pos = (::res->xpos+dx2)*(::res->border==2)+(::res->xpos+dy2)*(::res->border!=2)
      y2pos = (::res->ypos+dy2)*(::res->border==2)+(::res->ypos+dx2)*(::res->border!=2)
      #inside delimits the draw area
      inside = (::res->xpos>=xmin)*(::res->xpos<=xmax)*(::res->ypos>=ymin)*(::res->ypos<=ymax)
      #crop zero zones
      inside_crop = autocrop(inside,0)
      x1pos_crop = x1pos[inside_crop.GetExtent]
      y1pos_crop = y1pos[inside_crop.GetExtent]
      x2pos_crop = x2pos[inside_crop.GetExtent]
      y2pos_crop = y2pos[inside_crop.GetExtent]
      
      #InitTime
      for i=0 to inside_crop.tx-1 {
        #x = ::res->xpos(i,0)
        #y = ::res->ypos(i,0)
        #Only paint on visualization region
        if inside_crop(i,0) {
          #if(y>=ymin && y<=ymax) {
            #a = ::res->acoef(i,0)
            #b = ::res->bcoef(i,0)
            #c = ::res->ccoef(i,0)
            #YMAX
            #Equation --> y = a + b*x + c*x^2
            #if(::res->border(i,0) == 2) {
              #::norm_input_draw.SetPenColor(wx.wxColour(255,0,0))
              #x1 = -0.4
              #y1 = a + b*x1 + c*x1*x1
              #y1 = -y1
              #x2 = 0.4
              #y2 = a + b*x2 + c*x1*x2
              #y2 = -y2
              #::norm_input_draw.DrawLineZ(x+x1,y+y1,x+x2,y+y2)
              #::norm_input_draw.DrawLineZ(x+dx1(i,0),y+dy1(i,0),x+dx2(i,0),y+dy2(i,0))
            #} else {
              #XMAX
              #Equation --> x = a + b*y + c*y^2
              #::norm_input_draw.SetPenColor(wx.wxColour(0,255,0))
              #dx1 = -0.4
              #dy1 = a + b*dx1 + c*dx1*dx1
              #di1 = -dy1
              #dj1 = dx1
              #dx2 = 0.4
              #dy2 = a + b*dx2 + c*dx2*dx2
              #di2 = -dy2
              #dj2 = dx2
              #::norm_input_draw.DrawLineZ(x+di1,y+dj1,x+di2,y+dj2)
              #::norm_input_draw.DrawLineZ(x+dy1(i,0),y+dx1(i,0),x+dy2(i,0),y+dx2(i,0))
            #}
            if(::res->border(i,0) == 2) {
              ::norm_input_draw.SetPenColor(&wx.wxColour(255,0,0))
            } else {
              ::norm_input_draw.SetPenColor(&wx.wxColour(0,255,0))
            }
            ::norm_input_draw.DrawLineZ(x1pos_crop(i,0),y1pos_crop(i,0),x2pos_crop(i,0),y2pos_crop(i,0))
          #}
        }
      }
      ::norm_input_draw.DrawingAreaDisplay()
      
      #EndTime
      
    }
    Comments(::drawBorder, "Draw the sub-pixel border")
    
    #-----------------------
    
    proc ::Run() {
    	::load_input()
    	::norm_input <<= norm(::input)
      if (exists(::res)) { del ::res; }
      if(::alg_type==0) {
        ::res = ::filters->Subpixel2D(&::norm_input, ::threshold, ::lineal)
      } else {
        ::res = ::filters->GaussianSubpixel2D(&::norm_input, ::threshold, ::lineal)
      }
			
      
      ::Display
      ::drawBorder
      
      ::norm_input_draw.PaintCallback(&::drawBorder)
    }
    Comments(::Run, "Detects edges with Subpixel2D method")
    
    #-----------------------
    
    proc ::Display() {
      global
      if (exists(::norm_input) && ::alg_type == 0) {
        show ::norm_input
      } else {
        if(exists(::res)) {
          ::norm_input <<= ::res->denoised
          show ::norm_input
        }
      }
    }
    Comments(::Display, "Show the result image")
    
    #-----------------------
    
    proc ::AutoRun() {
      if(::reload) {
        ::Run
      }
    }
    Comments(::AutoRun, "Updates image automatically when parameters change.")
    
    #-----------------------
    
    proc ::Save() {
      eval "global::" + ::output_name + "<<=::res;"
    }
    Comments(::Save, "Save output image as global variable")
    
    #-----------------------
    
    proc ::CreateGui() {
      import = &global::ami_import;
      ::win = import->ParamPanel("Subpixel 2D")
      
      ::win.BeginBook()
        ::win.AddPage("Parameters")
          ::win.BeginBoxPanel("Sub-pixel2D parameters")
            ::win.BeginHorizontal()
              ::win.AddImageChoice(&::input_name, "Input")
              ::AddBitmapButton(&::win, &::icons._New_image, 16, "load_input")
            ::win.EndHorizontal()
            ::win.AddString(&::output_name, "Output")
            #Edge detection parameters
            ::win.AddFloat(&::threshold, "Thres.", 0, 25)
            ::win.SetCallback(&::AutoRun)
            ::win.AddBoolean(&::lineal, "Lineal Case")
            ::win.SetCallback(&::AutoRun)
          ::win.EndBoxPanel()
          ::win.BeginHorizontal
          	#::win.AddBoolean(&::reload, "Reload")
            #::win.AddButton("Detect edge",     ::Run)
            ::filter_type = ::win.AddEnum(&::alg_type, "Method")
              ::win.AddEnumChoice(::filter_type, "SubPixel")
              ::win.AddEnumChoice(::filter_type, "Gaussian SubPixel")
            ::icons.LoadIconPNG("Play")
            ::AddBitmapButton(&::win, &::icons._Play, 16, "Run")
          ::win.EndHorizontal
      ::win.EndBook()

      ::AddStandardButtons(&::win)
      ::win.Update(-1)
      ::win.Display
    }
    
    ::Init

  } #end Class

} #end If


#----------------
# Main
#----------------
if (!exists(subp2D)) {
  Subpixel2DClass subp2D
} else {
  InfoDialog "The script for subpixel edge detection in 2D images seems to be already loaded."
}
