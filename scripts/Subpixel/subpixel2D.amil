#Interface for sub-pixel 2D detection

func "Common/ScriptGui"

if (!exists(Subpixel2DClass)){

	#Import filters
  ami_import->Filters()

	Class Subpixel2DClass : public ScriptGui{
  
    ::filters = &global::filters
    
    #-----------------------
    proc ::Init(){
      ::class_name  = "global::Subpixel2DClass"
      ::input_name  = "",                "Input image"
      ::output_name = "subpixel2D_edge", "Output image name"
      ::threshold   = 25,                "Gradient threshold"
      ::linear      = UCHAR(0),          "First or second order"
      ::reload      = UCHAR(0),          "Reload automatically"
      ::normals     = UCHAR(0),          "Draw edge normals"
      ::change      = UCHAR(0),          "Change contour's default values"
      ::alg_type    = INT(0),            "Sub-pixel 2D algorithm type"
      #Edge parameters
      ::Ered        = INT(255),          "Red contour value"
      ::Egreen      = INT(0),            "Green contour value"
      ::Eblue       = INT(0),            "Blue contour value"
      ::Ealpha      = INT(255),          "Alpha contour component"
      ::Ethickness  = INT(1),            "Contour thickness"
      ::Estyle      = INT(0),            "Contour line style"
      #Normal parameters
      ::Nred        = INT(0),          "Red normal value"
      ::Ngreen      = INT(0),          "Green normal value"
      ::Nblue       = INT(255),            "Blue normal value"
      ::Nalpha      = INT(255),          "Alpha normal component"
      ::Nthickness  = INT(1),            "Normal thickness"
      ::Nstyle      = INT(0),            "Normal line style"
      ::CreateGui()
    }
    

    #-----------------------
    
    proc ::load_input() {
      eval "::input <<="+::input_name+";"
      if (::input_name=="BrowseImage") {
        ::input_name = "::input"
        ::win.Update(-1)
      }
    }
    Comments(::load_input, "Load the input image")
    
    #-----------------------
    
    proc ::drawBorder() {
      #Catch visualization region limits
      xmin = ::norm_input_draw.GetXmin()
      xmax = ::norm_input_draw.GetXmax()
      ymin = ::norm_input_draw.GetYmin()
      ymax = ::norm_input_draw.GetYmax()
      #Create four new images for displacements inside pixel
      dx1 = Image(DOUBLE,::res->xpos.tx,1,1)
      dy1 = Image(DOUBLE,::res->xpos.tx,1,1)
      dx2 = Image(DOUBLE,::res->xpos.tx,1,1)
      dy2 = Image(DOUBLE,::res->xpos.tx,1,1)
      dx1 = -0.4
      #y = a + b*x + c*x*x
      dy1 = ::res->acoef + ::res->bcoef*dx1 + ::res->ccoef*dx1*dx1
      dy1 = -dy1
      dx2 = 0.4
      dy2 = ::res->acoef + ::res->bcoef*dx2 + ::res->ccoef*dx2*dx2
      dy2 = -dy2
      #Create images for draw points (draw line from x1,y1 to x2,y2)
      x1pos = (::res->xpos+dx1)*(::res->border==2)+(::res->xpos+dy1)*(::res->border!=2)
      y1pos = (::res->ypos+dy1)*(::res->border==2)+(::res->ypos+dx1)*(::res->border!=2)
      x2pos = (::res->xpos+dx2)*(::res->border==2)+(::res->xpos+dy2)*(::res->border!=2)
      y2pos = (::res->ypos+dy2)*(::res->border==2)+(::res->ypos+dx2)*(::res->border!=2)
      #inside delimits the draw area inside the region defined by xmin,xmax,ymin and ymax
      inside = (::res->xpos>=xmin)*(::res->xpos<=xmax)*(::res->ypos>=ymin)*(::res->ypos<=ymax)
      #crop zero zones using autocrop
      inside_crop = autocrop(inside,0)
      x1pos_crop = x1pos[inside_crop.GetExtent]
      y1pos_crop = y1pos[inside_crop.GetExtent]
      x2pos_crop = x2pos[inside_crop.GetExtent]
      y2pos_crop = y2pos[inside_crop.GetExtent]
      
      #If draw normals is active, calculate normals
      if (::normals==1) {
        #Edge central point
        px = (x1pos+x2pos) / 2
        py = (y1pos+y2pos) / 2
        #Calculate normal point
        div = (::res->aintensity - ::res->bintensity) / sqrt(1+::res->bcoef*::res->bcoef)
        sign = (div>=0)*1 + (div<0)*-1
        nx = ::res->bcoef * sign
        ny = Image(DOUBLE,nx.tx,1,1)
        ny = sign * 1
        
        normx = (px+nx)*(::res->border==2)+(px+ny)*(::res->border!=2)
        normy = (py+ny)*(::res->border==2)+(py+nx)*(::res->border!=2)
        
        px_crop = px[inside_crop.GetExtent]
        py_crop = py[inside_crop.GetExtent]
        normx_crop = normx[inside_crop.GetExtent]
        normy_crop = normy[inside_crop.GetExtent]
      }
      
      #InitTime
      for i=0 to inside_crop.tx-1 {
        #Only paint on visualization region
        if inside_crop(i,0) {
            if(::change==0){
              if(::res->border(i,0) == 2) {
                ::norm_input_draw.SetPenColor(&wx.wxColour(255,0,0))
              } else {
                ::norm_input_draw.SetPenColor(&wx.wxColour(0,255,0))
              }
            } else {
              ::norm_input_draw.SetPenColor(&wx.wxColour(::Ered,::Egreen,::Eblue,::Ealpha))
              ::norm_input_draw.SetLineParameters(::Ethickness,::Estyle)
            }
            #Draw edge
            ::norm_input_draw.DrawLineZ(x1pos_crop(i,0),y1pos_crop(i,0),x2pos_crop(i,0),y2pos_crop(i,0))
            #Draw normals
            if(::normals==1) {
              if(::change == 1) {
                ::norm_input_draw.SetPenColor(&wx.wxColour(::Nred,::Ngreen,::Nblue,::Nalpha))
                ::norm_input_draw.SetLineParameters(::Nthickness,::Nstyle)
              }
              ::norm_input_draw.DrawLineZ(px_crop(i,0), py_crop(i,0), normx_crop(i,0), normy_crop(i,0))
            }
        } #end if inside_crop
      } #end for
      ::norm_input_draw.DrawingAreaDisplay()
      
      #EndTime
      
    }
    Comments(::drawBorder, "Draw the sub-pixel border")
    
    #-----------------------
    
    proc ::Run() {
    	::load_input()
    	::norm_input <<= norm(::input)
      if (exists(::res)) { del ::res; }
      if(::alg_type==0) {
        ::res = ::filters->Subpixel2D(&::norm_input, ::threshold, ::linear)
      } else {
        ::res = ::filters->GaussianSubpixel2D(&::norm_input, ::threshold, ::linear)
      }
			
      
      ::Display
      ::drawBorder
      
      ::norm_input_draw.PaintCallback(&::drawBorder)
    }
    Comments(::Run, "Detects edges with Subpixel2D method")
    
    #-----------------------
    
    proc ::Display() {
      global
      if (exists(::norm_input) && ::alg_type == 0) {
        show ::norm_input
      } else {
        if(exists(::res)) {
          ::norm_input <<= ::res->denoised
          show ::norm_input
        }
      }
    }
    Comments(::Display, "Show the result image")
    
    #-----------------------
    
    proc ::AutoRun() {
      if(::reload) {
        ::Run
      }
    }
    Comments(::AutoRun, "Updates image automatically when parameters change.")
    
    #-----------------------
    
    proc ::Save() {
      eval "global::" + ::output_name + "<<=::res;"
    }
    Comments(::Save, "Save output image as global variable")
    
    #-----------------------
    
    proc ::Enable() {
      if(::change == 1) {
        ::win.EnablePanel(::color_edge_panel, 1)
        ::win.EnablePanel(::prop_edge_panel, 1)
        ::win.EnablePanel(::color_normal_panel, 1)
        ::win.EnablePanel(::prop_normal_panel, 1)
      } else {
        ::win.EnablePanel(::color_edge_panel, 0)
        ::win.EnablePanel(::prop_edge_panel, 0)
        ::win.EnablePanel(::color_normal_panel, 0)
        ::win.EnablePanel(::prop_normal_panel, 0)
      }
    }
    
    #-----------------------
    
    proc ::CreateGui() {
      import = &global::ami_import;
      ::win = import->ParamPanel("Subpixel 2D")
      
      ::win.BeginBook()
        ::win.AddPage("Parameters")
          ::win.BeginBoxPanel("Sub-pixel2D parameters")
            ::win.BeginHorizontal()
              ::win.AddImageChoice(&::input_name, "Input")
              ::AddBitmapButton(&::win, &::icons._New_image, 16, "load_input")
            ::win.EndHorizontal()
            ::win.AddString(&::output_name, "Output")
            #Edge detection parameters
            ::win.AddFloat(&::threshold, "Thres.", 0, 25)
            ::win.SetCallback(&::AutoRun)
            ::win.AddBoolean(&::linear, "1st order")
            ::win.SetCallback(&::AutoRun)
          ::win.EndBoxPanel()
          ::win.BeginHorizontal()
            #::win.AddBoolean(&::reload, "Reload")
            ::win.AddBoolean(&::normals, "Draw normals")
          ::win.EndHorizontal()
          ::win.BeginHorizontal()
            ::filter_type = ::win.AddEnum(&::alg_type, "Method")
              ::win.AddEnumChoice(::filter_type, "SubPixel")
              ::win.AddEnumChoice(::filter_type, "Gaussian SubPixel")
            ::icons.LoadIconPNG("Play")
            ::AddBitmapButton(&::win, &::icons._Play, 16, "Run")
          ::win.EndHorizontal()
          #New page for change contour and normals parameters
          ::win.AddPage("Contour")
            ::win.AddBoolean(&::change, "Change defaul")
            ::win.SetCallback(&::Enable)
            #New book for edge and normals parameters
            ::win.BeginBook()
              #Edge parameters
              ::win.AddPage("Edge")
                ::color_edge_panel = ::win.BeginBoxPanel("Color")
                  ::win.AddInt(&::Ered, "R", 0, 255)
                  ::win.AddInt(&::Egreen, "G", 0, 255)
                  ::win.AddInt(&::Eblue, "B", 0, 255)
                  ::win.AddInt(&::Ealpha, "A", 0, 255)
                ::win.EndBoxPanel()
                ::win.EnablePanel(::color_edge_panel, 0)
                ::prop_edge_panel = ::win.BeginBoxPanel("Properties")
                  ::win.AddInt(&::Ethickness, "Thick.",1, 5)
                  ::style_type = ::win.AddEnum(&::Estyle, "Style")
                  ::win.AddEnumChoice(::style_type, "______")
                  ::win.AddEnumChoice(::style_type, "..........")
                ::win.EndBoxPanel()
                ::win.EnablePanel(::prop_edge_panel, 0)
              #Normals parameters
              ::win.AddPage("Normals")
                ::color_normal_panel = ::win.BeginBoxPanel("Color")
                    ::win.AddInt(&::Nred, "R", 0, 255)
                    ::win.AddInt(&::Ngreen, "G", 0, 255)
                    ::win.AddInt(&::Nblue, "B", 0, 255)
                    ::win.AddInt(&::Nalpha, "A", 0, 255)
                  ::win.EndBoxPanel()
                  ::win.EnablePanel(::color_normal_panel, 0)
                  ::prop_normal_panel = ::win.BeginBoxPanel("Properties")
                    ::win.AddInt(&::Nthickness, "Thick.",1, 5)
                    ::style_type = ::win.AddEnum(&::Nstyle, "Style")
                    ::win.AddEnumChoice(::style_type, "______")
                    ::win.AddEnumChoice(::style_type, "..........")
                  ::win.EndBoxPanel()
                  ::win.EnablePanel(::prop_normal_panel, 0)
            ::win.EndBook()
           
      ::win.EndBook()

      ::AddStandardButtons(&::win)
      ::win.Update(-1)
      ::win.Display
    }
    
    ::Init

  } #end Class

} #end If


#----------------
# Main
#----------------
if (!exists(subp2D)) {
  Subpixel2DClass subp2D
} else {
  InfoDialog "The script for subpixel edge detection in 2D images seems to be already loaded."
}
