#Interface for sub-pixel 3D detection

func "Common/ScriptGui"

#For use VTK
import_vtk

if (!exists(Subpixel3DClass)){

	#Import filters
  ami_import->Filters()

	Class Subpixel3DClass : public ScriptGui{
  
    ::filters = &global::filters
    
    #-----------------------
    proc ::Init(){
      ::class_name  = "global::Subpixel3DClass"
      ::input_name  = "",                "Input image"
      ::output_name = "subpixel3D_edge", "Output image name"
      ::threshold   = 25,                "Gradient threshold"
      ::alg_type    = INT(0),            "Sub-pixel 3D algorithm type"
      ::alg_enum    = INT(0),            "Enumeration of algorithms"
      ::linear      = UCHAR(0),          "First or second order"
      
      ::CreateGui()
    }
    

    #-----------------------
    
    proc ::load_input() {
      eval "::input <<="+::input_name+";"
      if (::input_name=="BrowseImage") {
        ::input_name = "::input"
        ::win.Update(-1)
      }
    }
    Comments(::load_input, "Load the input image")
    
    #-----------------------
    
    proc ::vtkPruebita() {
      #Create 3 points
      points = vtk.vtkPoints.New()
      points.InsertNextPoint(1.0, 0.0, 0.0)
      points.InsertNextPoint(0.0, 0.0, 0.0)
      points.InsertNextPoint(0.0, 1.0, 0.0)
      
      #Add points to a polydata
      polydata = vtk.vtkPolyData.New()
      polydata.SetPoints(&points)
      
      #Set point normals
      array = vtk.vtkDoubleArray.New()
      #3D normals
      array.SetNumberOfComponents(3)
      array.SetNumberOfTuples(polydata.GetNumberOfPoints())
      
      #Construct the normal vectors
      pN1 = vector_double()
      pN1.push_back(1.0)
      pN1.push_back(0.0)
      pN1.push_back(0.0)
      pN2 = vector_double()
      pN2.push_back(0.0)
      pN2.push_back(1.0)
      pN2.push_back(0.0)
      pN3 = vector_double()
      pN3.push_back(0.0)
      pN3.push_back(0.0)
      pN3.push_back(1.0)
      
      #Add the data to the normals array
      array.SetTuple(0, &pN1[0])
      array.SetTuple(1, &pN2[0])
      array.SetTuple(2, &pN3[0])
      
      #Add the normals to the points in the polydata
      polydata.GetPointData.SetNormals(array)
      
      #We make a little test using the glyph3D
      planeSource = vtk.vtkPlaneSource.New() #We draw planes
      glyph3D = vtk.vtkGlyph3D.New()
      glyph3D.OrientOn()
      glyph3D.SetSource(&planeSource.GetOutput())
      glyph3D.SetVectorModeToUseNormal()
      glyph3D.SetInput(&polydata)
      glyph3D.SetScaleFactor(1)
      glyph3D.Update()
      
      #Draw the result
      #Visualize
      mapper = vtk.vtkPolyDataMapper.New()
      mapper.SetInputConnection(&glyph3D.GetOutputPort())
      #Create the wxVTKFrame
      renwin_interact = global::wxVTKFrame()
      renwin = renwin_interact.GetRenderWindow()
      #Create and add the renderer
      renderer = vtk.vtkRenderer.New()
      renwin.AddRenderer(&renderer)
      interact = vtk.vtkInteractorStyleTrackballCamera.New()
      renwin_interact.SetInteractorStyle(&interact)
      #This is the actor with the planes
      actor = vtk.vtkActor.New()
      actor.SetMapper(&mapper)
      renderer.AddActor(&actor)
      renderer.ResetCameraClippingRange()
      renderer.SetBackground(0.3, 0.6, 0.3)
      renderer.ResetCamera()
      
      #renwin.Render()
      renwin_interact.Start()
    }
    
    proc ::vtkExample() {
      #Computing the edge normals
      div = Image(DOUBLE, ::res->xpos.tx, ::res->xpos.ty, ::res->xpos.tz)
      div = (::res->aintensity - ::res->bintensity)/ \
            (sqrt(1 + ::res->bcoef*::res->bcoef + ::res->ccoef*::res->ccoef))
      #Normal components
      nx = Image(DOUBLE, div.tx, div.ty, div.tz)
      ny = Image(DOUBLE, div.tx, div.ty, div.tz)
      nz = Image(DOUBLE, div.tx, div.ty, div.tz)
      #Fill the components
      nx = div * ::res->bcoef
      ny = div * -1
      nz = div * ::res->ccoef
      
      sphereSource = vtk.vtkSphereSource.New()
      sphereSource.Update()
      
      polydata      = vtk.vtkPolyData.New()
      polydata.ShallowCopy(&sphereSource.GetOutput())
      #polydata.SetPoints(&points)
      
      #Drawing the input image
      ::vol_isosurf = isosurf(::input, (max(::input)+min(::input))/2)
      #Create the polydata and compute the normals
      vol_polydata = global::ToVtkPolyData(::vol_isosurf)
      vol_normals = vtk.vtkPolyDataNormals.New()
      vol_normals.SetInput(&vol_polydata)
      vol_normals.SetFeatureAngle(60.0)
      #Create the mapper and conect it with the normals output
      vol_mapper = vtk.vtkPolyDataMapper.New()
      vol_mapper.SetInputConnection(&vol_normals.GetOutputPort())
      vol_mapper.ScalarVisibilityOff()
      #Create a new actor set the vol_mapper
      vol_actor = vtk.vtkActor.New()
      vol_actor.SetMapper(&vol_mapper)
      
      #Array for the normals
      array = vtk.vtkDoubleArray.New()
      #array.SetNumberOfComponents(3) #3D normals
      #array.SetNumberOfTuples(nx.tx) #En este caso sería pillar el número de pixels borde
      #Cómo demonios inserto los puntos?? Hay que pasarle un vector de double (puntero)
      #Habría que insertar uno de cada nx, ny y nz
      
      #Esto no va muy bien, no sé si es que no hereda GetPointData de vtkDataSet
      #vol_polydata.GetPointData.SetNormals(&array)
      
      #arrowSource = vtk.vtkArrowSource.New() #esto quizás me sirva para las normales
      
      planeSource = vtk.vtkPlaneSource.New()
      
      glyph3D = vtk.vtkGlyph3D.New()
      glyph3D.OrientOn()
      #glyph3D.SetSource(&arrowSource.GetOutput()) #para pintar las normales
      glyph3D.SetSource(&planeSource.GetOutput())
      #glyph3D.SetVectorModeToUseVector()
      glyph3D.SetVectorModeToUseNormal()
      glyph3D.SetInput(&vol_polydata)
      glyph3D.SetScaleFactor(0.1)
      #printn glyph3D.GetVectorModeAsString()
      glyph3D.Update()
      
      #Visualize
      mapper = vtk.vtkPolyDataMapper.New()
      mapper.SetInputConnection(&glyph3D.GetOutputPort())

      #actor = vtk.vtkActor.New()
      #actor.SetMapper(&mapper)
      
      #renderer = vtk.vtkRenderer.New()
      
      #renderWindow = vtk.vtkRenderWindow.New()
      #renderWindow.AddRenderer(&renderer)
      
      #renderWindowInteractor = vtk.vtkRenderWindowInteractor.New()
      #renderWindowInteractor.SetRenderWindow(&renderWindow)
      
      #renderer.AddActor(&actor)
      #renderer.SetBackground(0.3, 0.6, 0.3)
      
      #renderWindow.Render()
      #renderWindowInteractor.Start()
      
      #Create the wxVTKFrame
      renwin_interact = global::wxVTKFrame()
      renwin = renwin_interact.GetRenderWindow()
      #Create and add the renderer
      renderer = vtk.vtkRenderer.New()
      renwin.AddRenderer(&renderer)
      interact = vtk.vtkInteractorStyleTrackballCamera.New()
      renwin_interact.SetInteractorStyle(&interact)
      #This is the actor with the planes
      actor = vtk.vtkActor.New()
      actor.SetMapper(&mapper)
      renderer.AddActor(&actor)
      #This is the actor with the input image
      renderer.AddActor(&vol_actor)
      renderer.ResetCameraClippingRange()
      renderer.SetBackground(0.3, 0.6, 0.3)
      renderer.ResetCamera()
      
      #renwin.Render()
      renwin_interact.Start()
      
    }
    
    #-----------------------
    
    proc ::drawBorder() {
      if(exists(::res) && exists(::sp3D)){
        image_draw = &::input_draw

        #InitTime
        #Catch visualization region limits
        xmin = image_draw.GetXmin()
        xmax = image_draw.GetXmax()
        ymin = image_draw.GetYmin()
        ymax = image_draw.GetYmax()
        zmin = image_draw.GetZmin()
        zmax = image_draw.GetZmax()
        #inside delimits the draw area inside the region defined by xmin,xmax,ymin and ymax
        inside = (::res->xpos>=xmin)*(::res->xpos<=xmax)*(::res->ypos>=ymin)*(::res->ypos<=ymax)* \
                 (::res->zpos>=zmin)*(::res->zpos<=zmax)
        inside_crop = autocrop(inside,0)
        x_crop = ::res->xpos[inside_crop.GetExtent]
        y_crop = ::res->ypos[inside_crop.GetExtent]
        z_crop = ::res->zpos[inside_crop.GetExtent]
        #XY plane
        image_draw.SetPenColor(&wx.wxColour(255,0,0))
        for i=0 to inside_crop.tx-1 {
          if (inside_crop(i,0) && z_crop(i,0) == 25) {
            image_draw.DrawLineZ(x_crop(i,0), y_crop(i,0), x_crop(i,0), y_crop(i,0))
          }
        }
        image_draw.DrawingAreaDisplay()
        #XZ plane
        #YZ plane
        
      } else {
        InfoDialog "Before draw the border, you must apply the method."
      }
    }
    Comments(::drawBorder, "Draw the sub-pixel border")
    
    #-----------------------
    
    proc ::Run() {
    	::load_input()
      #Erase the draw objects
      if (exists(::input_draw))    { del ::input_draw; }
      #
      if (::input.vdim==1) {
        ::input <<= (DOUBLE) ::input
        ::norm_input <<= (::input<=1)*1 + (::input>1)*::input
        ::norm_input.info
      } else {
      	::norm_input <<= (DOUBLE) norm(::input)
        ::norm_input.info
      }
      #Erase the subpixel object and the result if it exists
      if (exists(::res))  { del ::res; }
      if (exists(::sp3D)) { del ::sp3D; }
      #Build a SubPixel3D object
      ::sp3D = ::import->SubPixel3D(&::norm_input,::threshold,::linear)
      
      if (::alg_type == 0) {
        ::res = ::sp3D->GradienteCurvo3D()
      }
      
      ::Display()
      ::drawBorder()
      #::vtkExample() Esta es la función buena, ahora la sustituyo por una prueba
      ::vtkPruebita()
      
      ::input_draw.PaintCallback(&::drawBorder)
    }
    Comments(::Run, "Detects edges with Subpixel3D methods")
    
    #-----------------------
    
    proc ::Display() {
      #global
      if (exists(::input)) {
            show ::input
      } 
    }
    Comments(::Display, "Show the result image")
    
    #-----------------------
    
    proc ::CreateGui() {
      ::import = &global::ami_import;
      ::win = ::import->ParamPanel("Subpixel 3D")
      
      ::win.BeginBook()
        ::win.AddPage("Param.")
        
          #Global parameters panel
          ::win.BeginBoxPanel("Global parameters")
            ::win.BeginHorizontal()
              ::win.AddImageChoice(&::input_name, "In.")
              ::AddBitmapButton(&::win, &::icons._New_image, 16, "load_input")
            ::win.EndHorizontal()
            ::win.AddString(&::output_name, "Out.")
            #Edge detection parameters
            ::win.AddFloat(&::threshold, "Thr.", 0, 100)
            ::win.AddBoolean(&::linear, "1st order")
          ::win.EndBoxPanel()
          
          #Method panel
          ::win.BeginBoxPanel("Subpixel detection method")
            ::alg_enum = ::win.AddEnum(&::alg_type, "Method")
              ::win.AddEnumChoice(::alg_enum, "Basic detector")
          ::win.EndBoxPanel()
          
 
          ::icons.LoadIconPNG("Play")
          ::AddBitmapButton(&::win, &::icons._Play, 16, "Run")
          
      
      ::win.EndBook()

      ::AddStandardButtons(&::win)
      ::win.Update(-1)
      ::win.Display
    }
    
    ::Init

  } #end Class

} #end If
