#Interface for sub-pixel 3D detection

func "Common/ScriptGui"

#For use VTK
import_vtk

if (!exists(Subpixel3DClass)){

	#Import filters
  ami_import->Filters()

	Class Subpixel3DClass : public ScriptGui{
  
    ::filters = &global::filters
    
    #-----------------------
    proc ::Init(){
      ::class_name  = "global::Subpixel3DClass"
      ::input_name  = "",                "Input image"
      ::output_name = "subpixel3D_edge", "Output image name"
      ::threshold   = 25,                "Gradient threshold"
      ::alg_type    = INT(0),            "Sub-pixel 3D algorithm type"
      ::alg_enum    = INT(0),            "Enumeration of algorithms"
      ::show_vol    = UCHAR(0),          "Show or hide the volume"
      ::show_planes = UCHAR(1),          "Show or hide the planes of the edge"
      ::show_normals= UCHAR(0),          "Show or hide the normals of the edge"
    }
    

    #-----------------------
    
    proc ::load_input() {
      eval "::input <<="+::input_name+";"
      if (::input_name=="BrowseImage") {
        ::input_name = "::input"
        ::win.Update(-1)
      }
    }
    Comments(::load_input, "Load the input image")
    
    #-----------------------
    
    proc ::vtkDrawEdges() {
      #Edge points
      edge_points = vtk.vtkPoints.New()
      #We fill the points with the result of the subpixel3D algorithm
      for i = 0 to ::res->xpos.tx-1 {
        edge_points.InsertNextPoint(::res->xpos(i), ::res->ypos(i), ::res->zpos(i))
      }
      
      #Add the points to a polydata
      edges_polydata = vtk.vtkPolyData.New()
      edges_polydata.SetPoints(&edge_points)
      
      #Array for the normals
      normals_array = vtk.vtkDoubleArray.New()
      #Three components (x,y,z)
      normals_array.SetNumberOfComponents(3)
      #The number of tuples will be the number of edge pixels
      normals_array.SetNumberOfTuples(::res->xpos.tx)
      #We fill the array with the normals previously computed
      if(exists(i)) { del i; }
      for i = 0 to ::res->xpos.tx-1 {
        if (exists(v)) { del v; }
        v = vector_double()
        v.push_back(::res->nx(i,0,0))
        v.push_back(::res->ny(i,0,0))
        v.push_back(::res->nz(i,0,0))
        normals_array.SetTupleValue(i, &v[0])
      }
      
      #Asign the normals to the polydata
      edges_polydata.GetPointData().SetNormals(&normals_array)
      
      if (::show_vol == 1) {
        #Drawing the input image
        ::vol_isosurf = isosurf(::input, (max(::input)+min(::input))/2)
        #Create the polydata and compute the normals
        vol_polydata = global::ToVtkPolyData(::vol_isosurf)
        vol_normals = vtk.vtkPolyDataNormals.New()
        vol_normals.SetInput(&vol_polydata)
        vol_normals.SetFeatureAngle(60.0)
        #Create the mapper and conect it with the normals output
        vol_mapper = vtk.vtkPolyDataMapper.New()
        vol_mapper.SetInputConnection(&vol_normals.GetOutputPort())
        vol_mapper.ScalarVisibilityOff()
        #Create a new actor set the vol_mapper
        ::vol_actor = vtk.vtkActor.New()
        ::vol_actor.SetMapper(&vol_mapper)
      }
     
      if (::show_normals == 1) {
        arrowSource = vtk.vtkArrowSource.New()
        arrow_glyph3D = vtk.vtkGlyph3D.New()
        arrow_glyph3D.OrientOn()
        arrow_glyph3D.SetSource(&arrowSource.GetOutput())
        arrow_glyph3D.SetVectorModeToUseNormal()
        arrow_glyph3D.SetInput(&edges_polydata)
        arrow_glyph3D.SetScaleFactor(0.5)
        arrow_glyph3D.Update()
        
        #Mapper for the visualization
        arrow_mapper = vtk.vtkPolyDataMapper.New()
        arrow_mapper.SetInputConnection(&arrow_glyph3D.GetOutputPort())
        
        #Actor
        ::arrow_actor = vtk.vtkActor.New()
        ::arrow_actor.SetMapper(&arrow_mapper)
      }
      
      if (::show_planes == 1) {
        planeSource = vtk.vtkPlaneSource.New()
        planeSource.SetNormal(1.0, 0.0, 0.0)
        plane_glyph3D = vtk.vtkGlyph3D.New()
        plane_glyph3D.OrientOn()
        plane_glyph3D.SetSource(&planeSource.GetOutput())
        plane_glyph3D.SetVectorModeToUseNormal()
        plane_glyph3D.SetInput(&edges_polydata)
        plane_glyph3D.SetScaleFactor(0.8)
        plane_glyph3D.Update()
        
        #Mapper for the visualization
        plane_mapper = vtk.vtkPolyDataMapper.New()
        plane_mapper.SetInputConnection(&plane_glyph3D.GetOutputPort())
        
        #Actor
        ::plane_actor = vtk.vtkActor.New()
        ::plane_actor.SetMapper(&plane_mapper)
      }
      
      #Create the scene
      renwin = ::renwin_interact.GetRenderWindow()
      #Create and add the renderer
      renderer = vtk.vtkRenderer.New()
      renwin.AddRenderer(&renderer)
      interact = vtk.vtkInteractorStyleTrackballCamera.New()
      ::renwin_interact.SetInteractorStyle(&interact)
      #We add the actors
      if (::show_vol == 1) {
        renderer.AddActor(&::vol_actor)
      }
      if (::show_planes == 1) {
        renderer.AddActor(&::plane_actor)
      }
      if (::show_normals == 1) {
        renderer.AddActor(&::arrow_actor)
      }

      renderer.ResetCameraClippingRange()
      renderer.SetBackground(0.3, 0.3, 0.6)
      renderer.ResetCamera()
      #renwin.Render()
      ::renwin_interact.Start()
      
    }
    
    #-----------------------
    
    proc ::Run() {
    	::load_input()
      #Erase the draw objects
      if (exists(::input_draw))    { del ::input_draw; }
      #
      if (::input.vdim==1) {
        ::input <<= (DOUBLE) ::input
        ::norm_input <<= (::input<=1)*1 + (::input>1)*::input
        #::norm_input.info
      } else {
      	::norm_input <<= (DOUBLE) norm(::input)
        ::norm_input.info
      }
      #Erase the subpixel object and the result if it exists
      if (exists(::res))  { del ::res; }
      if (exists(::sp3D)) { del ::sp3D; }
      #Build a SubPixel3D object
      ::sp3D = ::import->SubPixel3D(&::norm_input,::threshold)
      
      if (::alg_type == 0) {
        ::res = ::sp3D->GradienteCurvo3D()
      }
      
      ::vtkDrawEdges()
      
    }
    Comments(::Run, "Detects edges with Subpixel3D methods")
    
    #-----------------------
    
    proc ::Display() {
      #global
      if (exists(::input)) {
            show ::input
      } 
    }
    Comments(::Display, "Show the result image")
    
    #-----------------------
    
    proc ::MainBook_AddVolRenTab() {
       mb = ami.MainFrame.GetMainBook()

      ::panel = wx.wxPanel(&ami.MainFrame)
      ::panel._SetName("Subp3D")

      sbox_sizer = wx.wxBoxSizer(wx.wxVERTICAL)
      ::panel.SetSizer(&sbox_sizer)
      ::flex_sizer =  wx.wxFlexGridSizer(2,1,0,0)
      ::flex_sizer.AddGrowableRow(0,4)
      ::flex_sizer.AddGrowableRow(1,1)
      ::flex_sizer.AddGrowableCol(0,1)

      sbox_sizer.Add( &::flex_sizer, 1, wx.wxALL | wx.wxEXPAND,2)
      # create widget here
      import_vtk
      ::renwin_interact = wxVTKRenderWindowInteractor(&::panel,-1)
      ::renwin_interact.UseCaptureMouseOn()
      ::renwin_interact.Enable(true)
      # Still drawing problem (missed exposed events???)
      ::renwin_interact.SetBackgroundColour(wx.wxColour(0,0,0))
      ::flex_sizer.Add(&::renwin_interact, 1, wx.wxEXPAND | wx.wxALL | wx.wxALIGN_CENTER )
      
      # Add to main book
      ::icons.LoadIconPNG2("Transparency","Transparency")
      mb.AddPage( &::panel,"Subp3D",1, wx.wxBitmap(&::icons._Transparency.Scale(16,16)))
      ::volren_pageindex = mb.GetPageIndex(&::panel)
      
    }
    
    #-----------------------
    
    proc ::MainBook_CloseTab() {
      if (exists(::volren_pageindex)){
        mb = ami.MainFrame.GetMainBook()
        mb.DeletePage(::volren_pageindex)
      }
    }
    
    #-----------------------
    
    # Redefinition of Close to close the panel tab in main_book
    #
    proc ::Close() {
      ::MainBook_CloseTab()
      ::win.HidePanel()
      delvars GetObjectName(::Close)
    }
    Comments( ::Close, "Will close the interface and delete the corresponding object named '"+GetObjectName(::Close)+"'.")
    
    #-----------------------
    
    proc ::CreateGui() {
      ::import = &global::ami_import;
      ::win = ::import->ParamPanel("Subpixel 3D")
      
      ::win.BeginBook()
        ::win.AddPage("Param.")
        
          #Global parameters panel
          ::win.BeginBoxPanel("Global parameters")
            ::win.BeginHorizontal()
              ::win.AddImageChoice(&::input_name, "In.")
              ::AddBitmapButton(&::win, &::icons._New_image, 16, "load_input")
            ::win.EndHorizontal()
            ::win.AddString(&::output_name, "Out.")
            #Edge detection parameters
            ::win.AddFloat(&::threshold, "Thr.", 0, 100)
          ::win.EndBoxPanel()
          
          #Method panel
          ::win.BeginBoxPanel("Subpixel detection method")
            ::alg_enum = ::win.AddEnum(&::alg_type, "Method")
              ::win.AddEnumChoice(::alg_enum, "Basic detector")
          ::win.EndBoxPanel()
      
          ::win.BeginBoxPanel("Visualization")
            ::win.AddBoolean(&::show_vol, "Volume")
            ::win.AddBoolean(&::show_planes, "Edges")
            ::win.AddBoolean(&::show_normals, "Normals")
          ::win.EndBoxPanel()
          
 
          ::icons.LoadIconPNG("Play")
          ::AddBitmapButton(&::win, &::icons._Play, 16, "Run")
          
      
      ::win.EndBook()

      ::AddStandardButtons(&::win)
      ::win.Update(-1)
      ::win.Display
      
      ::MainBook_AddVolRenTab()
    }
    
    ::Init()

  } #end Class

} #end If
