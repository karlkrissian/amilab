
if (!exists(MinSearchClass)) {

  Class MinSearchClass {

    proc ::Init() {
      ::eval_string = "res = (input-10)*(input-10)", "Evaluation string, defines the function to minimize and uses 'input' as input value and 'res' as resulting value"

      ::minval = 0, "Minimal value"
      ::maxval = 1, "Maximal value"
      ::nbits  = INT(4), "number of iteration of dichotomial method"
      ::CreateWindow()
    }

    #----------------------------
    proc ::Close() \
    {
      ::win.Hide
      delvars GetObjectName(::Close)
    }
    ::Close.Comments("Will close the interface and delete the corresponding object named '"+GetObjectName(::Close)+"'.")
    
    #----------------------------
    proc ::CloseAll() \
    {
      ::Close
      if (exists(MinSearchClass)) { del MinSearchClass; }
    }
    ::CloseAll.Comments("Call ::Close() method and delete the class variable")
    
    #
    # Simple procedure to find the minimum of a function
    #
    proc ::EvalFunction( NUM input, NUM res ) {
      #res = (input-10)*(input-10)
      eval ::eval_string
      print sprint("%2.2f --> ",input)+sprint("%2.2f\n",res);
    }
    
    
    #
    # Simple procedure to find the minimum of a function
    #
    proc ::FindMinimum() {
    #
      v0=0; v1=0; v2=0;
      v=0;
      _step=(::maxval-::minval)/2.0
    
      ::EvalFunction(::minval,&v0)
      ::EvalFunction(::minval+_step,&v1)
      ::EvalFunction(::maxval,&v2)
    
      current=::minval+_step
    
      for _n=0 to ::nbits { 
    
      # different configurations  
      if (v0<v1) {
        if ((current-2*_step)>::minval) {
          v2=v1
          v1=v0
          current=current-_step
          ::EvalFunction(current-_step,&v0)      
        } else {
          v2=v1
          _step=_step/2.0
          current=current-_step
          ::EvalFunction(current,&v1)
        }
      } else {
        if ((v1<v0)&&(v1<v2)) {
          _step=_step/2
          ::EvalFunction(current-_step,&v0)
          ::EvalFunction(current+_step,&v2)
        } else {
          if (v2<v1) {
            if ((current+2*_step)<::maxval) {
              v0=v1
              v1=v2
              current=current+_step
              ::EvalFunction(current+_step,&v2)      
            } else {
              _step=_step/2
              current=current+_step
              v0=v1
              ::EvalFunction(current,&v1)     
            }
          }
        }
      }
    
      } // for
    
    
      print sprint("x=     %2.3f \t",current-_step)
      print sprint("%2.3f \t",current)
      print sprint("%2.3f \n",current+_step)
    
      print sprint("values %2.3f \t",v0)
      print sprint("%2.3f \t",v1)
      print sprint("%2.3f \n",v2)
    
    
    }

    proc ::CreateWindow() \
    {
      # parameters window
      ::win = ParamWin("MinSearch")
      
      ::win.BeginBook
        ::win.AddPage("Parameters")
          ::win.AddString(::eval_string,"Eval string")
          ::win.AddFloat(::minval,"min",0,100)
          ::win.AddFloat(::maxval,"max",0,100)
          ::win.AddInt(::nbits,"iter",1,10)
          ::win.AddButton("Run",::FindMinimum)
      ::win.EndBook
      ::win.BeginHorizontal
        ::win.AddButton("Close",      ::Close)
        ::win.AddButton("Close All",  ::CloseAll)
      ::win.EndHorizontal
      
      ::win.update
      ::win.Display
    }

    ::Init

  }
  # end class MinSearchClass
}

#----------------------------
# Main
#----------------------------

if (!exists(minsearch)) {

  MinSearchClass minsearch
  
  if (argc>=1) {
    printn "reading image"
    minsearch->eval_string = $1
    minsearch->win.update
  }

} else {
  InfoDialog "The script seems to be already loaded."
}

