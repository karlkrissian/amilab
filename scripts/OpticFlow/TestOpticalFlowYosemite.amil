# command line: ./amilab 

ami_import->AMIFluid()


yos_mask ="Yosemite/Mask/mask%02.0f.bmp"

seqmin=INT(0)
seqmax=INT(14)

use_clouds        = UCHAR(0)
symmetric         = UCHAR(1)
inverse_upsample  = INT(1)
temporal          = UCHAR(1)
global_smoothing  = UCHAR(1)
use_Javier        = UCHAR(0)
use_JavAgustin    = UCHAR(0)
use_Vorticity     = UCHAR(0)
use_Zoom          = UCHAR(0)
Gaussian_scales   = UCHAR(0)
use_splines       = UCHAR(0)

presmoothing      = 0.6

removelastline = UCHAR(0)

input_data_name   = ""

#--------------------------------------------------
# ami PDE optic flow parameters
#
beta            = 0.25
alfa            = 2.0
Conv_GS_exp     = INT(-5)
Nscales         = INT(3)
Conv_Scales_exp = INT(-2)
gradtype        = INT(0)
boundarytype    = INT(0)
gradcomputation = INT(0)
smoothfunction  = INT(0)
smoothgradient      = UCHAR(0)
alpha_normalization = UCHAR(1)
alpha_norm_epsilon  = INT(-2)


#--------------------------------------------------
# Javier's code parameters
#
zoom            = INT(2)
alfa_Javier     = 10
T               = 500
dt              = 10
Nu              = 0.5

#--------------------------------------------------
# Javier and Agustin's code parameters
#
JA_zoom         = INT(2)
JA_alfa         = 0.6
JA_beta         = 0.3
JA_gamma        = 1
JA_isotropy     = 0.1
JA_T            = 500
JA_dt           = 10
JA_Nu           = 0.5

#--------------------------------------------------
# Vorticity code parameters
#
vort_grid       = INT(1)
vort_winsize    = INT(5)
vort_sigma      = 2
vort_alpha_log  = 3
vort_TOL_log    = -5

#--------------------------------------------------
# Vorticity code parameters
#
OFzoom_sigma    = 1.0
OFzoom_T        = 500.0
OFzoom_nbiter   = INT(5)
OFzoom_alpha    = 1.0
OFzoom_ht       = 10
OFzoom_quantile = 0.15
OFzoom_zoom     = INT(4);
# from 0 to 3:
# 0: Horn/Schunck
# 1: image driven, isotropic
# 2: image driven, anisotropic (Nagel)
# 3: flow driven, isotropic
OFzoom_dtype    = INT(0)

#--------------------------------------------------
# test varying alfa
#
alfa_min  = 0.25
alfa_max  = 4
alfa_step = 0.25

#--------------------------------------------------
# Continous Gaussian Scales
#
sigma_min  = 0.4
sigma_max  = 4
sigma_N    = INT(5)


#
proc LoadDisks() {
#    -----------
  global

  vx=1
  vy=1.5

  i = Image(FLOAT,64,64,1)
  func "/home/karl/projects/Scripts/AddSphere.amil"
  i = i*0-10
  AddBrightSphere(&i,32,32,0,10)
  i2 = i*0-10
  AddBrightSphere(&i2,32+vx,32+vy,0,10)

  d1 = Image(FLOAT_VECTOR,i.tx,i.ty,i.tz)
  d = d1*0

  local

}

proc DeleteImages() {
  global

  del im
  del im1
  del displ
  del displ_res
  del mask
  del ang_error

  local
}


#
proc LoadImages() {
#    ----------

  global
  input_data_name = "standard"

  if (use_clouds==1) {
    yos_image="Yosemite/Clouds/yos_clouds_%02.0f.bmp"
    yos_displ="Yosemite/Clouds/yos%02.0f.uv_clouds_.uv"
  } else {
    yos_image="Yosemite/NoClouds/yos_images_%02.0f.bmp"
    yos_displ="Yosemite/NoClouds/yos%02.0f.uv_noclouds_.uv"
  }

print "1\n"
  I = Image(sprint(yos_image,seqmin))
  i = (FLOAT) I[0]
  i = Flip(i,1)
  if (removelastline==1) {
    // get rid of last line
    tmp = i
    del i
    i = tmp[0:tmp.tx-1,7:tmp.ty-2,0:0]
    del tmp
  }
  del I

  im = Image(FLOAT,i.tx,i.ty,seqmax-seqmin+1);
  im.putimage(i,0,0,0)
  del i

  displ = Image(FLOAT_VECTOR,im.tx,im.ty,seqmax-seqmin);
  displ.initvalue(0,0,0)

  mask = Image(UCHAR,im.tx,im.ty,seqmax-seqmin);

  # read image sequence
  for seq=seqmin to seqmax-1 {

    I = Image(sprint(yos_image,seq+1)) 
    i = (FLOAT) I[0]
    i = Flip(i,1)

    if (removelastline==1) {
      // get rid of last line
      tmp = i
      del i
      i = tmp[0:tmp.tx-1,7:tmp.ty-2,0:0]
      del tmp
    }
    del I
    im.putimage(i,0,0,seq+1-seqmin)
    del i

    d1 = AMIFluid->amiReadUV(sprint(yos_displ,seq))

    if (removelastline==1) {
      // get rid of last line
      tmp = d1
      del d1
      d1 = tmp[0:tmp.tx-1,7:tmp.ty-2,0:0]
      del tmp
    }
    displ.putimage(d1,0,0,seq-seqmin)
    del d1

    # mask
    M = Image(sprint(yos_mask,seq))
    m = M[0]
    m = Flip(m,1)
    del M

    if (removelastline==1) {
      // get rid of last line
      tmp = m
      del m
      m = tmp[0:tmp.tx-1,7:tmp.ty-2,0:0]
      del tmp
    }
    mask.putimage(m,0,0,seq-seqmin)
    del m
  }

//  del i; del m; del d1

  displ_res= displ*0
  im1 = im[:,:,0:seqmax-seqmin-1]

  ang_error = (FLOAT) displ[0]*0

  local

}
# LoadImages()

#
proc LoadImagesBarron() {
#    ----------

  global

  input_data_name = "Barron"

  if (use_clouds==1) {
    yos_image="YosemiteBarron/yos%02.0f.png"
  } else {
    yos_image="YosemiteBarron/yos_nc%02.0f.png"
  }


  I = Image(sprint(yos_image,seqmin))
  i = (FLOAT) I
  i = Flip(i,1)
  if (removelastline==1) {
    // get rid of last line
    tmp = i
    del i
    i = tmp[0:tmp.tx-1,7:tmp.ty-2,0:0]
    del tmp
  }
  del I

  im = Image(FLOAT,i.tx,i.ty,seqmax-seqmin+1);
  im.putimage(i,0,0,0)
  del i

  displ = Image(FLOAT_VECTOR,im.tx,im.ty,seqmax-seqmin);
  displ.initvalue(0,0,0)

  mask = Image(UCHAR,im.tx,im.ty,seqmax-seqmin);
  mask.initvalue(0)

  # read image sequence
  for seq=seqmin to seqmax-1 {

    I = Image(sprint(yos_image,seq+1)) 
    i = (FLOAT) I
    i = Flip(i,1)

    if (removelastline==1) {
      // get rid of last line
      tmp = i
      del i
      i = tmp[0:tmp.tx-1,7:tmp.ty-2,0:0]
      del tmp
    }
    del I
    im.putimage(i,0,0,seq+1-seqmin)
    del i
  }

  # Read the ground truth
  if (use_clouds==1) {
    displ89 = AMIFluid->amiReadBarronData("YosemiteBarron/yos_clouds.F")
    # set displacement to (2,0) in the clouds
    displ89_x = displ89[0]
    displ89_y = displ89[1]
    displ89_x = displ89_x*(displ89_x<99)+(displ89_x>=99)*2
    displ89_y = displ89_y*(displ89_y<99)
    displ89[0] = displ89_x
    displ89[1] = displ89_y
    displ.putimage(displ89,0,0,8-seqmin)

    # set mask to only 8-9 frame
    mask89 = mask[:,:,8-seqmin:8-seqmin]
    mask89.initvalue(255)
    mask.putimage(mask89)

    del displ89_x
    del displ89_y
    del displ89
    del mask89
  } else {
    displ89 = AMIFluid->amiReadBarronData("YosemiteBarron/yos_noclouds.F")

    # set mask to only 8-9 frame
    mask89 = mask[:,:,8-seqmin:8-seqmin]
    mask89 = (displ89[0]<99)*255
    mask.putimage(mask89)

    # set displacement to (0,0) in the clouds
    displ89_x = displ89[0]
    displ89_y = displ89[1]
    displ89_x = displ89_x*(displ89_x<99)
    displ89_y = displ89_y*(displ89_y<99)
    displ89[0] = displ89_x
    displ89[1] = displ89_y
    displ.putimage(displ89,0,0,8-seqmin)
    displ.putimage(displ89,0,0,8-seqmin)

    del displ89_x
    del displ89_y
    del displ89
    del mask89
  }

  displ_res= displ*0
  im1 = im[:,:,0:seqmax-seqmin-1]

  ang_error = (FLOAT) displ[0]*0

  local

} 
# LoadImagesBarron


#
proc LoadImages2() {
#    ----------
  global
// define im

  i = (FLOAT) Image($1)
  im = Image(FLOAT,i.tx,i.ty,2);
  im.putimage(i,0,0,0)

  i = (FLOAT) Image($2) 
  im.putimage(i,0,0,1)

  if (argc>2) {
    displ = Image($3)
  } else {
    displ = Image(FLOAT,i.tx,i.ty,1,3)
  }
  displ.setvoxelsize(i.vx,i.vy,i.vz)

  displ_res= displ*0
  seqmin=0
  seqmax=1
  im1 = im[:,:,0:seqmax-seqmin-1]

  ang_error = (FLOAT) displ[0]*0

  mask = Image(UCHAR,im.tx,im.ty,seqmax-seqmin);
  mask.initvalue(255)

  local

}


proc InverseFlow( IMAGE _flow, NUM scale_factor) {
  flow1 = Resize(_flow,_flow.tx*scale_factor,_flow.ty*scale_factor,1,2)
  flow1 = AMIFluid->amiInverseFlow(flow1/2)
  _flow = Resize(flow1,_flow.tx,_flow.ty,_flow.tz,2)
}

#--------------------------------------------------
proc invert_flow_2d_t(IMAGE _flow) {
  //
  for seq=0 to _flow.tz-1 {
    _tmp = _flow[:,:,seq:seq]
    InverseFlow(&_tmp,inverse_upsample)
    _flow.putimage(_tmp,0,0,seq)
    del _tmp
  }
}


#--------------------------------------------------
proc call_amiOFPDE_temp(IMAGE _im, IMAGE _res) {

  AMIFluid->amiOFSetSymmetric(symmetric)
  
  Conv_GS     = exp(ln(10)*Conv_GS_exp    )  
  Conv_Scales = exp(ln(10)*Conv_Scales_exp)  
  AMIFluid->amiOF_2D_T(_im,&_res,beta,beta,2,2,alfa,alfa,Conv_GS,Nscales,Conv_Scales,gradtype,smoothfunction)
  
  if (symmetric) {
    // invert flux
    global_new 
    symmetricflow=_res;
    invert_flow_2d_t(&_res)
    local_new
  } 
 
}

#--------------------------------------------------
proc call_amiOFPDE_JavAgustin(IMAGE _im, IMAGE _res) {

  print "Starting call_amiOFPDE_JavAgustin() \n"
  resx = _res[0]
  resy = _res[1]
  _im.info
  resx.info
  resy.info
  AMIFluid->amiOpticFlow(_im,&resx,&resy, JA_zoom, JA_alfa, JA_beta, JA_gamma, JA_isotropy, JA_T, JA_dt, JA_Nu)
  _res[0] = resx;
  _res[1] = resy;

  print "End call_amiOFPDE_JavAgustin() \n"
}


#--------------------------------------------------
proc call_amiOFPDE_Javier(IMAGE _im1, IMAGE _im2, IMAGE _res) {

  resx = _res[0]
  resy = _res[1]
  AMIFluid->amiJavierHornSchunck(_im1,_im2,&resx,&resy, zoom, alfa_Javier, T, dt, Nu);
  _res[0] = resx;
  _res[1] = resy;
}


#--------------------------------------------------
proc call_amiOFPDE_Zoom(IMAGE _im1,IMAGE _im2, IMAGE _res) {

  _resx=_res[0]
  _resy=_res[1]

  AMIFluid->amiOFVar2DZoom(_im1,_im2,OFzoom_sigma,OFzoom_T,OFzoom_alpha,OFzoom_dtype,OFzoom_quantile,OFzoom_ht,&_resx,&_resy,OFzoom_nbiter,OFzoom_zoom);

  _res[0]=_resx
  _res[1]=_resy

}

#--------------------------------------------------
proc call_amiOFPDE_Vorticity(IMAGE _im1,IMAGE _im2, IMAGE _res) {

  vort_alpha  = exp(ln(10)*vort_alpha_log  ) 
  vort_TOL    = exp(ln(10)*vort_TOL_log    ) 

  _resx=_res[0]
  _resy=_res[1]
  _vort=_resx;

  AMIFluid->amiGradVorticity(_im1,_im2,&_resx,&_resy,vort_grid,vort_winsize,vort_sigma,vort_alpha,vort_TOL,&_vort)

  _res[0]=_resx
  _res[1]=_resy

}


#--------------------------------------------------
proc call_OFPDE(IMAGE _im1, IMAGE _im2, IMAGE _res) {
  print "call_OFPDE\n"
  if (use_Javier==1) {
    call_amiOFPDE_Javier(_im1,_im2,&_res)
  } else {
    if (use_Vorticity==1) {
      call_amiOFPDE_Vorticity(_im1,_im2,&_res)
    } else {
      if (use_Zoom==1) {
        call_amiOFPDE_Zoom(_im1,_im2,&_res)
      } else {
        call_amiOFPDE(_im1,_im2,&_res)
      }
    }
  }
}



#--------------------------------------------------
proc call_amiOFPDE_GaussSc(IMAGE _im1, IMAGE _im2, IMAGE _res) {

  AMIFluid->amiOFSetSymmetric(symmetric)
  zoom_z = 1+_im1.tz>1;
  Conv_GS     = exp(ln(10)*Conv_GS_exp    )  
  Conv_Scales = exp(ln(10)*Conv_Scales_exp)  
  
  ln_min=ln(sigma_min)
  ln_max=ln(sigma_max)

  print "1\n"
  // smooth from sigma_max to sigma_min
  for _n=0 to sigma_N-1 {
    print "2\n"
    _sigma = exp(ln_max+(ln_min-ln_max)/(sigma_N-1)*_n)
    print sprint("\n sigma = %0.2f \n",_sigma)
    _im1s = filter(_im1,_sigma,0,0,0)
    _im2s = filter(_im2,_sigma,0,0,0)
    AMIFluid->amiOFPDE_Param(beta,beta,beta,2,2,zoom_z,alfa,alfa,alfa,Conv_GS,1,Conv_Scales,gradtype,smoothfunction)
    AMIFluid->amiOFPDE(_im1s,_im2s,&_res)
  }

  if (symmetric==1) {
    // inverse flow
    InverseFlow(&_res,inverse_upsample)
  }
}


#--------------------------------------------------
proc call_amiOFPDE(IMAGE _im1, IMAGE _im2, IMAGE _res) {

  print "amiOFPDE\n"
  if (Gaussian_scales==1) {
    call_amiOFPDE_GaussSc(_im1,_im2,&_res)
  } else {
    AMIFluid->amiOFSetSymmetric(symmetric)
    zoom_z = 1+_im1.tz>1;
    Conv_GS     = exp(ln(10)*Conv_GS_exp    )  
    Conv_Scales = exp(ln(10)*Conv_Scales_exp)  
    AMIFluid->amiOFPDE_Param(beta,beta,beta,2,2,zoom_z,alfa,alfa,alfa,Conv_GS,Nscales,Conv_Scales,gradtype,smoothfunction)
    AMIFluid->amiOFPDE(_im1,_im2,&_res)

    if (symmetric==1) {
      // inverse flow
      InverseFlow(&_res,inverse_upsample)
    }
  }
}




#--------------------------------------------------
proc call_amiOFPDE_Javier_sym(IMAGE _im1, IMAGE _im2, IMAGE _res) {
  resx = _res[0]
  resy = _res[1]
  AMIFluid->amiJavierHornSchunckSym(_im1,_im2,&resx,&resy, zoom, alfa_Javier, T, dt, Nu);
  _res[0] = resx;
  _res[1] = resy;
  // inverse flow
  _res = AMIFluid->amiInverseFlow(_res)
}


#--------------------------------------------------
proc call_OFPDE_sym(IMAGE _im1, IMAGE _im2, IMAGE _res) {
  if (use_Javier==0) {
    call_amiOFPDE(_im1,_im2,&_res)
  } else {
    call_amiOFPDE_Javier_sym(_im1,_im2,&_res)
  }
}



#--------------------------------------------------
proc angular_error(IMAGE _d1, IMAGE _d0, IMAGE _err){
  _err = (_d1*_d0+1)/sqrt(_d1*_d1+1)/sqrt(_d0*_d0+1)
  # limit to [-1, 1]
  _err = _err*(_err<1) +(_err>=1)
  _err = _err*(_err>-1)-(_err<=-1)
  # convert to degrees
  _err = acos(_err)/Pi*180

}

#--------------------------------------------------
proc RemoveBorder(IMAGE _m, NUM _size) {
  umask = _m[_size:_m.tx-1-_size,_size:_m.ty-1-_size,0:_m.tz-1]
  _m.initvalue(0)
  _m.putimage(umask)
  del umask
}


proc CB_Stats() {

  // some statistics ...
  diff = (displ-displ_res)*(displ-displ_res)

  error = sqrt(mean(diff))
  print sprint("RMS error = %f \n",error);

  ng = normgrad(im,1)
  error = sqrt(mean[ng>0.1](diff))
  print sprint("mean (in high gradients) error = %f \n",error);

  error_max = sqrt(max(diff))
  print sprint("MAX error = %f \n",error_max);

  ang_error.initvalue(0)
  angular_error(displ,displ_res,&ang_error)  


  if (use_clouds) {
    // full image
    mask1=mask*0+255
  } else {
    // remove sky
    mask1=mask
  }
  print sprint("Angular error : %f\n",mean(ang_error));
  print sprint("Angular error (earth): %f\n",mean(ang_error,mask1));
  // standard deviation of the error
  ae1 = ang_error-mean(ang_error,mask1)
  ae1_sd = ae1*ae1
  ang_sd = sqrt(mean(ae1_sd,mask1))
  print sprint("Angular error SD (earth) : %f\n",ang_sd);

  RemoveBorder(&mask1,15)
  print sprint("Angular error (earth - 15 pix. border): %f\n",mean(ang_error,mask1));

  print "Only pixel with big enough displacement ...\n"
  if (use_clouds) {
    // full image
    mask1=mask*0+255
  } else {
    // remove sky
    mask1=mask
  }

  // Erode mask
  mask1f = (FLOAT) mask1
  mask1fe = EDPerode(mask1f,1,0.25)
  mask1 =  (UCHAR) ((mask1fe>127)*255)
  
  print sprint("Angular error : %f\n",mean(ang_error));
  print sprint("Angular error (earth): %f\n",mean(ang_error,mask1));
  RemoveBorder(&mask1,15)
  print sprint("Angular error (earth - 15 pix. border): %f\n",mean(ang_error,mask1));
   
}


#--------------------------------------------------
#--------------------------------------------------

# BUG??,  needed to create this function to avoid a segmentation fault ...
proc UpdateDisplay() {
  global; show im1; local  
}

proc CB_ReLoad() {
  if (images_loaded) {
    DeleteImages()
  }
  LoadImages()
  images_loaded=1
}

proc CB_ReLoadBarron() {
  if (images_loaded) {
    DeleteImages()
  }
  LoadImagesBarron()
  images_loaded=1
}

proc CB_Restart() {
//print "CB_Restart \n"
  displ_res.initvalue(0,0,0);
  CB_Iterate()
}


proc CB_IterateTemporal() {
  if (use_JavAgustin==1) {
    call_amiOFPDE_JavAgustin(im,&displ_res);
  } else {
    call_amiOFPDE_temp(im,&displ_res);
  }
  UpdateDisplay()
}

proc CB_IterateStandard() {
  print seqmin; print "\t"; print seqmax; print "\n"

  if (input_data_name=="Barron") {
    _seqmin=8
    _seqmax=9
  } else {
    _seqmin=seqmin
    _seqmax=seqmax
  }

  for seq=_seqmin to _seqmax-1 {
    print "Computing "; print seq; print "\n"
    seqn=seq-seqmin
    print "1\t"; print seqn; print "\n"
    i  = im[:,:,seqn:seqn]
    print "2\t";
    i2 = im[:,:,seqn+1:seqn+1]
    print "3\t";
    d  = displ_res[:,:,seqn:seqn]
    if (symmetric==0) {
      call_OFPDE(i,i2,&d);
    } else { 
      call_OFPDE_sym(i,i2,&d);
    }
    displ_res.putimage(d,0,0,seqn)
  }
  UpdateDisplay()
}

proc CB_Iterate() {
//  print "CB_Iterate \n"
//  print sprint("temporal %0.0f \n",temporal);
  if (presmoothing>0.1) {
    im_bak=im
    # 2D Gaussian filtering in X and Y
    im = filter(im_bak,presmoothing,0,0,-1)
  }
  alpha_epsilon  = exp(ln(10)*alpha_norm_epsilon)

  #print sprint("global smoothing = %01.0f \n",global_smoothing)
  AMIFluid->amiOFSetGlobalConstraint(global_smoothing)
  AMIFluid->amiOFSetSmoothGradient(smoothgradient)
  AMIFluid->amiOFSetGradient(gradcomputation)
  AMIFluid->amiOFSetBoundaryType(boundarytype)
  AMIFluid->amiOFSetAlphaNormEpsilon(alpha_epsilon)
  AMIFluid->amiOFSetNormalizeAlpha(alpha_normalization)

  AMIFluid->amiOFSetInterpolation(use_splines)
  if (temporal==1) {
    CB_IterateTemporal()
  } else {
    CB_IterateStandard()
  }

  if (presmoothing>0.1) {
    im = im_bak
    del im_bak
  }

}


proc CB_Display() {
  global
  show im1;
  im1_draw.setvector(1,displ_res);
  im1_draw.setvector(2,displ);
  local
}

proc CB_InputImages() {
  global
  winput.Display
  local
}

proc CB_AlphaTests() {
  global
  w2.Display
  local
}

proc CB_amiOF_param() {
  global
  wamiOF.Display
  local
}


proc CB_JavOF_param() {
  global
  wJavOF.Display
  local
}

proc CB_JAOF_param() {
  global
  wJAOF.Display
  local
}

proc CB_Vort_param() {
  global
  wVort.Display
  local
}

proc CB_OFzoom_param() {
  global
  wOFzoom.Display
  local
}

proc CB_GaussianScales_param() {
  global
  wGaussSc.Display
  local
}

proc CB_RunAlphaTests() {

  param_str=""
  if (symmetric) {
    param_str = param_str + "_SYM"
  } else { 
    param_str = param_str + "_STD"
  }
  if (temporal) {
    param_str = param_str + "_2DT"
  } else { 
    param_str = param_str + "_2D_"
  }
  param_str = param_str + sprint("_seq%0.0f-",seqmin)
  param_str = param_str + sprint("%0.0f",seqmax)
  param_str = param_str + sprint("_PreSmooth%0.2f",presmoothing)
  param_str = param_str + sprint("_Beta%0.2f",beta)
  param_str = param_str + sprint("_Scal%0.0f",Nscales)
  param_str = param_str + sprint("_GradTyp%0.0f",gradtype)
  param_str = param_str + sprint("_GradComp%0.0f",gradcomputation)
  param_str = param_str + sprint("_BoundTyp%0.0f",boundarytype)
  param_str = param_str + sprint("_SmoothGrad%0.0f",smoothgradient)  
  param_str = param_str + sprint("_GlobSmooth%0.0f",global_smoothing)  
  param_str = param_str + sprint("_SmoothFunc%0.0f",smoothfunction)
  param_str = param_str + sprint("_UseSplines%0.0f",use_splines)
  param_str = param_str + sprint("_AlphaNorm%0.0f",alpha_normalization)
  param_str = param_str + sprint("_AlphaEps%0.0f",alpha_norm_epsilon)
  param_str = param_str + sprint("_GST%0.0f",Conv_GS_exp)
  param_str = param_str + sprint("_ST%0.0f",Conv_Scales_exp)
  param_str = param_str + sprint("_a%0.2f",alfa_min)
  param_str = param_str + sprint("-%0.2f",alfa_max)
  param_str = param_str + sprint("-%0.2f",alfa_step)


  if (use_clouds==1) {
    filedir="Results/Clouds/"
  } else {
    filedir="Results/NoClouds/"
  }

  filename1=filedir+"MeanAngError____"+param_str+".dat"
  filename2=filedir+"MeanAngErrorMarg"+param_str+".dat"
  filename3=filedir+"SDAngError______"+param_str+".dat"
  filename4=filedir+"MeanAngErrorSky_"+param_str+".dat"
  test_file1 = open(filename1,"w")
  test_file2 = open(filename2,"w")
  test_file3 = open(filename3,"w")
  test_file4 = open(filename4,"w")

  param_str = ""
  if (symmetric) {
    param_str = param_str + "(Symmetric) "
  } else { 
    param_str = param_str + "(Standard) "
  }
  if (temporal) {
    param_str = param_str + "(Temporal) "
  } else { 
    param_str = param_str + "(2D) "
  }
  param_str = param_str + sprint("(sequence,%0.0f,",seqmin)
  param_str = param_str + sprint("%0.0f) ",seqmax)
  param_str = param_str + sprint("(presmooth,%0.2f) ",presmoothing)
  param_str = param_str + sprint("(beta,%f) ",beta)
  param_str = param_str + sprint("(Nscales,%0.0f) ",Nscales)
  param_str = param_str + sprint("(gradtype,%0.0f) ",gradtype)
  param_str = param_str + sprint("(gradcomputation,%0.0f) ",gradcomputation)
  param_str = param_str + sprint("(boundtype,%0.0f) ",boundarytype)
  param_str = param_str + sprint("(smooth gradient,%0.0f) ",smoothgradient)
  param_str = param_str + sprint("(global smoothing,%0.0f) ",global_smoothing)
  param_str = param_str + sprint("(smoothfunction,%0.0f) ",smoothfunction)
  param_str = param_str + sprint("(splines,%0.0f) ",use_splines)
  param_str = param_str + sprint("(alpha normalization,%0.0f)",alpha_normalization)
  param_str = param_str + sprint("(alpha normalization epsilon,%0.0f)",alpha_norm_epsilon)
  param_str = param_str + sprint("(GS TOL,10^%0.0f) ",Conv_GS_exp)
  param_str = param_str + sprint("(Scale TOL,10^%0.0f) ",Conv_Scales_exp)
  param_str = param_str + sprint("(alpha,%f,",alfa_min)
  param_str = param_str + sprint("%f,",alfa_max)
  param_str = param_str + sprint("%f) ",alfa_step)

  # print parameter information at the beginning of the files
  test_file1.print "# Optical Flow technique\n"
  test_file1.print "# Angular error obtained for the Yosemite sequence\n"
  test_file1.print "# amilab script: "+$0+" \n"
  test_file1.print "# Parameters\n"
  test_file1.print "# "+param_str+"\n"


  test_file2.print "# Optical Flow technique\n"
  test_file2.print "# Angular error obtained for the Yosemite sequence\n"
  test_file2.print "# amilab script: "+$0+" \n"
  test_file2.print "# Parameters\n"
  test_file2.print "# "+param_str+"\n"
  test_file2.print "# margin of 15 pixels at the border\n"

  test_file3.print "# Optical Flow technique\n"
  test_file3.print "# Standard deviation of the angular error obtained for the Yosemite sequence\n"
  test_file3.print "# amilab script: "+$0+" \n"
  test_file3.print "# Parameters\n"
  test_file3.print "# "+param_str+"\n"

  test_file4.print "# Optical Flow technique\n"
  test_file4.print "# Angular error obtained for the Yosemite sequence, getting rid of the pb close to the sky\n"
  test_file4.print "# amilab script: "+$0+" \n"
  test_file4.print "# Parameters\n"
  test_file4.print "# "+param_str+"\n"

  n=(alfa_max-alfa_min)/alfa_step
  for k=0 to n {
    alfa = alfa_min+k/n*(alfa_max-alfa_min)
    CB_Restart()

    ang_error.initvalue(0)
    angular_error(displ,displ_res,&ang_error)  

    if (use_clouds) {
      // full image
      mask1=mask*0+255
    } else {
      // remove sky
      mask1=mask
    }

    test_file1.print alfa
    test_file1.print "\t"
    test_file1.print mean(ang_error,mask1)
    test_file1.print "\n"

    // standard deviation of the error
    ae1 = ang_error-mean(ang_error,mask1)
    ae1_sd = ae1*ae1
    ang_sd = sqrt(mean(ae1_sd,mask1))

    test_file3.print alfa
    test_file3.print "\t"
    test_file3.print ang_sd
    test_file3.print "\n"

    // error after removing 15 pixels at the border
    RemoveBorder(&mask1,15)
    test_file2.print alfa
    test_file2.print "\t"
    test_file2.print mean(ang_error,mask1)
    test_file2.print "\n"

    if (use_clouds) {
      // full image
      mask1=mask*0+255
    } else {
      // remove sky
      mask1=mask
    }
    // Erode mask
    mask1f = (FLOAT) mask1
    mask1fe = EDPerode(mask1f,1,0.25)
    mask1 =  (UCHAR) ((mask1fe>127)*255)
    test_file4.print alfa
    test_file4.print "\t"
    test_file4.print mean(ang_error,mask1)
    test_file4.print "\n"

    ProcessXEvents(200);

  }

  print "closing files \n"
  test_file1.close
  test_file2.close
  test_file3.close
  test_file4.close
  print "files closed\n"
}


#--------------------------------------------------
# Input Images
#
winput = ParamWin("Input")
winput.BeginBox("Yosemite sequence from M. Black")
use_clouds_id      = winput.AddBoolean(use_clouds)
removelastline_id  = winput.AddBoolean(removelastline)
seqmin_id          = winput.AddInt(seqmin,0,14)
seqmax_id          = winput.AddInt(seqmax,0,14)
restart_id         = winput.AddButton("ReLoad", CB_ReLoad)
winput.EndBox
winput.BeginBox("Yosemite sequence from Barron")
use_clouds_id      = winput.AddBoolean(use_clouds)
removelastline_id  = winput.AddBoolean(removelastline)
seqmin_id          = winput.AddInt(seqmin,1,15)
seqmax_id          = winput.AddInt(seqmax,1,15)
restart_id         = winput.AddButton("ReLoad", CB_ReLoadBarron)
winput.EndBox
winput.BeginBox("Image from parameters")
loadimparam_id     = winput.AddButton("Load", LoadImages2)
winput.EndBox
winput.CreateWin



#--------------------------------------------------
# Parameters for libami's code
#
wamiOF = ParamWin("PDE Param")

presmoothing_id    = wamiOF.AddFloat(presmoothing,0,3)
beta_id            = wamiOF.AddFloat(beta,0.01,5)
alfa_id            = wamiOF.AddFloat(alfa,0.01,20)
Nscales_id         = wamiOF.AddInt(Nscales,1,5)

gradtype_id        = wamiOF.AddInt(gradtype,0,3)

gradcomputation_id = wamiOF.AddEnum(gradcomputation)
wamiOF.AddEnumChoice(gradcomputation_id,"grad_max")
wamiOF.AddEnumChoice(gradcomputation_id,"grad_3x3")
wamiOF.AddEnumChoice(gradcomputation_id,"grad_splines")

boundtype_id = wamiOF.AddEnum(boundarytype)
wamiOF.AddEnumChoice(boundtype_id,"border")
wamiOF.AddEnumChoice(boundtype_id,"outside mask")


smoothfunction_id  = wamiOF.AddEnum(smoothfunction)
wamiOF.AddEnumChoice(smoothfunction_id,"x^2")
wamiOF.AddEnumChoice(smoothfunction_id,"sqrt(x^2)")

smoothgradient_id      = wamiOF.AddBoolean(smoothgradient) 
alpha_normalization_id = wamiOF.AddBoolean(alpha_normalization)
alpha_norm_epsilon_id  = wamiOF.AddInt(alpha_norm_epsilon,-5,0)

wamiOF.BeginBox("Convergence")
#wamiOF.BeginHorizontal
Conv_GS_exp_id     = wamiOF.AddInt(Conv_GS_exp,-10,0)
Conv_Scales_exp_id = wamiOF.AddInt(Conv_Scales_exp,-5,0)
#wamiOF.EndHorizontal
wamiOF.EndBox
wamiOF.CreateWin

#--------------------------------------------------
# Parameters for Javier's code
#
wJavOF = ParamWin("Javier PDE Param")
zoom_id            = wJavOF.AddInt(  zoom,       0,5)
alphaJ_id          = wJavOF.AddFloat(alfa_Javier,0.01,20)
T_id               = wJavOF.AddFloat(T,          0.01,2000)
dt_id              = wJavOF.AddFloat(dt,         0.01,20)
Nu_id              = wJavOF.AddFloat(Nu,         0.01,10)
wJavOF.CreateWin

#--------------------------------------------------
# Parameters for Javier and Agustin's code
#
wJAOF = ParamWin("Javier and Agustin PDE Param")
JA_zoom_id         = wJAOF.AddInt  ( JA_zoom,    0,   5)
JA_alpha_id        = wJAOF.AddFloat( JA_alfa,    0.01,5)
JA_beta_id         = wJAOF.AddFloat( JA_beta,    0.01,5)
JA_gamma_id        = wJAOF.AddFloat( JA_gamma,   0.01,5)
JA_isotropy_id     = wJAOF.AddFloat( JA_isotropy,0.01,5)
JA_T_id            = wJAOF.AddFloat( JA_T,       0.01,2000)
JA_dt_id           = wJAOF.AddFloat( JA_dt,      0.01,20)
JA_Nu_id           = wJAOF.AddFloat( JA_Nu,      0.01,10)
wJAOF.CreateWin

#--------------------------------------------------
# Parameters for Vorticity code
#
wVort = ParamWin("Vorticity OF param")
vort_grid_id       = wVort.AddInt(vort_grid,   1,10)
vort_winsize_id    = wVort.AddInt(vort_winsize,3,10)
vort_sigma_id      = wVort.AddFloat(vort_sigma,0.1,5)
vort_alpha_log_id  = wVort.AddFloat(vort_alpha_log,-1,10)
vort_TOL_log_id    = wVort.AddFloat(vort_TOL_log,-10,-3)
wVort.CreateWin

#--------------------------------------------------
# Parameters for optic_flow_zoom code
#
wOFzoom = ParamWin("Optic Flow PDE 2D parameters")

OFzoom_sigma_id    = wOFzoom.AddFloat(OFzoom_sigma,0.5,5)
OFzoom_T_id        = wOFzoom.AddFloat(OFzoom_T,1,1000)
OFzoom_nbiter_id   = wOFzoom.AddInt(OFzoom_nbiter,1,200)

OFzoom_dtype_id    = wOFzoom.AddInt(OFzoom_dtype,0,3)
OFzoom_alpha_id    = wOFzoom.AddFloat(OFzoom_alpha,0.01,5)
OFzoom_ht_id       = wOFzoom.AddFloat(OFzoom_ht,0.01,10)
OFzoom_quantile_id = wOFzoom.AddFloat(OFzoom_quantile,0.01,10)
OFzoom_zoom_id     = wOFzoom.AddInt(OFzoom_zoom,1,6)
wOFzoom.CreateWin

#--------------------------------------------------
# Parameters for continous Gaussian multiscale
#
wGaussSc = ParamWin("Continous Gaussian Scales")
sigma_min_id      = wGaussSc.AddFloat(sigma_min,0.01,5)
sigma_max_id      = wGaussSc.AddFloat(sigma_max,0.01,15)
sigma_N_id        = wGaussSc.AddInt(  sigma_N,  2,20)
wGaussSc.CreateWin

#--------------------------------------------------
# Main Parameters
#
w1 = ParamWin("Main")

input_id = w1.AddButton("Input Images", CB_InputImages)

amiOF_id  = w1.AddButton("Parameters for libami code",         CB_amiOF_param)
JavOF_id  = w1.AddButton("Parameters for Javier's code",       CB_JavOF_param)
JAOF_id   = w1.AddButton("Parameters for Javier and Agustin s code",       CB_JAOF_param)
GCPOF_id  = w1.AddButton("Gaussian Continuous Pyramid",        CB_GaussianScales_param)
ZoomOF_id = w1.AddButton("Parameters for optic_flow_zoom code",CB_OFzoom_param)
Vort_id   = w1.AddButton("Parameters for Vorticity code",      CB_Vort_param)

Jav_id              = w1.AddBoolean(use_Javier)
JavAgustin_id       = w1.AddBoolean(use_JavAgustin)
Zoom_id             = w1.AddBoolean(use_Zoom)
Vort_id             = w1.AddBoolean(use_Vorticity)
sym_id              = w1.AddBoolean(symmetric)
invup_id            = w1.AddInt(inverse_upsample,1,10)
temp_id             = w1.AddBoolean(temporal)
global_smoothing_id = w1.AddBoolean(global_smoothing)
use_splines_id      = w1.AddBoolean(use_splines)
Gaussian_scales_id  = w1.AddBoolean(Gaussian_scales)

w1.BeginBox("Controls")
w1.BeginHorizontal
restart_id=w1.AddButton("Restart", CB_Restart)
iterate_id=w1.AddButton("Iterate", CB_Iterate)

#w1.EndHorizontal
#w1.BeginHorizontal

display_id=w1.AddButton("Display", CB_Display)
stat_id   =w1.AddButton("Statistics", CB_Stats)
w1.EndHorizontal
alfatests_id = w1.AddButton("Alpha Test", CB_AlphaTests)
w1.EndBox


w1.CreateWin
w1.Display

#-------------------------------------------------
# Creating parameter window for test on alpha
#-------------------------------------------------
w2 = ParamWin("test sequence on alpha")
alfa_min_id     = w2.AddFloat(alfa_min,0.01,10)
alfa_max_id     = w2.AddFloat(alfa_max,0.01,20)
alfa_step_id    = w2.AddFloat(alfa_step,0.01,1)
alfa_start_id   = w2.AddButton("Run Alpha Test", CB_RunAlphaTests)
w2.CreateWin


#LoadImages()
images_loaded=0
