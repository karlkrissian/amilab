
func "Common/ScriptGui"

#!/usr/local/bin/amilab
if (!exists(RunExperimentsClass)){
  
  Class RunExperimentsClass : public ScriptGui{
  
    maindir = "CarotidBifurcationWorkshop2009/"
    func maindir+"ReadPoints.amil"
    func maindir+"CropImage.amil"
    func maindir+"CreateInitialSpheres.amil"
    # load the noise reduction script
    func maindir+"CreateProbabilityClass.amil"
    # load the vesselness script
    func "Centerlines/MultiLines/MultiLinesClass.amil"
    # load the shortest path script
    func "Centerlines/ShortestPath/ShortestPathClass.amil"
    # load the Level Sets Gui script
    func "Segmentation/LevelSets/LevelSetsClass.amil"
    func "SyntheticImages/AddSphere.amil"

    # load the current configuration
    func "carotidchallenge_config.amil"


    ReadPointsClass           ::ReadPoints
    CropImageFromPointsClass  ::CroppedInput
    CreateProbabilityClass    ::CP
    MultiLinesClass           ::ML
    ShortestPathClass         ::SP
    CreateInitialSpheresClass ::CIS
    LevelSetsClass            ::LS
    AddSphereClass            ::AS
    config                    ::CONFIG
    
    
    #------------------------------------------
    proc ::Init() \
    {
      ::config       = INT(0)
     
      ::nointeraction = UCHAR(0)
      ::advanced = UCHAR(0), "To use the advanced mode. Go to 'Adv' tab."

      ::datacenter     = INT(0), "Data Center: Erasmus MC, Hadassah and Louis Pradel"
      ::datanumber     = INT(0), "Dataset Number"
      ::datatype       = INT(0), "Three types of Datasets: Training, Testing or On-site"
      ::cropmarginXY   = INT(30), "Crop margin XY"
      ::cropmarginZtop = INT(40), "Crop margin Z top"
      ::cropmarginZbot = INT(25), "Crop margin Z bot"
      ::crop_created   = UCHAR(0)
      # using local stats for level set evolution? 0: true 1: false
      ::localstats	    = INT(1) 
      ::localpar       = INT(1)
      # Initial Spheres Radii in mm
      ::sphereradii    = 1
    
      ::ves_downsample  = UCHAR(0)
      ::mlmax_threshold = 20, "Multilines Max Threshold"

      ::dist_threshold = 1, "Distance Threshold"
      ::resample_dist  = 0.1, "Resample Distance"
      #--- evolution range in mm along Z coord for each carotid from the junction
      ::maxdistz_ECA = 20
      ::maxdistz_ICA = 50
      ::mindistz     = 20

      ::inverted_paths = 0

      ::minvesselint = INT(1150), "Vessel min intensity range"
      ::maxvesselint = INT(1600), "Vessel max intensity range"

      ::nD_plus = UCHAR(0), "Use 3D+scale processing of centerline paths"
      ::use_EXC = UCHAR(0), "Enable Excentricity"
      ::EXC_th  = 0.6,"Excentricity parameter"
      ::PSF_stddev  = 2,"Gaussian Point Spread Function standard deviation in voxels (supposed isotropic)"

      curdir = op_system.GetCurrentScriptDir()

      ::html_filename = curdir+"/Doc/carotidseg_challenge/index.html"

      ::showgroundtruth = UCHAR(0), "Display Ground Truth"
      ::showpoints = UCHAR(0), "Display Points"
      ::showpaths = UCHAR(0), "Display Paths"
      ::showjunction = UCHAR(0), "Display Junction"
      ::RenderActive=false
      ::input_object_render=""
      ::ActorsNumber="0", "The number of visible actors."
      ::color= wx.wxColour(255,165,50), "The surface image color."
    }

    #------------------------------------------
    proc ::SetDataCenter( NUM DataCenter) \
    {
      ::datacenter = DataCenter
      printn "SetDataCenter->::datacenter==%1%" % ::datacenter
    }

    #------------------------------------------
    proc ::SetDataNumber( NUM DataNumber) \
    {
      ::datanumber = DataNumber
      printn "SetDataNumber->::datanumber==%1%" % ::datanumber
    }

    #------------------------------------------
    proc ::SetDataType( NUM DataType) \
    {
      ::datatype = DataType
      printn "SetDataType->::datatype==%1%" % ::datatype
    }
        
    #------------------------------------------
    proc ::ReadData() \
    {
    
      SetStatusText("Reading data ...")
      # read input image
      ::datanumber_str = "%1%" % ::datacenter 
      ::datanumber_str = ::datanumber_str + "%02.0f" % ::datanumber
      ::current_datadir    = ::CONFIG->data_dir       +"/challenge"+ ::datanumber_str
      ::current_resultsdir = ::CONFIG->results_dir    +"/challenge"+ ::datanumber_str
      ::current_gtdir      = ::CONFIG->groundtruth_dir+"/challenge"+ ::datanumber_str

      MyDir=wx.wxFileName()
      MyDir.AssignDir(::current_resultsdir)
      if(MyDir.DirExists()) {
        printn "%1% directory exists" % ::current_resultsdir
      } else {
        MyDir.Mkdir()
        printn "Created the directory: %1%" % ::current_resultsdir
      }

      if (::datacenter==0) {
        ::cropmarginZtop = 5
        ::cropmarginZbot = 20
      } else {
        ::cropmarginZtop = 40
        ::cropmarginZbot = 20
      }

      # read data side
      f = File(::current_datadir+"/side"+::datanumber_str+".txt","r")
      s = ""
      f.read(&s)
    
      if (s=="left") {
        inputname = ::current_datadir + "/cta"+::datanumber_str+"l.mhd"
      }
      
      if (s=="right") {
        inputname = ::current_datadir + "/cta"+::datanumber_str+"r.mhd"
      }
      printn "inputname="+inputname
      ::input <<= itk->Read(inputname)
    
      # read input points
      pointsname = ::current_datadir + "/points"+::datanumber_str+".txt"
      ::ReadPoints->ReadPoints(pointsname)
      ::crop_created = 0
      ::CropData()
      //::win.Update(-1)
      SetStatusText("Reading data ... done")

    }
    
    
    #------------------------------------------
    proc ::ReadGT() \
    {
      print "::datatype="
      printn ::datatype
      // only for training data sets
      if (::datatype==0) {
        printn "1"
        # read GT image
        GTname = ::current_gtdir + "/pv"+::datanumber_str+".mhd"
        printn "Reading itk image "+GTname
        if (wx.wxFileName(GTname).FileExists()) {
          ::GT <<= itk->Read(GTname)
      
          # read the ROI information
          ROIname = ::current_gtdir + "/roi"+::datanumber_str+".txt"
          roi = File(ROIname,"r")
          minx = 0; roi.read(&minx)
          miny = 0; roi.read(&miny)
          minz = 0; roi.read(&minz)
      
          # set the ground truth translation ??? maybe not necessary ???
      
          # Read the Exterior image
          extname = ::current_gtdir + "/ext"+::datanumber_str+".mhd"
          ::ext <<= itk->Read(extname)
      
          # Read the GT Isosurface
          isoname = ::current_gtdir + "/iso"+::datanumber_str+".vtp"
          if (exists(::GTiso)) { del ::GTiso; }
          ::GTiso = Surface(isoname)
        } else  {
          if (!::nointeraction) {
            InfoDialog "Ground Truth not available";
          }
        }
      }
    }
    
    
    #------------------------------------------
    proc ::CropData() \
    {
      SetStatusText("Cropping data ...")
      if (!exists(::input)) { ::ReadData(); }
      ::CroppedInput->CropImageFromPoints(&::ReadPoints,\
                                  &::input,\
                                  ::cropmarginXY,\
                                  ::cropmarginZtop,\
                                  ::cropmarginZbot)
      ::crop_created = 1
      SetStatusText("Cropping data ... done")
      # save input information and free the initial image
      ::input_tx  = ::input.tx
      ::input_ty  = ::input.ty
      ::input_tz  = ::input.tz
      ::input_trx = ::input.trx
      ::input_try = ::input.try
      ::input_trz = ::input.trz
      # keep a reduced size input
      ::input_reduced <<= (USHORT) MeanHalfSize(::input)
      del ::input
    }
    
    #------------------------------------------
    proc ::LocalStats() \
    {
      ::CP->set_input(::CroppedInput->input_cropped)
      ::CP->lsd_erosion = 0
      ::CP->Apply()
      printn "Calculated the local statistics"
    }
    
    #-----------------------------------------
    proc ::Vesselness() \
    {
    
      if (!::ves_downsample) {
        # trunk max intensities to  ::maxvesselint
        vesselness_input = ::CroppedInput->input_cropped* (::CroppedInput->input_cropped<::maxvesselint)+\
                          (::CroppedInput->input_cropped>=::maxvesselint)*::maxvesselint
        mask = (UCHAR) ((::CroppedInput->input_cropped>::minvesselint)*\
                                     (::CroppedInput->input_cropped<::maxvesselint)*255)
      } else {
        # first downsample in X and Y
        vesselness_input = Resize(::CroppedInput->input_cropped, \
            ::CroppedInput->input_cropped.tx/2,::CroppedInput->input_cropped.ty/2,\
            ::CroppedInput->input_cropped.tz,1)
        mask = (UCHAR) ( (vesselness_input>::minvesselint)*\
                                      (vesselness_input<::maxvesselint)*255)
    
        vesselness_input = \
            vesselness_input*(vesselness_input<::maxvesselint)+\
            (vesselness_input>=::maxvesselint)*::maxvesselint
      }
      ::ML.set_input(vesselness_input)
      ::ML.set_mask(mask)
      ::ML.radmin  = 0.5
      ::ML.radmax  = 4
      ::ML.numrad  = 6
      ::ML.mode    = 1
      #::ML.use_SD  = 1
      ::ML.use_SD  = 0
      ::ML.SD_th   = 0.5
      #::ML.use_EXC = 1
      ::ML.use_EXC = ::use_EXC
      ::ML.EXC_th  = ::EXC_th
      # Keep the 80% highest values along the boundary
      ::ML.keephighest = 80
      # save multiscale local maxima
      ::ML.local_maxima = 1
      ::ML.keep_radii = 1
      #::ML.normalize_gradient=0
      ::ML.win.Update(-1)

      ::keep_all_scales = ::nD_plus
      ::ML.PSF_stddev = ::PSF_stddev
      ::ML.MultiLines_new()
    }

    #-----------------------------------------
    proc ::SaveVesselness() \
    {
      # 1. Save Level Set resulting image
      ::ML->result.save ::current_resultsdir+"/vesselness_result.ami.gz"
      ::ML->maxima.save ::current_resultsdir+"/vesselness_maxima.ami.gz"
      #if (exists(::ML.radii)) {
      ::ML->radii.save  ::current_resultsdir+"/vesselness_radii.ami.gz"
      #}
    }
    
    #-----------------------------------------
    proc ::ReadVesselness() \
    {
      vfilename  = ::current_resultsdir+"/vesselness_result.ami.gz"
    
      if (wx.wxFileName(vfilename).FileExists()) {
        # 1. Save Level Set resulting image
        ::ML->set_result(Image vfilename)
        # check dimensions
        if ((::ML->result.tx!=::CroppedInput->input_cropped.tx)|| \
            (::ML->result.ty!=::CroppedInput->input_cropped.ty)|| \
            (::ML->result.tz!=::CroppedInput->input_cropped.tz)) {
          result_bak = ::ML->result
          ::ML->result <<= Image(FLOAT,::input_tx,::input_ty,::input_tz)
          ::ML->result.settranslation(::input_trx,::input_try,::input_trz)
          ::ML->result.setvoxelsize(::CroppedInput->input_cropped)
          ::ML->result.putimage(result_bak)
          del result_bak
          ::ML->result <<= ::ML->result[::CroppedInput->input_cropped.GetExtent]
          message = "CarotidExperiments_ReadVesselness() \n File %1% wrong dimensions, image has been adapted " % vfilename 
          if (!::nointeraction) {
            InfoDialog message
          } else {
            printn message
          }
        }
      } else {
        if (!::nointeraction) {
          InfoDialog "CarotidExperiments_ReadVesselness() \n File %1% does not exists " % vfilename 
        }
      }

      vmfilename  = ::current_resultsdir+"/vesselness_maxima.ami.gz"
    
      if (wx.wxFileName(vmfilename).FileExists()) {
        # 1. Save Level Set resulting image
        ::ML.set_maxima( Image vmfilename)
        # check dimensions
        if ((::ML->maxima.tx!=::CroppedInput->input_cropped.tx)|| \
            (::ML->maxima.ty!=::CroppedInput->input_cropped.ty)|| \
            (::ML->maxima.tz!=::CroppedInput->input_cropped.tz)) {
          maxima_bak = ::ML.maxima
          ::ML.maxima <<= Image(FLOAT,::input_tx,::input_ty,::input_tz)
          ::ML->maxima.settranslation(::input_trx,::input_try,::input_trz)
          ::ML->maxima.setvoxelsize(::CroppedInput->input_cropped)
          ::ML->maxima.putimage(maxima_bak)
          del maxima_bak
          ::ML.maxima <<= ::ML.maxima[::CroppedInput->input_cropped.GetExtent]
          message = "CarotidExperiments_ReadVesselness() \n File %1% wrong dimensions, image has been adapted " % vmfilename 
          if (!::nointeraction) {
            InfoDialog message
          } else {
            printn message
          }
        }
      } else {
        if (!::nointeraction) {
          InfoDialog "CarotidExperiments_ReadVesselness() \n File %1% does not exists " % vmfilename 
        }
      }

      vmfilename  = ::current_resultsdir+"/vesselness_radii.ami.gz"

      if (wx.wxFileName(vmfilename).FileExists()) {
        ::ML.set_radii( Image vmfilename)
      } else {
        if (!::nointeraction) {
          InfoDialog "CarotidExperiments_ReadVesselness() \n File %1% does not exists " % vmfilename
        }
      }
    }
    
    #-----------------------------------------
    proc ::CreatePaths() \
    {
      SetStatusText("Creating paths ...")
      # load the shortest path script
      morph = filters.ContinuousMorphology()
      
      ::CIS->CheckInitialPoints(&::ReadPoints,::CroppedInput->input_cropped,::sphereradii)
      if (!::nointeraction) {
        if (!exists(::CIS->pt1_OK)) { InfoDialog "Discarded point 1"; }
        if (!exists(::CIS->pt2_OK)) { InfoDialog "Discarded point 2"; }
        if (!exists(::CIS->pt3_OK)) { InfoDialog "Discarded point 3"; }
      }
    
      if (exists(::ML->result)) {
        if (exists(::CP->prob)) {
          # ensure that CP_prob is maximum around local maxima
          
          if (::nD_plus) {
            #if (exists(::ML->maxima)) {
              ## threshold to get maxima positions
              #maxima_neigh = (::ML.maxima>::mlmax_threshold)
              ## dilate a little
              ##maxima_neigh = EDPdilate(maxima_neigh,1,0.25)
              #maxima_neigh = morph.Dilate(maxima_neigh,1,0.25)

              #::speed_lmax <<= (maxima_neigh>=0.95)*maxima_neigh * ::ML->result * 1.2
              #::speed_prob <<= ::CP->prob*::ML->result
              #::speed <<=  max(::speed_lmax, ::speed_prob)

            #} else {
              #::speed <<= ::CP->prob * ::ML->result
            #}
            ::speed <<= ::ML->all_responses
          } else {
            #if (exists(::ML->maxima)) {
              ## threshold to get maxima positions
              ##maxima_neigh = (::ML.maxima>::mlmax_threshold)
              ## dilate a little
              ##maxima_neigh = EDPdilate(maxima_neigh,1,0.25)
              ##maxima_neigh = morph.Dilate(maxima_neigh,1,0.25)

              ##::speed_lmax <<= (maxima_neigh>=0.95)*maxima_neigh * ::ML->result * 1.2


              ## only apply probability weight of big enough scales to avoid lowering intensities of small vessels
              #vsx = ::ML->result.vsx
              #vsy = ::ML->result.vsy
              #vsz = ::ML->result.vsz
              #vmax = max(vsx,max(vsy,vsz))
              #::speed <<= (::ML.radii>vmax*1.5)*(::CP->prob * ::ML->result)+((::ML.radii<vmax*1.5))*::ML->result
              #::speed_prob <<= ::CP->prob*::ML->result
              ##::speed <<=  max(::speed_lmax, ::speed_prob)

            #} else {
            # only apply probability weight of big enough scales to avoid lowering intensities of small vessels
            vsx = ::ML->result.vx
            vsy = ::ML->result.vy
            vsz = ::ML->result.vz
            vmax = max(vsx,max(vsy,vsz))*1.5
            ::speed <<= (::ML.radii>vmax*1.5)*(::CP->prob * ::ML->result)+((::ML.radii<vmax*1.5))*::ML->result
            #}
          }
        } else {
          if (!::nointeraction) {
            InfoDialog "prob not found, path based only on the Vesselness!"
          }
          ::speed <<= ::ML->result
        }
      } else {
        if (!::nointeraction) {
          InfoDialog "CarotidExperiments_Path1: no Vesselness image found" 
        }
        ::speed <<= ::CroppedInput->input_cropped
      }
    
      //::SP->init
      //::win.Update(-1)
    
      ::SP->epsilon         = 0.01
      ::SP->maxcost         = 10000
      ::SP->step_size       = 0.01
      ::SP->maxlength       = 300
      ::SP->use_input_speed = 1
      ::SP->input_Imin      = ::minvesselint
      ::SP->input_Imax      = ::maxvesselint
      ::SP->input_speed     = 1
      
      #::SP->load_input()
      ::SP->set_input(::CroppedInput->input_cropped)
      ::SP->set_speed(::speed)
      ::SP->end_mode        = 0 # no end mask
      #::SP->load_speed()
      #::win.Update(-1)
    
      ::SP->SetStartPointWorld(::ReadPoints->p1x,::ReadPoints->p1y,::ReadPoints->p1z)
      if (::nD_plus) {
        # Get the scale of the maximal value at the starting point
        rmax = 0
        smax = 0
        for n=0 to ::ML->all_responses.vdim-1 {
          rep = ::ML->all_responses(::SP.startx,::SP.starty,::SP.startz,n)
          if (rep>rmax) { rmax=rep; smax=n;}
        }
        ::SP->SetStartScale(smax)
      }
    
      if (exists(::CIS->pt2_OK)) \
      {
        SetStatusText(" Path from point 1 to point 2 ...")
        # path 1
        ::SP->SetEndPointWorld(::ReadPoints->p2x,::ReadPoints->p2y,::ReadPoints->p2z)

        if (::nD_plus) {
          # Get the scale of the maximal value at the starting point
          rmax = 0
          smax = 0
          for n=0 to ::ML->all_responses.vdim-1 {
            rep = ::ML->all_responses(::SP.endx,::SP.endy,::SP.endz,n)
            if (rep>rmax) { rmax=rep; smax=n;}
          }
          ::SP->SetEndScale(smax)
        }

        ::SP->Run()
        # path from Common to Internal Carotid Arteries
        if (exists(::pathCI)) { del ::pathCI; }
        ::pathCI = ::SP->path
        if (exists(::pathCIs)) { del ::pathCIs; }
        ::pathCIs = SmoothLines(::SP->path)
      }
    
      if (exists(::CIS->pt3_OK)) \
      {
        SetStatusText(" Path from point 1 to point 3 ...")
        # path 2
        ::SP->SetEndPointWorld(::ReadPoints->p3x,::ReadPoints->p3y,::ReadPoints->p3z)
        ::SP->Run
        # path from Common to External Carotid Arteries
        if (exists(::pathCE)) { del ::pathCE; }
        ::pathCE = ::SP->path
        if (exists(::pathCEs)) { del ::pathCEs; }
        ::pathCEs = SmoothLines(::SP->path)
      }
    
      SetStatusText("Creating paths ... done")
    }
    
    
    #-----------------------------------------
    proc ::SavePaths() \
    {
      # save the result to a file here ...
      if (exists(::pathCI)) {
        ::pathCI._save(::current_resultsdir+"/pathCI.vtk")
        ::pathCIs._save(::current_resultsdir+"/pathCIs.vtk")
      }
      if (exists(::pathCE)) {
        ::pathCE._save(::current_resultsdir+"/pathCE.vtk")
        ::pathCEs._save(::current_resultsdir+"/pathCEs.vtk")
      }      
      if (exists(::speed)) {
        ::speed.save ::current_resultsdir+"/speed.ami.gz"
      }
    }
    
    
    #-----------------------------------------
    proc ::ReadPaths() \
    {
      if (wx.wxFileName(::current_resultsdir+"/pathCIs.vtk").FileExists()) {
        if (exists(::pathCIs)) { del ::pathCIs; }
        ::pathCIs = Surface(::current_resultsdir+"/pathCIs.vtk")
      } else {
        if (!::nointeraction) {
          InfoDialog ::current_resultsdir+"/pathCIs.vtk not found!"
        }
      }
    
      if (wx.wxFileName(::current_resultsdir+"/pathCEs.vtk").FileExists()) {
        if (exists(::pathCEs)) { del ::pathCEs; }
        ::pathCEs = Surface(::current_resultsdir+"/pathCEs.vtk")
      } else {
        if (!::nointeraction) {
          InfoDialog ::current_resultsdir+"/pathCEs.vtk not found!"
        }
      }
      
      if (wx.wxFileName(::current_resultsdir+"/speed.ami.gz").FileExists()) {
        if (exists(::speed)) { del ::speed; }
        ::speed = Image ::current_resultsdir+"/speed.ami.gz"
      } else {
        if (!::nointeraction) {
          InfoDialog ::current_resultsdir+"/speed.ami.gz not found!"
        }
      }
      //::SP->init
    }
    
    
    #-----------------------------------------
    proc ::JunctionFromPaths() \
    {
      SetStatusText("Computing Junction from Paths")
      if (exists(::pathCIs)&&(exists(::pathCEs))) {
        lI = ResampleLines(::pathCIs,::resample_dist)
        lE = ResampleLines(::pathCEs,::resample_dist)
        lIp = lI.GetLine(0)
        lEp = lE.GetLine(0)
        minsize = lIp.tx<lEp.tx?lIp.tx:lEp.tx
        lIp1 = lIp[0:(minsize-1),0:0,0:0]
        lEp2 = lEp[0:(minsize-1),0:0,0:0]
        d = lIp1-lEp2
        dn = norm(d)
        dn = dn>::dist_threshold
        dn1 = autocrop(dn,0)
        lmean = (lIp1+lEp2)/2
        ::Jx = lmean(dn1.trx,0,0,0)
        ::Jy = lmean(dn1.trx,0,0,1)
        ::Jz = lmean(dn1.trx,0,0,2)
      
        # check for branch order
        yI = lIp(dn1.trx,0,0,1)
        yE = lEp(dn1.trx,0,0,1)
        if (yI<yE) {
          mes = "Path to point 3 is lower than path to point 2, setting External to 2"
          mes = mes + " yE=%1%" % yE
          mes = mes + " yI=%1%" % yI
          if (!::nointeraction) {
            InfoDialog mes
          } else {
            printn mes
          }
          ::inverted_paths = 1

          # swap paths
          tmp_path = ::pathCIs
          ::pathCIs <<= ::pathCEs
          ::pathCEs <<= tmp_path
          del tmp_path

          # swap path line information
          tmp_lp <<= lIp
          lIp    <<= lEp
          lEp    <<= tmp_lp

        } else {
          ::inverted_paths = 0
        }
   
        #--- Estimate remaining distance along Z axis to segment
        ::covered_distz_C = 0
        ::covered_distz_I = 0
        ::covered_distz_E = 0

        # both lines start at the same point ...
        minC_z = ::ReadPoints->p1z
        ::covered_distz_C = ::Jz-minC_z;

        maxI_z = max(lIp[2])
        if (maxI_z>::Jz) { ::covered_distz_I = maxI_z-::Jz; }
      
        maxE_z = max(lEp[2])
        if (maxE_z>::Jz) { ::covered_distz_E = maxE_z-::Jz; }
      
        ::CheckCCALength()
        ::CheckECALength()
        ::CheckICALength()
      # else if exist both paths
      } else {
        if (!::nointeraction) {
          InfoDialog "Did not found both paths for computing the junction"
        }
      }
      # end if exist both paths
      SetStatusText("Junction from Paths: done")
    }
    
    
    #-----------------------------------------
    # complement or cut the CCA path
    #
    proc ::CheckCCALength() \
    {
      SetStatusText("Checking CCA length")
      lI = ResampleLines(::pathCIs,::resample_dist)
      lIp <<= lI.GetLine(0)

      # check for remaining distance of CCA
      remaining_dist = ::mindistz-::covered_distz_C
      eval "printn ::nointeraction;"
      eval "printn remaining_dist;"
      if (remaining_dist>0) {
        if (!::nointeraction) {
          InfoDialog "Computing remaining path for CCA"
        }
        # compute the remaining path
        # 1. crop the speed image in Z from selected up to 
        #    the remaining distance
        maxz = lIp(0,0,0,2)
        minz = maxz-remaining_dist
        # convert to voxel coordinates
        minz = (minz-::speed.trz)/::speed.vz
        maxz = (maxz-::speed.trz)/::speed.vz
        # add a small margin
        minz = minz - 5
        maxz = maxz + 5
        # check for image limits
        if (minz<0) {
          if (!::nointeraction) {
            InfoDialog "CheckCCALength()\tCropped image too small, setting minz from %1% to 0" % minz
          }
          minz = 0;
        }
        if (maxz>::speed.tz-1) { 
          if (!::nointeraction) {
            InfoDialog "CheckCCALength()\tCropped image too small, limiting maxz (%1%)" % maxz
          }
          maxz = ::speed.tz-1; 
        }
        ::speed2 <<= ::speed[:,:,minz:maxz]

        # close and reload ShortestPath
        #if (exists(::SP->Close())) { ::SP->Close(); }

        # set the parameters and run
        ::input2 <<= ::CroppedInput->input_cropped[::speed2.GetExtent]

        # end mask contains the first voxels in Z axis
        ::endmask <<= ((FLOAT) Zpos(::speed2)<5)

        ::SP->epsilon         = 0.01
        ::SP->maxcost         = remaining_dist+5
        ::SP->step_size       = 0.01
        ::SP->maxlength       = remaining_dist+20
        ::SP->use_input_speed = 1
        ::SP->input_Imin      = ::minvesselint
        ::SP->input_Imax      = ::maxvesselint
        ::SP->input_speed     = 1
        ::SP->end_mode        = 1
        ::SP->set_input(::input2)
        ::SP->set_speed(::speed2)
        ::SP->set_endmask(::endmask)
        # ::win.Update(-1)
    
        ::SP->SetStartPointWorld(::ReadPoints->p1x,::ReadPoints->p1y,::ReadPoints->p1z)
        ::SP->Run()

        if (exists(::pathCC_rems)) { del ::pathCC_rems; }
        # path from Common to Internal Carotid Arteries
        ::pathCC_rems = SmoothLines(::SP->path)

        # update covered dist
        lC_rem_p = ::pathCC_rems.GetLine(0)
        minC_rem_z = min(lC_rem_p[2])
        if (minC_rem_z<::Jz) { 
          ::covered_distz_C = ::Jz-minC_rem_z; 
        }
      } else {
      # end if ::remaining_dist>0
        # here we don´t cut both path at the beginning
      }

      SetStatusText("CCA length: done")
    }
    # end proc CarotidExperiments_CheckCCALength()

    #-----------------------------------------
    # possibly cut the ECA path
    #
    proc ::CheckECALength() \
    {
      SetStatusText("Checking ECA length")
      lE = ResampleLines(::pathCEs,::resample_dist)
      lEp = lE.GetLine(0)

      # cut the ECA at junction -+ a given distance
      zmax = ::Jz+::maxdistz_ECA
      zmin = ::Jz-::mindistz
      needcut = ((max(lEp[2])>zmax)||(min(lEp[2])<zmin))

      if (needcut) {
        if (exists(::pathCEs_cut)) { del ::pathCEs_cut; }
        ::pathCEs_cut = Surface()
        ::pathCEs_cut.NewLine()
        i = 0
        _start=0
        _end=0
        for n=0 to lEp.tx-1 {
          posz = lEp(n,0,0,2)
          _start = _start||(posz>=zmin);
          if ((_start)&&(!_end)) {
            _end = posz>zmax
            if (!_end) {
              ::pathCEs_cut.AddPoint(lEp(n,0,0,0),lEp(n,0,0,1),posz)
              ::pathCEs_cut.LineAddPointNumber(i)
              i=i+1
            }
          }
        }
        ::pathCEs_cut.EndLine()
      }
      SetStatusText("ECA length: done")
    }
    # end proc CarotidExperiments_CheckECALength()


    #-----------------------------------------
    # complement or cut the ICA path
    #
    proc ::CheckICALength() \
    {
      SetStatusText("Checking ICA length")
      lI = ResampleLines(::pathCIs,::resample_dist)
      lIp = lI.GetLine(0)

      # check for remaining distance of ICA
      remaining_dist = ::maxdistz_ICA-::covered_distz_I
      if (remaining_dist>0) {
        if (!::nointeraction) {
          InfoDialog "Computing remaining path for ICA"
        }
        # compute the remaining path
        # 1. crop the speed image in Z from selected up to 
        #    the remaining distance
        minz = lIp(lIp.tx-1,0,0,2)
        maxz = minz+remaining_dist
        # convert to voxel coordinates
        minz = (minz-::speed.trz)/::speed.vz
        maxz = (maxz-::speed.trz)/::speed.vz
        # add a small margin
        minz = minz - 5
        maxz = maxz + 5
        # check for image limits
        if (minz<0) { 
          if (!::nointeraction) {
            InfoDialog "Cropped image too small, setting minz from %1% to 0" % minz
          }
          minz = 0;
        }
        if (maxz>::speed.tz-1) { 
          if (!::nointeraction) {
            InfoDialog "Cropped image too small, limiting maxz (%1%)" % maxz
          }
          maxz = ::speed.tz-1; 
        }
        ::speed2 <<= ::speed[:,:,minz:maxz]

        # avoid going into ECA 
          # reconstruct a tube around ICA of 3mm
          radii <<= Image(FLOAT,lI.NbPoints(),1,1)
          radii  = 3
          ica_tube <<= LineRecons(lI,::speed2,radii)

          # reconstruct a tube around ECA of 3mm
          if (exists(::pathCEs_cut)) {
            radii <<= Image(FLOAT,::pathCEs_cut.NbPoints(),1,1)
            radii  = 3
            eca_tube <<= LineRecons(::pathCEs_cut,::speed2,radii)
          } else {
            radii <<= Image(FLOAT,lI.NbPoints(),1,1)
            radii  = 3
            eca_tube <<= LineRecons(lI,::speed2,radii)
          }

          # set speed to 0 for point in eca tube but not in ica tube
          tube_contour=255*exp(-0.5)
          discard= (eca_tube<tube_contour)*(ica_tube>tube_contour)
          # keep non-discarded points
          ::speed2 = (discard<0.5)*::speed2

        # close and reload ShortestPath
        # if (exists(::SP->Close)) { ::SP->Close(); }
        
        # set the parameters and run
        ::input2 <<= ::CroppedInput->input_cropped[::speed2.GetExtent]

        # end mask contains the last voxels in Z axis
        ::endmask <<= ((FLOAT) Zpos(::speed2))>\
                                        (::speed2.tz-1-5)

        ::SP->epsilon         = 0.01
        ::SP->maxcost         = remaining_dist+5
        ::SP->step_size       = 0.01
        ::SP->maxlength       = 200
        ::SP->use_input_speed = 1
        ::SP->input_Imin      = ::minvesselint
        ::SP->input_Imax      = ::maxvesselint
        ::SP->input_speed     = 1
        ::SP->end_mode        = 1
        ::SP->set_input(::input2)
        ::SP->set_speed(::speed2)
        ::SP->set_endmask(::endmask)
        //::win.Update(-1)
    
        ::SP->SetStartPointWorld(lIp(lIp.tx-1,0,0,0),\
                                lIp(lIp.tx-1,0,0,1),\
                                lIp(lIp.tx-1,0,0,2))  
        ::SP->Run()

        if (exists(::pathCI_rems)) { del ::pathCI_rems; }
        # path from Common to Internal Carotid Arteries
        ::pathCI_rems = SmoothLines(::SP->path)

        # update covered dist
        lI_rem_p = ::pathCI_rems.GetLine(0)
        maxI_rem_z = max(lI_rem_p[2])
        if (maxI_rem_z>::Jz) { 
          ::covered_distz_I = maxI_rem_z-::Jz; 
        }
      }
      # end if ::remaining_dist>0

      # check for cutting the path
      zmax = ::Jz+::maxdistz_ICA
      zmin = ::Jz-::mindistz
      needcut = ((max(lIp[2])>zmax)||(min(lIp[2]<zmin)))

      if (needcut) {
        if (exists(::pathCIs_cut)) { del ::pathCIs_cut; }
        ::pathCIs_cut = Surface()
        ::pathCIs_cut.NewLine()
        i=0
        _start=0
        _end=0
        for n=0 to lIp.tx-1 {
          posz = lIp(n,0,0,2)
          _start = _start||(posz>=zmin);
          if ((_start)&&(!_end)) {
            _end = posz>zmax
            if (!_end) {
              ::pathCIs_cut.AddPoint(lIp(n,0,0,0),lIp(n,0,0,1),posz)
              ::pathCIs_cut.LineAddPointNumber(i)
              i=i+1
            }
          }
        }
        ::pathCIs_cut.EndLine()
      }

      SetStatusText("ICA length: done")
    }
    # end proc CarotidExperiments_CheckICALength()

    #-----------------------------------------
    proc ::SaveJunction() \
    {
      if (exists(::Jx)) {
        junc_file = File(::current_resultsdir + "/junction.txt","w")
    
        # problem to put comments in string !!!
        #junc_file._printn("# Information about the detected junction point:")
        junc_file._printn("")
        junc_file._printn("::inverted_paths = %1% " % ::inverted_paths)
        junc_file._printn("")
        junc_file._printn("::Jx = %1% " % ::Jx)
        junc_file._printn("::Jy = %1% " % ::Jy)
        junc_file._printn("::Jz = %1% " % ::Jz)
        junc_file._printn("")
        junc_file._printn("::covered_distz_C =  %1% " % ::covered_distz_C)
        junc_file._printn("::covered_distz_E =  %1% " % ::covered_distz_E)
        junc_file._printn("::covered_distz_I =  %1% " % ::covered_distz_I)
      }
      # save the paths here if they have been inverted
      ::SavePaths()
      if (exists(::pathCEs_cut)) {
        ::pathCEs_cut._save( ::current_resultsdir+"/pathCEs_cut.vtk")
      }
      if (exists(::pathCIs_cut)) {
        ::pathCIs_cut._save (::current_resultsdir+"/pathCIs_cut.vtk")
      }
      if (exists(::pathCC_rems)) {
        ::pathCC_rems._save (::current_resultsdir+"/pathCC_remaining_smoothed.vtk")
      }
      if (exists(::pathCI_rems)) {
        ::pathCI_rems._save (::current_resultsdir+"/pathCI_remaining_smoothed.vtk")
      }
    }

    #-----------------------------------------
    proc ::ReadJunction() \
    {
      Path_junc_file = ::current_resultsdir + "/junction.txt"
      func Path_junc_file

      ::ReadPaths()

       #printn "::inverted_paths = %1% " % ::inverted_paths
       #printn "::Jx = %1% " % ::Jx
       #printn "::Jy = %1% " % ::Jy
       #printn "::Jz = %1% " % ::Jz
       #printn "::covered_distz_C =  %1% " % ::covered_distz_C
       #printn "::covered_distz_E =  %1% " % ::covered_distz_E
       #printn "::covered_distz_I =  %1% " % ::covered_distz_I

      if (wx.wxFileName(::current_resultsdir+"/pathCEs_cut.vtk").FileExists()) {
        if (exists(::pathCEs_cut)) { del ::pathCEs_cut; }
        ::pathCEs_cut = Surface(::current_resultsdir+"/pathCEs_cut.vtk")
      }# else {
        #if (!::nointeraction) {
          #InfoDialog ::current_resultsdir+"/pathCEs_cut.vtk not found!"
        #}
      #}

      if (wx.wxFileName(::current_resultsdir+"/pathCIs_cut.vtk").FileExists()) {
        if (exists(::pathCIs_cut)) { del ::pathCIs_cut; }
        ::pathCIs_cut = Surface(::current_resultsdir+"/pathCIs_cut.vtk")
      } #else {
        #if (!::nointeraction) {
          #InfoDialog ::current_resultsdir+"/pathCIs_cut.vtk not found!"
        #}
      #}

      if (wx.wxFileName(::current_resultsdir+"/pathCC_remaining_smoothed.vtk").FileExists()) {
        if (exists(::pathCC_rems)) { del ::pathCC_rems; }
        ::pathCC_rems = Surface(::current_resultsdir+"/pathCC_remaining_smoothed.vtk")
      }# else {
        #if (!::nointeraction) {
          #InfoDialog ::current_resultsdir+"/pathCC_remaining_smoothed.vtk not found!"
        #}
      #}

      if (wx.wxFileName(::current_resultsdir+"/pathCI_remaining_smoothed.vtk").FileExists()) {
        if (exists(::pathCI_rems)) { del ::pathCI_rems; }
        ::pathCI_rems = Surface(::current_resultsdir+"/pathCI_remaining_smoothed.vtk")
      } #else {
        #if (!::nointeraction) {
          #InfoDialog ::current_resultsdir+"/pathCI_remaining_smoothed.vtk not found!"
        #}
      #}
    }

    #-----------------------------------------
    proc ::PathsDisplay() \
    {
      ::ReadGT()
    
      if (!exists(::Jx)) {
        if (!::nointeraction) {
          InfoDialog "Find the junction first!"
        }
      } else {
        ::junction_display_size    = 0.6
        if (exists(::junc_sphere)) { del ::junc_sphere; }
        ::junc_sphere = vtktools.vtkSphere(::junction_display_size,8,8,::Jx,::Jy,::Jz)
      
        # create empty surface for display
        if (exists(::surf)) { del ::surf; }
        ::surf = Surface()
        show ::surf

        if (exists(::pathCEs)) {::surf_draw += ::pathCEs; }
        if (exists(::pathCIs)) { ::surf_draw += ::pathCIs; }
        if (exists(::pathCC_rems)) {
          ::surf_draw += ::pathCC_rems
          ::pathCC_rems.SetColor(5,250,5)
        }
        if (exists(::pathCI_rems)) {
          ::surf_draw += ::pathCI_rems
          ::pathCI_rems.SetColor(5,250,5)
        }

        ::surf_draw += ::junc_sphere
        if (exists(::GTiso)) {
          ::surf_draw += ::GTiso
          ::GTiso.SetOpacity(0.5)
        }
        ::junc_sphere.SetDiffuse(5,250,5)
    
        if (exists(::ext)) {
          if (!exists(::ext_surf)) {
            ::ext_surf = isosurf(::ext,0.5)
          }
          ::surf_draw += ::ext_surf
          ::ext_surf.SetDiffuse(255,0,0)
          ::ext_surf.SetOpacity(0.5)
        }
        ::pathCEs.SetColor(255,0,0)
        ::pathCIs.SetColor(0,0,255)
        if (exists(::pathCEs_cut)) {
          ::surf_draw += ::pathCEs_cut
          ::pathCEs_cut.SetColor(255,0,0)
          ::pathCEs_cut.SetLineWidth(3)
        }
        if (exists(::pathCIs_cut)) {
          ::surf_draw += ::pathCIs_cut
          ::pathCIs_cut.SetColor(0,0,255)
          ::pathCIs_cut.SetLineWidth(3)
        }
        ::surf_draw.Normalize()
        ::surf_draw.Center()
      }
    
    }
    
    #------------------------------------------
    proc ::LevelSetsExternal() \
    {
      if (!exists(::pathCEs)) {
        if (!::nointeraction) {
          InfoDialog "no ECA path for levelset"
        }
      } else {
    
      #--- Sets the parameters
        ::tube_size     = 0.5
        # stop evolution at n*standard deviation
        ::ls_prob_limit = 2
      
        #--- Compute the initial cylindrical tube
        if (exists(::pathCEs_cut)) {
          radii         = Image(FLOAT,::pathCEs_cut.NbPoints(),1,1)
          radii         = ::tube_size
          ::pathCE_lsinit <<= LineRecons(::pathCEs_cut,::CroppedInput->input_cropped,radii)
          ::pathCE_lsinit = ::pathCE_lsinit-255*exp(-0.5)
        } else {
          ::pathCEs_res   = ResampleLines(::pathCEs,::resample_dist)
          radii         = Image(FLOAT,::pathCEs_res.NbPoints(),1,1)
          radii         = ::tube_size
          ::pathCE_lsinit <<= LineRecons(::pathCEs_res,::CroppedInput->input_cropped,radii)
          ::pathCE_lsinit = ::pathCE_lsinit-255*exp(-0.5)
        }
      
        #--- Initialize the level set evolution
        ::LS->set_input(&::CroppedInput->input_cropped)
        ::LS->init_mode              = 1 
        ::LS->accept_high_intensity  = 0
        ::LS->use_expansion_image    = 1
        ::LS->conv_freq              = 20
        ::LS->threads                = 4
        # estimate running time based on the remaining centerline distance to segment
        if (exists(::covered_distz_E)) {
          remaining_dist = ::maxdistz_ECA-::covered_distz_E
          remaining_Tmin = remaining_dist/::CroppedInput->input_cropped.vz
          ::LS->T           = max(60,remaining_Tmin*3);
        } else {
          ::LS->T = 60
        }
      
        ::LS.win.Update(-1)
        ::LS.set_initial(&::pathCE_lsinit)
        ::LS.win.Update(-1)

        #--- Computes the intensity statistics
        ::LS.ComputeIntensityStats()
        ::LS.win.Update(-1)
      
        #--- Compute the expansion force
        #     -- limit its range along Z axis based on the detected junction
        if (exists(::Jz)) {
          zmax = ::Jz+::maxdistz_ECA
          zmax = (zmax - ::LS->input.trz)/::LS->input.vz
          if (zmax>::LS->input.tz-1) { zmax=::LS->input.tz-1; }
          zmin = ::Jz-::mindistz
          zmin = (zmin - ::LS->input.trz)/::LS->input.vz
          if (zmin<0) { zmin=0;}
        } else {
          zmin = 0;
          zmax = ::LS->input.tz-1
        }
        ::pathCE_expforce = ::LS->input*0-0.5
        #     -- compute the force inside the ROI
        ::expforce_roi = ::pathCE_expforce[:,:,zmin:zmax]
        ::expforce_roi  = (::LS->input[::expforce_roi.GetExtent]-::LS->Imean)/::LS->Isd
        ::expforce_roi = ::expforce_roi*::expforce_roi
        ::expforce_roi = exp(-::expforce_roi/2)-exp(-(::ls_prob_limit*::ls_prob_limit)/2)
        ::pathCE_expforce.putimage(::expforce_roi)
      
        ::LS->set_expansion(&::pathCE_expforce)
      
        # Run the evolution
        ::LS.win.Update(-1)
        ::LS.ReRun()
        ::pathCE_contours <<= ::LS->inls

        # 1. Save Level Set resulting image
        ::LS->inls.save ::current_resultsdir+"/levelset_CC_CE.ami.gz"
        ::LS->SaveParams( ::current_resultsdir+"/levelset_CC_CE.amil" )
        SetStatusText("ECA levelset done...")
      }
    }
    
    
    #------------------------------------------
    proc ::LevelSetsInternal() \
    {
      if (!exists(::pathCIs)) {
        if (!::nointeraction) {
          InfoDialog "no ICA path for levelset"
        }
      } else {
            
        #--- Sets the parameters
        ::tube_size     = 0.5
        # stop evolution at n*standard deviation
        ::ls_prob_limit = 2
      
        #--- Compute the initial cylindrical tube
        if (exists(::pathCIs_cut)) {
          radii         = Image(FLOAT,::pathCIs_cut.NbPoints(),1,1)
          radii         = ::tube_size
          ::pathCI_lsinit <<= LineRecons(::pathCIs_cut,::CroppedInput->input_cropped,radii)
        } else {
          ::pathCIs_res   = ResampleLines(::pathCIs,::resample_dist)
          radii         = Image(FLOAT,::pathCIs_res.NbPoints(),1,1)
          radii         = ::tube_size
          ::pathCI_lsinit <<= LineRecons(::pathCIs_res,::CroppedInput->input_cropped,radii)
        }
    
        #--- check for computed remaining centerline
        if (exists(::pathCC_rems)) {
          ::pathCC_rems_res = ResampleLines(::pathCC_rems,::resample_dist)
          radii         <<= Image(FLOAT,::pathCC_rems_res.NbPoints(),1,1)
          radii           = ::tube_size
          # reconstructed remaining centerline
          rem_recons    <<= LineRecons(::pathCC_rems_res,::CroppedInput->input_cropped,radii)
          ::pathCI_lsinit = max(::pathCI_lsinit, rem_recons)
        }
        if (exists(::pathCI_rems)) {
          ::pathCI_rems_res = ResampleLines(::pathCI_rems,::resample_dist)
          radii         <<= Image(FLOAT,::pathCI_rems_res.NbPoints(),1,1)
          radii           = ::tube_size
          # reconstructed remaining centerline
          rem_recons    <<= LineRecons(::pathCI_rems_res,::CroppedInput->input_cropped,radii)
          ::pathCI_lsinit = max(::pathCI_lsinit, rem_recons)
        }
      
        ::pathCI_lsinit = ::pathCI_lsinit-255*exp(-0.5)
    
        #--- Initialize the level set evolution
        ::LS->set_input(&::CroppedInput->input_cropped)
        ::LS->init_mode              = 1 
        ::LS->accept_high_intensity  = 0
        ::LS->use_expansion_image    = 1
        ::LS->conv_freq              = 20
        ::LS->threads                = 4
        # estimate running time based on the remaining centerline distance to segment
        if (exists(::covered_distz_I)) {
          remaining_dist = ::maxdistz_ICA-::covered_distz_I
          remaining_Tmin = remaining_dist/::CroppedInput->input_cropped.vz
          ::LS->T           = max(60,remaining_Tmin*3);
          #eval "printn "+::LS->T+";"
        } else {
          ::LS->T = 60
        }

        //::win.Update(-1)
        ::LS->set_initial(&::pathCI_lsinit)
        //::win.Update(-1)
        #--- Computes the intensity statistics
        ::LS->ComputeIntensityStats()
        //::win.Update(-1)
      
        #--- Compute the expansion force
        #     -- limit its range along Z axis based on the detected junction
        if (exists(::Jz)) {
          zmax = ::Jz+::maxdistz_ICA
          zmax = (zmax - ::LS->input.trz)/::LS->input.vz
          if (zmax>::LS->input.tz-1) { zmax=::LS->input.tz-1; }
          zmin = ::Jz-::mindistz
          zmin = (zmin - ::LS->input.trz)/::LS->input.vz
          if (zmin<0) { zmin=0;}
        } else {
          zmin = 0
          zmax = ::LS->input.tz-1
        }
        ::pathCI_expforce = ::LS->input*0-0.5
        #     -- compute the force inside the ROI
        expforce_roi = ::pathCI_expforce[:,:,zmin:zmax]
        expforce_roi  = (::LS->input[expforce_roi.GetExtent]-::LS->Imean)/::LS->Isd
        expforce_roi = expforce_roi*expforce_roi
        expforce_roi = exp(-expforce_roi/2)-exp(-(::ls_prob_limit*::ls_prob_limit)/2)
        ::pathCI_expforce.putimage(expforce_roi)
      
        //::win.Update(-1)
        ::LS->set_expansion(&::pathCI_expforce)
      
        # Run the evolution
        //::win.Update(-1)
        ::LS->ReRun
        ::pathCI_contours <<= ::LS->inls

        # 1. Save Level Set resulting image
        ::LS->inls.save ::current_resultsdir+"/levelset_CC_CI.ami.gz"
        ::LS->SaveParams( ::current_resultsdir+"/levelset_CC_CI.amil" )
		SetStatusText("ICA levelset done...")
      }
    }
    
    
    #------------------------------------------
    proc ::LevelSetsPathsSave() \
    {
      # the LevelSets interface can be closed to free some memory
      ::LS->Close()

      if (exists(::pathCE_contours)&&exists(::pathCI_contours)) {
        # get the maximum between the 2 results and save it
        ::inls = max(::pathCE_contours,::pathCI_contours)
      } else {
        if exists(::pathCE_contours) {
          printn "****"
          ::inls = ::pathCE_contours
        } else {
          if exists(::pathCI_contours) {
            ::inls = ::pathCI_contours
          } else {
            if (!::nointeraction) {
              InfoDialog "No contour available"
            }
          }
        }
      }
    
      ::SaveResults()
    }
    
    
    #------------------------------------------
    proc ::InitialSpheres() \
    {
      #::LS->input_name   = "::CroppedInput->input_cropped"
      #--- add initial spheres
      printn "call to ::CIS->CreateInitialSpheres"
      ::lsinit <<= ::CIS->CreateInitialSpheres(&::ReadPoints,\
                                  &::CroppedInput->input_cropped,\
                                  "tmp_InitialSpheres",\
                                  (FLOAT)::sphereradii)
    }
    
    #------------------------------------------
    proc ::SaveResults() \
    {
      if (!exists(::inls)) {
        if (!::nointeraction) {
          InfoDialog "Need to run the segmentation first: loading level set  ..."
        }
      } else {
        # if segmentation comes from paths, save with diff names 
        if (exists(::pathCE_contours)) {
          ::inls.save ::current_resultsdir+"/levelset_result_from_paths.ami.gz"
        } else {
          # 1. Save Level Set resulting image
          ::inls.save ::current_resultsdir+"/levelset_result.ami.gz"
          ::LS->SaveParams( ::current_resultsdir+"/levelset_params.amil" )
        }
    
        # create the image with partial volume effect
        # check if we need to resize ::inls
        if (::inls.trx!=::input_trx)||(::inls.try!=::input_try)||(::inls.trz!=::input_trz) {
          #InfoDialog "The result should be rescaled to the original image scale ! (TODO)"
          #inls_rescaled = Resize(::inls,
        }
        pvim = filters.ComputePV_subdiv(::inls,4)
        if (0) {
          # put in bigger image
          pvim_big <<= Image(FLOAT,::input_tx,::input_ty,::input_tz)
          pvim_big.settranslation(::input_trx,::input_try,::input_trz)
          pvim_big.setvoxelsize(::CroppedInput->input_cropped)
          pvim_big.putimage(pvim)
        } else {
          pvim_big = pvim
        }
        del pvim
        itk->Write(&pvim_big,::current_resultsdir+"/pv"+::datanumber_str+".mhd")
    
        # 2. Save ROI text file
        roi_file = File(::current_resultsdir+"/roi"+::datanumber_str+".txt","w")
        # compute the voxel position of the first point
        ::ReadPoints->p1x=floor(((FLOAT)pvim_big.trx-::input_trx)/::CroppedInput->input_cropped.vx+0.5)
        ::ReadPoints->p1y=floor(((FLOAT)pvim_big.try-::input_try)/::CroppedInput->input_cropped.vy+0.5)
        ::ReadPoints->p1z=floor(((FLOAT)pvim_big.trz-::input_trz)/::CroppedInput->input_cropped.vz+0.5)
      
        ::ReadPoints->p2x=floor(::ReadPoints->p1x+((FLOAT)pvim_big.tx-1)*pvim_big.vx/::CroppedInput->input_cropped.vx+0.5)
        ::ReadPoints->p2y=floor(::ReadPoints->p1y+((FLOAT)pvim_big.ty-1)*pvim_big.vy/::CroppedInput->input_cropped.vy+0.5)
        ::ReadPoints->p2z=floor(::ReadPoints->p1z+((FLOAT)pvim_big.tz-1)*pvim_big.vz/::CroppedInput->input_cropped.vz+0.5)

        roi_file._print("%0.0f "  % ::ReadPoints->p1x)
        roi_file._print("%0.0f "  % ::ReadPoints->p1y)
        roi_file._print("%0.0f\n" % ::ReadPoints->p1z)
        roi_file._print("%0.0f "  % ::ReadPoints->p2x)
        roi_file._print("%0.0f "  % ::ReadPoints->p2y)
        roi_file._print("%0.0f\n" % ::ReadPoints->p2z)
        if (!::nointeraction) { InfoDialog "Result is saved!"; }
      }
    }
    
    
    #------------------------------------------
    proc ::Evaluation() \
    {
      ::cmd = ::CONFIG->evaluation_scriptdir+"/lumen.sh " \
            + ::CONFIG->groundtruth_dir + " " \
            + ::CONFIG->results_dir + " " \
            + ::CONFIG->results_dir + " " \
            + ::datanumber_str
      printn ::cmd
      sh ::cmd
    }
    
    
    #------------------------------------------
    proc ::DisplayResults() \
    {
      # read ground truth if needed
      if (!exists(::GTiso)) {
        ::ReadGT()
      }
      # read the mask image
      ext_name = ::current_gtdir + "/ext" + ::datanumber_str + ".mhd"
      ::ext = itk->Read(ext_name)
      # read the level set results
      #imname = ::current_resultsdir+"/levelset_result.ami.gz"
      imname = ::current_resultsdir+"/levelset_result_from_paths.ami.gz"
      printn " reading " + imname
      ::lsres <<= Image imname
    
      #imname = ::current_resultsdir+"/levelset_result_calc.ami.gz"
      #printn " reading " + imname
      #::lsres_calc <<= Image imname
    
      # Show: the LS, LS with calc, GT, initial spheres
      if (exists(::ls_surf)) { del ::ls_surf; }
      ::ls_surf = isosurf(::lsres,0)
      #if (exists(::lscalc_surf)) { del ::lscalc_surf; }
      #::lscalc_surf = isosurf(::lsres_calc,0)
      ::InitialSpheres()
      ::spheres_surf = isosurf(::lsinit,0)
    
      show ::ls_surf
      #::ls_surf_draw += ::lscalc_surf
      ::ls_surf_draw += ::GTiso
      ::ls_surf_draw += ::spheres_surf
      #::lscalc_surf.SetOpacity(0.4)
      ::GTiso.SetDiffuse(250,5,5)
      ::ls_surf.SetOpacity(0.6)
      ::spheres_surf.SetDiffuse(5,250,5)

      if (exists(::pathCEs)) { 
        ::ls_surf_draw += ::pathCEs; ::pathCEs.SetColor(255,0,0);
      }
      if (exists(::pathCIs)) { 
        ::ls_surf_draw += ::pathCIs; ::pathCIs.SetColor(0,0,255);
      }
      
      
    }
    
    #------------------------------------------
    proc ::DisplayLevel() \
    {
      resultl_name = ::current_resultsdir+"/levelset_result_from_paths.ami.gz"
      resultl = Image resultl_name
      ::resultl_iso = isosurf(resultl,0.01)
      show ::resultl_iso
    }
    
    #------------------------------------------
    proc ::ConfigEvent() {
      ::win.EnablePanel(::config_crop_page,     ::advanced==1)
      ::win.EnablePanel(::config_dir_page,      ::advanced==1)
      ::win.EnablePanel(::config_advanced_page, ::advanced==1)
      
    }

    #------------------------------------------
    proc ::CreateVtkActor( OBJECT poly) \
    {
      polynormals = vtk.vtkPolyDataNormals.New()
      polynormals.SetInput(&poly)
      polynormals.SetFeatureAngle(60.0)
      polymapper = vtk.vtkPolyDataMapper.New()
      polymapper.SetInputConnection(&polynormals.GetOutputPort())
      polymapper.ScalarVisibilityOff()
      polyactor = vtk.vtkActor.New()
      polyactor.SetMapper(&polymapper)
      return=&polyactor
    }
    Comments( ::CreateVtkActor, "Create a VTK actor.")

    #------------------------------------------
    proc ::DisplayThePoint(NUM Radius, NUM Theta, NUM Phi, \
                           NUM Xpoint, NUM Ypoint, NUM Zpoint, \
                           NUM redColorValue,   \
                           NUM greenColorValue, \
                           NUM blueColorValue) {
      ThePoint=vtktools.vtkSphere(Radius,Theta,Phi,Xpoint,Ypoint,Zpoint)
      ThePoint_polydata = vtktools.ToVtkPolyData(&ThePoint)
      ThePointActor = ::CreateVtkActor(&ThePoint_polydata)
      ThePointActor.GetProperty().SetColor(redColorValue,greenColorValue,blueColorValue)
      return=&ThePointActor
    }
    Comments( ::DisplayThePoint, "Create a point and actor.")

    #------------------------------------------
    proc ::DisplayThePath(OBJECT TheObject, \
                          NUM redColorValue,   \
                          NUM greenColorValue, \
                          NUM blueColorValue, \
                          NUM LineWidth) {
      ThePath_polydata = vtktools.ToVtkPolyData(&TheObject)
      ThePathActor = ::CreateVtkActor(&ThePath_polydata)
      ThePathActor.GetProperty().EdgeVisibilityOn()
      ThePathActor.GetProperty().SetEdgeColor(redColorValue,greenColorValue,blueColorValue)
      ThePathActor.GetProperty().SetColor(redColorValue,greenColorValue,blueColorValue)
      ThePathActor.GetProperty().SetLineWidth(LineWidth)
      return=&ThePathActor
    }
    Comments( ::DisplayThePath, "Create a path and actor.")

    #------------------------------------------
    proc ::DisplayGroundTruth() {
      if (!exists(::GT)) { ::ReadGT(); }
      if (!exists(::GT)) {
        InfoDialog "Not found Ground Truth."
      } else {
        if(!exists(::GroundTruthActor)) {
          threshold=0.5
          vol1_isosurf = isosurf(::GT,threshold)
          vol1_polydata = vtktools.ToVtkPolyData(&vol1_isosurf)
          ::GroundTruthActor = ::CreateVtkActor(&vol1_polydata)
          ::GroundTruthActor.GetProperty().SetOpacity(0.9)
          ::GroundTruthActor.GetProperty().SetColor(0,0,1)
          ::VolRen_obj.renderer.AddActor(&::GroundTruthActor)
          printn "Display Ground Truth"
        }
      }
    }
    Comments( ::DisplayGroundTruth, "Added the ground truth actor to the scene.")


    #------------------------------------------
    proc ::HideGroundTruth() {
      if(exists(::GroundTruthActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::GroundTruthActor)
        del ::GroundTruthActor
        printn "Removed ground truth actor"
      }
    }
    Comments( ::HideGroundTruth, "Removed the ground truth actor from the scene.")

    #------------------------------------------
    proc ::DisplayPoints() {
      if(exists(::ReadPoints)) {
        if(!exists(::FirstpointActor)) {
          ::FirstpointActor = ::DisplayThePoint(1,10,10, \
                                                ::ReadPoints.p1x,::ReadPoints.p1y,::ReadPoints.p1z, \
                                                0,0,1)
          ::VolRen_obj.renderer.AddActor(&::FirstpointActor)
          printn "Display the first point"
        }

        if(!exists(::SecondpointActor)) {
          ::SecondpointActor = ::DisplayThePoint(1,10,10, \
                                                 ::ReadPoints.p2x,::ReadPoints.p2y,::ReadPoints.p2z, \
                                                 0,0,1)
          ::VolRen_obj.renderer.AddActor(&::SecondpointActor)
          printn "Display the second point"
        }

        if(!exists(::ThirdpointActor)) {
          ::ThirdpointActor = ::DisplayThePoint(1,10,10, \
                                                ::ReadPoints.p3x,::ReadPoints.p3y,::ReadPoints.p3z, \
                                                0,0,1)
          ::VolRen_obj.renderer.AddActor(&::ThirdpointActor)
          printn "Display the third point"
        }
      } else {
        InfoDialog "The points have not been read."
      }
    }
    Comments( ::DisplayPoints, "Added the three point to the scene.")

    #------------------------------------------
    proc ::HidePoints() {
      if(exists(::FirstpointActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::FirstpointActor)
        del ::FirstpointActor
        printn "Removed first point actor"
      }
      if(exists(::SecondpointActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::SecondpointActor)
        del ::SecondpointActor
        printn "Removed second point actor"
      }
      if(exists(::ThirdpointActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::ThirdpointActor)
        del ::ThirdpointActor
        printn "Removed third point actor"
      }
    }
    Comments( ::HidePoints, "Removed the three point from the scene.")

    #------------------------------------------
    proc ::DisplaySurfaceImage() {
      if (exists(::TheSurfaceActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::TheSurfaceActor)
        del ::TheSurfaceActor
        printn "Removed surface image actor"
      }
      if(::input_object_render != "Select surface image...") {
        eval "TheSurface = &"+::input_object_render+";"
        TheSurface_polydata = vtktools.ToVtkPolyData(&TheSurface)
        ::TheSurfaceActor = ::CreateVtkActor(&TheSurface_polydata)
        ::TheSurfaceActor.GetProperty().SetOpacity(0.9)
        ::TheSurfaceActor.GetProperty().EdgeVisibilityOn()
        ::TheSurfaceActor.GetProperty().SetEdgeColor((FLOAT)::color.Red()/255,(FLOAT)::color.Green()/255,(FLOAT)::color.Blue()/255)
        ::TheSurfaceActor.GetProperty().SetColor((FLOAT)::color.Red()/255,(FLOAT)::color.Green()/255,(FLOAT)::color.Blue()/255)
        ::TheSurfaceActor.GetProperty().SetLineWidth(3)
        ::VolRen_obj.renderer.AddActor(&::TheSurfaceActor)
        printn "Display surface image: %1%" % ::input_object_render
      }
    }
    Comments( ::DisplaySurfaceImage, "Added the surface image actor to the scene.")

    #------------------------------------------
    proc ::DisplayPaths() {
      if (exists(::pathCIs) && (!exists(::PathCIsActor))) {
        ::PathCIsActor = ::DisplayThePath(&::pathCIs,0,0,1,3)
        ::VolRen_obj.renderer.AddActor(&::PathCIsActor)
        printn "Display Path(pathCIs)"
      }

      if (exists(::pathCEs) &&(!exists(::PathCEsActor))) {
        ::PathCEsActor = ::DisplayThePath(&::pathCEs,1,0,0,3)
        ::VolRen_obj.renderer.AddActor(&::PathCEsActor)
        printn "Display Path(pathCEs)"
      }

      if ((!exists(::pathCIs)) || (!exists(::pathCEs))) {
        InfoDialog "All the paths have not been calculated."
      }
    }
    Comments( ::DisplayPaths, "Added the paths actor to the scene.")

    #------------------------------------------
    proc ::HidePaths() {
      if(exists(::PathCIsActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::PathCIsActor)
        del ::PathCIsActor
        printn "Removed pathCIs actor"
      }
      if(exists(::PathCEsActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::PathCEsActor)
        del ::PathCEsActor
        printn "Removed pathCEs actor"
      }
    }
    Comments( ::HidePaths, "Removed the paths actor from the scene.")
    
    #------------------------------------------
    proc ::DisplayJunction() {
      if (!exists(::Jx)) {
        InfoDialog "Find the junction first!"
      } else {
        if (!exists(::Junc_sphereActor)) {
          ::Junc_sphereActor = ::DisplayThePoint(1,8,8, \
                                                 ::Jx,::Jy,::Jz, \
                                                 0,1,0)
          ::VolRen_obj.renderer.AddActor(&::Junc_sphereActor)
          printn "Display Junction"
        }

        ::DisplayPaths()

        if (exists(::pathCEs_cut) && (!exists(::PathCEs_cutActor))) {
          ::PathCEs_cutActor = ::DisplayThePath(&::pathCEs_cut,1,0,0,3)
          ::VolRen_obj.renderer.AddActor(&::PathCEs_cutActor)
          printn "Display pathCEs_cut"
        }

        if (exists(::pathCIs_cut) && (!exists(::PathCIs_cutActor))) {
          ::PathCIs_cutActor = ::DisplayThePath(&::pathCIs_cut,0,0,1,3)
          ::VolRen_obj.renderer.AddActor(&::PathCIs_cutActor)
          printn "Display pathCIs_cut"
        }

        if (exists(::pathCC_rems) && (!exists(::PathCC_remsActor))) {
          ::PathCC_remsActor = ::DisplayThePath(&::pathCC_rems,0,1,0,3)
          ::VolRen_obj.renderer.AddActor(&::PathCC_remsActor)
          printn "Display pathCC_rems"
        }

        if (exists(::pathCI_rems) && (!exists(::PathCI_remsActor))) {
          ::PathCI_remsActor = ::DisplayThePath(&::pathCI_rems,0,1,0,3)
          ::VolRen_obj.renderer.AddActor(&::PathCI_remsActor)
          printn "Display pathCI_rems"
        }

        if (exists(::GTiso) && (!exists(::GTisoActor))) {
          GTiso_polydata = vtktools.ToVtkPolyData(&::GTiso)
          ::GTisoActor = ::CreateVtkActor(&GTiso_polydata)
          ::GTisoActor.GetProperty().SetOpacity(0.6)
          ::GTisoActor.GetProperty().SetColor(1,1,1)
          ::VolRen_obj.renderer.AddActor(&::GTisoActor)
          printn "Display GTiso"
        }
        if (exists(::ext_surf) && (!exists(::Ext_surfActor))) {
          ext_surf_polydata = vtktools.ToVtkPolyData(&::ext_surf)
          ::Ext_surfActor = ::CreateVtkActor(&ext_surf_polydata)
          ::Ext_surfActor.GetProperty().SetOpacity(0.8)
          ::Ext_surfActor.GetProperty().SetColor(1,0,0)
          ::VolRen_obj.renderer.AddActor(&::Ext_surfActor)
          printn "Display Ext_surf"
        }
      }
    }
    Comments( ::DisplayJunction, "Added the junction to the scene.")

    #------------------------------------------
    proc ::HideJunction() {
      if(exists(::Junc_sphereActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::Junc_sphereActor)
        del ::Junc_sphereActor
        printn "Removed Junction sphere actor"
      }
      if(exists(::PathCEs_cutActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::PathCEs_cutActor)
        del ::PathCEs_cutActor
        printn "Removed pathCEs_cut actor"
      }
      if(exists(::PathCIs_cutActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::PathCIs_cutActor)
        del ::PathCIs_cutActor
        printn "Removed pathCIs_cut actor"
      }
      if(exists(::PathCC_remsActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::PathCC_remsActor)
        del ::PathCC_remsActor
        printn "Removed pathCC_rems actor"
      }
      if(exists(::PathCI_remsActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::PathCI_remsActor)
        del ::PathCI_remsActor
        printn "Removed pathCI_rems actor"
      }
      if(exists(::GTisoActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::GTisoActor)
        del ::GTisoActor
        printn "Removed GTiso actor"
      }
      if(exists(::Ext_surfActor)) {
        ::VolRen_obj.renderer.RemoveActor(&::Ext_surfActor)
        del ::Ext_surfActor
        printn "Removed Ext_surf actor"
      }
    }
    Comments( ::HideJunction, "Removed the junction from the scene.")

    #------------------------------------------
    proc ::Render() {

      if(!::RenderActive){
        if (!exists(::input_reduced)) { ::ReadData(); }

        if (!exists(::VolRen_obj)) {
          func "Visualization/VolRen/VolRenClass"
          VolRenClass ::VolRen_obj
          ::VolRen_obj.Gui()
        }

        ::VolRen_obj.set_input(::input_reduced)
        ::VolRen_obj.vtkvol1.opacity_attenuation=0.25
        InfoDialog "Force get OpenGL current context"
        ::VolRen_obj.StartNew()
        ::RenderActive=true
      }

      if(::showgroundtruth) {
        ::DisplayGroundTruth()
      } else {
        ::HideGroundTruth()
      }

      if(::showpoints) {
        ::DisplayPoints()
      } else {
        ::HidePoints()
      }

      ::DisplaySurfaceImage()

      if(::showpaths) {
        ::DisplayPaths()
      } else {
        ::HidePaths()
      }

      if(::showjunction) {
        ::DisplayJunction()
      } else {
        ::HideJunction()
      }

      ::VolRen_obj.renderer.ResetCameraClippingRange()
      ::VolRen_obj.SetRendererBg()
      ::VolRen_obj.renderer.ResetCamera()
      ::VolRen_obj.BackupView()
      ::VolRen_obj.renderer.Render()

      ::VolRen_obj.renwin.Render()
      ::VolRen_obj.renwin_interact.Render()

      ::ActorsNumber = "%1%" % ::VolRen_obj.renderer.VisibleActorCount()
      ::win.SetLabelValue(::input_actors_number,::ActorsNumber)
      ::win.Update(-1)
    }
    Comments( ::Render, "Render the carotid scene.")

    #----------------------------
    # Redefinition of Close to close the VolRen_obj
    #
    proc ::Close() {
      if (exists(::VolRen_obj)) {
        ::VolRen_obj.Close()
      }
      ::win.HidePanel()
      delvars GetObjectName(::Close)
    }
    Comments( ::Close, "Will close the interface and delete the corresponding object named '"+GetObjectName(::Close)+"'.")

    #------------------------------------------
    proc ::Gui() \
    {
      ::win = ParamPanel("Carotid09")
      ::win.BeginBook()
    
        #----- Input Page
        ::win.AddPage("IO")
          ::win.BeginBoxPanel("data information")
          ::win.AddBoolean( &::advanced,"Advanced Mode")
          ::win.SetCallback(&::ConfigEvent)
            datacenter_id = ::win.AddEnum( &::datacenter,"Datacenter")
              ::win.AddEnumChoice(datacenter_id,"Erasmus MC")
              ::win.AddEnumChoice(datacenter_id,"Hadassah")
              ::win.AddEnumChoice(datacenter_id,"Louis Pradel")
            datatype_id = ::win.AddEnum( &::datatype,"Datatype")
              ::win.AddEnumChoice(datatype_id,"Training")
              ::win.AddEnumChoice(datatype_id,"Testing")
              ::win.AddEnumChoice(datatype_id,"On-site")
            ::win.AddInt( &::datanumber,  "Data Number", 0,35)
          ::win.EndBoxPanel
          ::win.BeginHorizontal
            ::win.AddButton("Read Data",         ::ReadData)
            ::win.AddButton("Read Ground Truth", ::ReadGT)
          ::win.EndHorizontal
          
          ::config_book = ::win.BeginBook()
            ::config_crop_page = ::win.AddPage("Crop")
              ::win.AddInt( &::cropmarginXY,  "cropXY", 0,200)
              ::win.AddInt( &::cropmarginZtop,  "cropZtop", 0,200)
              ::win.AddInt( &::cropmarginZbot,  "cropZbot", 0,200)
              ::win.AddButton("Crop Data",         ::CropData)
              ::win.AddBoolean( &::crop_created)
              
            ::config_dir_page = ::win.AddPage("Dir")  
              ::win.AddBoolean( &::nointeraction)
              ::win.BeginBoxPanel("Data paths")
                ::win.AddDirname( &::CONFIG.data_dir,"Data ")
                ::win.AddDirname( &::CONFIG.groundtruth_dir,"GT ")
                ::win.AddDirname( &::CONFIG.results_dir,"Results ")
              ::win.EndBoxPanel
    
              ::win.BeginBoxPanel("Evaluation paths")
                ::win.AddDirname( &::CONFIG.evaluation_bindir,    "Binary ")
                ::win.AddDirname( &::CONFIG.evaluation_scriptdir, "Scripts ")
              ::win.EndBoxPanel              
          ::win.EndBook()
    
        ::win.AddPage("Speed")
          ::win.BeginBoxPanel("LocalStats")
            ::win.AddButton("Apply",::LocalStats)
          ::win.EndBoxPanel
                      
          ::win.BeginBoxPanel("Vesselness")
            ::win.AddBoolean( &::ves_downsample)
            ::win.AddBoolean(&::nD_plus,"4D vesselness response")
            ::win.AddBoolean(&::use_EXC,"Enable Excentricity")
            ::win.AddFloat(  &::EXC_th,"Excentricity parameter")
            ::win.AddFloat(  &::PSF_stddev,"PSF")
            ::win.AddButton("Vesselness",     ::Vesselness)
            ::win.AddButton("Save",     ::SaveVesselness)
            ::win.AddButton("Read",     ::ReadVesselness)
          ::win.EndBoxPanel
                 
    
        #----- Run Page
        ::win.AddPage("Run")
          ::win.BeginBoxPanel("Vessel intensity range")
            ::win.AddInt( &::minvesselint,  "Min", 900,1300)
            ::win.AddInt( &::maxvesselint,  "Max", 900,2000)
          ::win.EndBoxPanel
          ::win.BeginBoxPanel("Paths (Vesselness+Prob)")
            ::win.BeginBoxPanel("Path")
              ::win.AddFloat( &::mlmax_threshold,  "Threshold", 0,100)
              ::win.BeginHorizontal
                ::win.AddButton("Create",  ::CreatePaths)
                ::win.AddButton("Save",    ::SavePaths)
                ::win.AddButton("Read",    ::ReadPaths)
              ::win.EndHorizontal
            ::win.EndBoxPanel
            ::win.BeginBoxPanel("Junction")
              ::win.AddFloat( &::dist_threshold,  "Threshold", 0.01,10)
              ::win.AddFloat( &::resample_dist,  "Resample", 0.01,10)
              ::win.BeginHorizontal
                ::win.AddButton("Junction",  ::JunctionFromPaths)
               ::win.AddButton("Display",    ::PathsDisplay)
                ::win.AddButton("Save",      ::SaveJunction)
                ::win.AddButton("Read",      ::ReadJunction)
              ::win.EndHorizontal
            ::win.EndBoxPanel
            ::win.BeginBoxPanel("LevelSets from paths")
              ::win.BeginHorizontal
                ::win.AddButton("External", ::LevelSetsExternal)
                ::win.AddButton("Internal", ::LevelSetsInternal)
                ::win.AddButton("Save",     ::LevelSetsPathsSave)
                ::win.AddButton("Display",  ::DisplayLevel)
              ::win.EndHorizontal
            ::win.EndBoxPanel
          ::win.EndBoxPanel
          ::win.BeginHorizontal
            ::win.AddButton("Evaluation",      ::Evaluation)
            ::win.AddButton("Display Results", ::DisplayResults)
          ::win.EndHorizontal

        ::config_advanced_page = ::win.AddPage("Adv")
          ::win.BeginBook()
          
            ::CP.SetParentPanel(&::win)
            ::CP.Gui()
            ::win.AddPage("Local Stats",&::CP->win)
           
            ::ML.SetParentPanel(&::win)
            ::ML.Gui()
            ::win.AddPage("Vesselness",&::ML->win)
            
            ::LS.SetParentPanel(&::win)
            ::LS.Gui()
            ::win.AddPage("LevelSets",&::LS->win)
            
          ::win.EndBook()

        #----- Visualization
        ::win.AddPage("Display")
          ::win.BeginBoxPanel("Options")
              ::win.AddBoolean( &::showgroundtruth,"Display Ground Truth")
              ::win.AddBoolean( &::showpoints,"Display Points")
              ::win.AddBoolean( &::showpaths,"Display Paths")
              ::win.AddBoolean( &::showjunction,"Display Junction")
          ::win.EndBoxPanel
          ::win.BeginBoxPanel("Surface")
              ::win.AddAMIObjectChoice( &::input_object_render, "")
              ::win.AddColor("Color",&::color)
          ::win.EndBoxPanel
          ::win.BeginBoxPanel("Visible actors")
            ::input_actors_number=::win.AddLabel( "Number: ", &::ActorsNumber)
          ::win.EndBoxPanel
          ::win.AddButton("Render",      ::Render)
          
        ::AddHelpPage(&::win)

      ::win.EndBook()
      
      ::AddStandardButtons(&::win)

      ::win.Update(-1)
      ::win.Display()
      
      ::ConfigEvent()
    }
    ::Init()
  }
  #------------------------------------------

#  if (!exists(experiments)) \
#  {
#    RunExperimentsClass experiments
#    experiments->Init()
#    experiments->Gui()
#  }
}
