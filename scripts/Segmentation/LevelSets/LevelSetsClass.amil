# command line: improcess

#SetDebugOn

func "Common/ScriptGui"

if (!exists(LevelSetsClass)) {

  #=============================================================================
  Class LevelSetsClass : public ScriptGui \
  {
    #---------------------------------------------------------------------------
    
    func "SyntheticImages/AddSphere.amil"
    AddSphereClass ::AS
      

    # LevelSets Parameters
    func "Variable/ObjectIO"
    # 
    #===========================================================================
    Class ::ParamClass : public ObjectIO {

        ::description = "Default parameters", \
                        "Description of the set of parameters"

        # 0: for spheres 1: for initial image
        ::init_mode         = INT(0),  "Contour initialization mode: spheres "+\
                                  "or zero-crossing of an image"
        ::minimal_intensity = 0,  "Minimal Intensity for the input image"
        
        # initial image threshold
        ::initial_image_threshold = 0, "Threshold for initial level set"

        # using world coordinates

        # Expansion parameters
        ::use_expansion       = UCHAR(1), "Use Expansion Force"
        ::use_expansion_image = UCHAR(0), "Set expansion force from an image"
        ::expansion_image_name = "Image"
        # probability threshold belong which expansion becomes negative
        ::prob_threshold = 0.3, "Expansion force parameter to create negative"+\
                                " forces (shrinking force) when the intensity"+\
                                " is too distant from the expected intensity"+\
                                "based on its mean and standard deviation"
        ::Imean = 70, "Estimated mean intensity of the structure to segment"
        ::Isd = 50,   "Estimated intensity standard deviation of the "+\
                      "structure to segment"
        ::accept_high_intensity = UCHAR(0) ,"If set to true, will allow the "+\
            "maximal expansion force for any intensity higher the given mean "+\
            "intensity"
        ::expansioncoeff  = 0.5, "Expansion weight in the evolution equation"

        # Advection parameters// 
        ::use_advection       = UCHAR(1), "Use Advection Force"
        ::advcoeff  = 0.5,   "Advection weight in the PDE"

        # Smoothing parameters
        ::use_smoothing       = UCHAR(1), "Use Smoothing Force"
        ::curvcoeff = 0.5,   "Smoothing weight in the PDE"
        ::smoothingtype = INT(0),\
                              "Smoothing mode: either mean curvature or minimal curvature"
        ::affinecurv    = UCHAR(0),\
                              "Experimental: use of affine curvature "+\
                              "(0: 2D affine curvature 1: 2D mean curvature)"

        # Geodesic framework
        ::use_geodesic = UCHAR(0), "Use the geodesic framework if the weight "+\
                                    "image is available."
        ::geoweights_sigma = 2, "Gaussian standard deviation use to compute "+\
                                "the local variance from the input image "+\
                                "in the geodesic framework"
        ::geoweights_minimum = 0.3, "minimal value of geodesic weights"

        # Velocity parameters
        ::use_velocity        = UCHAR(0), "Use Velocity Force"
        ::velcoeff  = 0.0

        # Global equation parameters
        ::dt = 0.5, "Evolution time-step"
        ::T  =200,  "Total Evolution time"

        ::check_convergence = UCHAR(1)
        ::conv_freq         = INT(20)

        # Narrow Band parameters
        ::NBD_method     = INT(2), "Narrow Band Distance computation method, "+\
            "if not for experimental purpose, you should keep the default "+\
            "value: fast chamfer (0:liana s, 1: fast marching 2: fast chamfer)"
        ::NBD_freq       = INT(6)
        ::DTmin = -50
        ::DTmax = 50

        #-----------------------------------------------------------------------
        proc ::__assign__( VAR p) {
          ::init_mode             = p.init_mode
          ::minimal_intensity     = p.minimal_intensity
          ::initial_image_threshold = p.initial_image_threshold

          ::use_expansion         = p.use_expansion
          ::use_expansion_image   = p.use_expansion_image
          ::expansion_image_name  = p.expansion_image_name
          ::prob_threshold        = p.prob_threshold
          ::Imean                 = p.Imean
          ::Isd                   = p.Isd
          ::accept_high_intensity = p.accept_high_intensity
          ::expansion_coeff       = p.expansion_coeff

          ::use_advection         = p.use_advection
          ::advcoeff              = p.advcoeff

          ::use_smoothing         = p.use_smoothing
          ::curvcoeff             = p.curvcoeff
          ::smoothingtype         = p.smoothingtype
          ::affinecurv            = p.affinecurv

          ::use_geodesic          = p.use_geodesic

          ::use_velocity          = p.use_velocity
          ::velcoeff              = p.velcoeff

          ::T                     = p.T
          ::dt                    = p.dt

          ::NBD_method            = p.NBD_method
          ::NBD_freq              = p.NBD_freq
          ::check_convergence     = p.check_convergence
          ::conv_freq             = p.conv_freq

          ::DTmin                 = p.DTmin
          ::DTmax                 = p.DTmax
        }
    }

    #---------------------------------------------------------------------------
    proc ::Init() {

        ::input_name   = "","Name of the input image variable"
        ::initial_name = "","Name of the initial level set image variable"
        ::geodesicimage_name = "", "Name of the input geodesic weight image"

        ::inputmin = 0
        ::inputmax = 32000

        ::ParamClass ::params

        ::sphere_radius = 3,  "Radius in current unit (usually in mm) of the "+\
                              "sphere to add"

        ::stop = 0,          "Test if the stop button has been pressed"
        # number of threads (not used right now)
        ::threads = INT(wx.wxThread.GetCPUCount()), \
              "Number of threads used during the evolution "+\
              "(the re-distancing of the narrow band is not multi-threaded)"


        ::downsamplefactor = INT(1)
        Comments( ::downsamplefactor, "Down-sampling factor, unused for the moment")

        #::in_draw.SetIsoContour(0,::inls0,0)
        #::in_draw.DrawIsoContour(0,1)

        ::result_filename = "LevelSetResult"
        ::result_filename_ext = ".ami.gz"
        ::resname_addtime = UCHAR(1)
        ::resname_addprob = UCHAR(1)

        ::wiki_help = "http://www.ctm.ulpgc.es/amilab_dokuwiki/dokuwiki/doku.php?id=tutorial-mainalgorithms-levelset#level_set_segmentation"

        ::html_filename = GetScriptsDir+"/Segmentation/LevelSets/Doc/levelset_gui/index.html"

        ::own_viewer = UCHAR(1), "if using own image viewer"
        ::isocontour_index = 1, "isocontour number to show the evolving level set"
    }


    #---------------------------------------------------------------------------
    proc  ::InitGeodesicWeightImage( IMAGE w)\
    {
        W = &w
        # Compute discrite derivatives
        Ip = filters.ImTranslate(&W,-1,0,0)
        Im = filters.ImTranslate(&W, 1,0,0)
        diff = (Ip-Im)/2
        ::geodesic_weight_dx = diff

        # Compute discrite derivatives
        Ip = filters.ImTranslate(&W, 0,-1,0)
        Im = filters.ImTranslate(&W, 0, 1,0)
        diff = (Ip-Im)/2
        ::geodesic_weight_dy = diff
 
        # does it work for 2D
        # Compute discrite derivatives
        Ip = filters.ImTranslate(&W,0,0,-1)
        Im = filters.ImTranslate(&W,0,0, 1)
        diff = (Ip-Im)/2
        ::geodesic_weight_dz = diff
    }

    #---------------------------------------------------------------------------
    proc  ::LoadGeodesicWeightImage()\
    {
      # Restriction on geodesic image type: FLOAT ???

      if (::geodesicimage_name=="BrowseImage") {
        InfoDisplay "Select input image"
      } else {
        ::params.use_geodesic = true
        del ::geodesic_weight
        eval "::geodesic_weight    = &"+::geodesicimage_name+";"

        ::InitGeodesicWeightImage(&::geodesic_weight)
        
        if (exists(::win)) {
          ::win.Update(-1)
        }
      }
    }

    #---------------------------------------------------------------------------
    proc  ::ComputeGeodesicWeightImage()\
    {
      if exists(::inls0) \
      {
        SetStatusText("Computing Geodesic Weights")
        inittime = wx.wxDateTime.UNow()
        # get local variable of input image
        
        i = &::input
        i_var = filter(i*i,::params.geoweights_sigma,0,0,0)
        is    = filter(i  ,::params.geoweights_sigma,0,0,0)
        i_var = i_var -is*is
        del is
        i_var_mean= mean[::inls0>0](i_var)
        w = exp(-i_var/i_var_mean)
        w = w*(1-::params.geoweights_minimum)+::params.geoweights_minimum
        del i_var

        del ::geodesic_weight
        ::geodesic_weight = &w
        del w
        ::InitGeodesicWeightImage(&::geodesic_weight)

        if (exists(::win)) {
          ::win.Update(-1)
        }

        diff=wx.wxDateTime.UNow()-inittime
        time_elapsed = diff.Format("%M min %S s %l ms").c_str()
        SetStatusText("Geodesic Weights \tDone (%1%)" % time_elapsed)
      } else \
      {
        InfoDialog "No initial contour image !"
      }
    }
    
    #---------------------------------------------------------------------------
    # Set the geodesic weight image and its gradient
    # to enable geodesic active contour for smoothing and advection terms
    #
    proc ::SetGeodesicWeights( IMAGE W, IMAGE Wx, IMAGE Wy, IMAGE Wz) \
    {
      ::params.use_geodesic = true
      ::geodesic_weight    = &W
      ::geodesic_weight_dx = &Wx
      ::geodesic_weight_dy = &Wy
      ::geodesic_weight_dz = &Wz
    }


    #---------------------------------------------------------------------------
    proc ::LSSaveParameters() {

        paramfile_name = ::result_filename+"_param.txt"
        if (wx.wxFileName(paramfile_name).FileExists()) {
          InfoDialog "file %1% already exists, please rename it." % paramfile_name
        } else {
          paramfile = File(paramfile_name,"w")
    
          paramfile._print("# AMILab\n")
          paramfile._print("# parameters used in the Level Set segmentation \n")
          paramfile._print("#  \n")
          paramfile._print("::input_name   = %1% \n" % ::input_name)
          paramfile._print("::initial_name = %1% \n" % ::initial_name)
          paramfile._print("::params.init_mode = %1% \n"    % ::params.init_mode)
          paramfile._print("::inputmin = %1% \n"     % ::inputmin)
          paramfile._print("::inputmax = %1% \n"     % ::inputmax)
          paramfile._print("::params.minimal_intensity = %1% \n"     % ::params.minimal_intensity)
          paramfile._print("::params.use_expansion = %1% \n" % ::params.use_expansion)
          paramfile._print("::params.use_advection = %1% \n" % ::params.use_advection)
          paramfile._print("::params.use_smoothing = %1% \n" % ::params.use_smoothing)
          paramfile._print("::params.use_velocity = %1% \n"  % ::params.use_velocity)
          paramfile._print("::params.use_expansion_image = %1% \n"     % ::params.use_expansion_image)
          paramfile._print("::params.expansion_image_name = %1% \n"     % ::params.expansion_image_name)
          paramfile._print("::params.Imean = %1% \n"     % ::params.Imean)
          paramfile._print("::params.Isd = %1% \n"     % ::params.Isd)
          paramfile._print("::params.prob_threshold = %1% \n"     % ::params.prob_threshold)
          paramfile._print("::sphere_radius = %1% \n"     % ::sphere_radius)
          paramfile._print("::params.accept_high_intensity = %1% \n"     % ::params.accept_high_intensity)
          paramfile._print("::params.expansioncoeff = %1% \n"     % ::params.expansioncoeff)
          paramfile._print("::params.dt = %1% \n"     % ::params.dt)
          paramfile._print("::params.T = %1% \n"     % ::params.T)
          paramfile._print("::params.NBD_method = %1% \n"     % ::params.NBD_method)
          paramfile._print("::params.NBD_freq = %1% \n"     % ::params.NBD_freq)
          paramfile._print("::params.check_convergence = %1% \n"     % ::params.check_convergence)
          paramfile._print("::params.conv_freq = %1% \n"     % ::params.conv_freq)
          paramfile._print("::stop = %1% \n"     % ::stop)
          paramfile._print("::threads = %1% \n"     % ::threads)
          paramfile._print("::params.advcoeff = %1% \n"     % ::params.advcoeff)
          paramfile._print("::params.curvcoeff = %1% \n"     % ::params.curvcoeff)
          paramfile._print("::params.smoothingtype = %1% \n"     % ::params.smoothingtype)
          paramfile._print("::params.affinecurv = %1% \n"     % ::params.affinecurv)
          paramfile._print("::params.velcoeff = %1% \n"     % ::params.velcoeff)
          paramfile._print("::downsamplefactor = %1% \n"     % ::downsamplefactor)
          paramfile.close()
        }
      }

    #---------------------------------------------------------------------------
    proc ::load_input() {
        printn "*** load_input ***"
        eval "::input <<= (FLOAT)"+::input_name+";"
        if (::input_name=="BrowseImage") {
          ::input_name = "::input"
          ::win.Update(-1)
        }
    
        ::inputmin          = min(::input)
        ::inputmax          = max(::input)
        ::GuiUpdateIntensityLimits(::inputmin,::inputmax)
        ::params.minimal_intensity = ::inputmin
        if (exists(::win)) {
          ::win.Update(-1)
        }

        ::UpdateHistogram()

        if (exists(::viewer)) { del ::viewer;}
        ::viewer = DessinImage(&::input)
        ::own_viewer = 1;
      }
      Comments( ::load_input, "Copies the input image in a local image member named 'input', and updates the min-max intensities")

    #---------------------------------------------------------------------------
    proc ::setviewer( OBJECT v) \
    {
      if (exists(::viewer)) { del ::viewer;}
      ::viewer = &v
      ::own_viewer = 0;
    }

    #---------------------------------------------------------------------------
    proc ::setisocontour( NUM index) \
    {
      ::isocontour_index = index;
    }

    #---------------------------------------------------------------------------
    proc ::UpdateViewer( ) \
    {
      if (exists(::viewer)) \
      {
        ::viewer.Paint()
        ::viewer.update()
      }
    }

    #---------------------------------------------------------------------------
    proc ::set_input(IMAGE _input) \
    {
      
      if (::own_viewer && exists(::viewer))  \
      { 
        del ::viewer; 
        ::own_viewer = 0;
      }
      if (exists(::inls_backup)) { del ::inls_backup; }
    
      ::input <<= (FLOAT)_input
          
      ::inputmin = min(::input)
      ::inputmax = max(::input)
      ::params.minimal_intensity = ::inputmin
      ::UpdateHistogram()
      ::GuiUpdateIntensityLimits(::inputmin,::inputmax)
    
      ::inls <<= (FLOAT)::input*0-10
      ::inls0 <<= ::inls
    
      if (!exists(::viewer)) { 
        ::viewer = DessinImage(&::input);
        ::own_viewer = 1;
      }
      ::viewer.SetIsoContour(::isocontour_index,&::inls,0)
      ::viewer.DrawIsoContour(::isocontour_index,1)
    
    }
  
    #---------------------------------------------------------------------------
    proc ::set_initial( IMAGE im) \
    {
      ::inls <<= im
      ::inls0 <<= ::inls
      show ::inls
      if (exists(::viewer)) {
        ::viewer.SetIsoContour(::isocontour_index,::inls,0)
        ::viewer.DrawIsoContour(::isocontour_index,1)
      }
    }
  
    #---------------------------------------------------------------------------
    proc ::set_expansion( IMAGE im) \
    {
      ::expansion_image <<= im
      #show ::expansion_image
    }
  
    #---------------------------------------------------------------------------
    proc ::UpdateHistogram() \
    {
      printn "*** UpdateHistogram ***"
      # display histogram
      ::h <<= histo(::input,::inputmin,::inputmax,::inputmax-::inputmin+1)
      ::dw.SetXLimits(::inputmin,::inputmax)
      ::dw.SetYLimits(min(::h),max(::h))
      ::dw.SetCurve(::h)
      ::dw.SetCurveProperties(0,"#F05050")
    }
    Comments( ::UpdateHistogram, "Updates the display of the Histogram.")

    #---------------------------------------------------------------------------
    proc ::UpdateExpansionCurve() \
    {
      if (exists(::input)) {
        ::exp_curve = Image(FLOAT,::inputmax-::inputmin+1,1,1)
        ::exp_curve.settranslation(::inputmin,0,0)
        
        ::exp_curve = SpacePos(::exp_curve)[0]- ::params.Imean
        
        ::exp_curve = \
          (exp(-::exp_curve*::exp_curve/(2*::params.Isd*::params.Isd))\
            -::params.prob_threshold)\
          *max(::h)
        
        ::dw->SetCurve(::exp_curve,1)
        ::dw->SetCurveProperties(1,"#5050F0")
        ::dw->SetYLimits(-max(-min(::exp_curve),-min(::h)),max(max(::h),max(::exp_curve)))
      } else {
        InfoDialog "You need to load the input image first ..."
      }
    }
    Comments( ::UpdateExpansionCurve, "Updates the display of the expansion mapping curve.")

    #---------------------------------------------------------------------------
    proc ::load_initial() {

      if (!exists(::input)) {
        InfoDialog "::load_initial() \t Need to load input image first!"
      } else {
        if (::params.init_mode==1) {
          eval "::inls <<= (FLOAT)"+::initial_name+";"
          if (::initial_name=="BrowseImage") {
            ::initial_name = "::initial_name"
            ::win.Update(-1)
          }
          minin = min(::inls)
          maxin = max(::inls)
          ::win.FloatConstraints(::initim_threshold_id,\
                                    minin,maxin,(minin+maxin)/2)
          ::inls = ::inls-::params.initial_image_threshold
          ::ComputeIntensityStats()
        } else {
          ::inls <<= ::input*0-1
        }
   
        ::inls0 <<= ::inls
        ::viewer.SetIsoContour(::isocontour_index,&::inls,0)
        ::viewer.DrawIsoContour(::isocontour_index,1)
      }
    }
    Comments( ::load_initial, "Copies the initial levelset image in a local image member named 'inls', and draws the corresponding isocontour in the image viewer.")

    #---------------------------------------------------------------------------
    proc ::ref_initial() {

      if (!exists(::input)) {
        InfoDialog "::load_initial() \t Need to load input image first!"
      } else {
        if (::params.init_mode==1) {
          if (::params.initial_image_threshold!=0) {
            ::params.initial_image_threshold=0
            ::win.Update(-1)
          }
          # Delete ::inls is it exists
          if (exists(::inls0)) { del ::inls0; }
          eval "::inls0 = &"+::initial_name+";"
          if (::initial_name=="BrowseImage") {
            ::initial_name = "::initial_name"
            ::win.Update(-1)
          }
          ::ComputeIntensityStats
        } else {
          ::inls0 = ::input*0-1
        }
    
        ::inls <<= ::inls0
        ::viewer.SetIsoContour(::isocontour_index,&::inls,0)
        ::viewer.DrawIsoContour(::isocontour_index,1)
      }
    }
    Comments( ::ref_initial, "Creates a reference to the initial levelset image in a local image member named 'inls', and draws the corresponding isocontour in the image viewer.")
  
    #---------------------------------------------------------------------------
    # reads the expansion image
    #
    proc ::load_expansion() \
    {
      eval "::expansion_image <<= (FLOAT)"+::params.expansion_image_name+";"
      if (::params.expansion_image_name=="BrowseImage") {
        ::params.expansion_image_name = "::expansion_image"
        ::win.Update(-1)
      }
    }

    #---------------------------------------------------------------------------
    proc ::Init1(IMAGE _input) {
      tmp = ((FLOAT)_input)*0-4
      ::Init(&_input,&tmp)
    }
    

    #---------------------------------------------------------------------------
    proc ::SaveParams( STRING filename) \
    {
      pfile = File(filename,"w")
      
      #pfile._printn("#")
      #pfile._printn("# amilab")
      #pfile._printn("#")
      #pfile._printn("# Parameters using for the level set evolution:")
      #pfile._printn("#")
      pfile._printn(" ")
      #pfile._printn("# Initialization:")
      pfile._printn("::params.init_mode = %1%" % ::params.init_mode)
      pfile._printn("::inputmin  = %1%" % ::inputmin)
      pfile._printn("::inputmax  = %1%" % ::inputmax)
      pfile._printn("::params.minimal_intensity = %1%" % ::params.minimal_intensity)
      pfile._printn("::sphere_radius = %1%" % ::sphere_radius)
      pfile._printn(" ")
      #pfile._printn("# Evolution equation:")
      pfile._printn("::params.Imean         = %1%" % ::params.Imean)
      pfile._printn("::params.Isd           = %1%" % ::params.Isd)
      pfile._printn("::params.accept_high_intensity = %1%" % ::params.accept_high_intensity)

      pfile._printn("::expansion_coeff = %1%" % ::params.expansioncoeff)
      pfile._printn("::params.dt              = %1%" % ::params.dt)
      pfile._printn("::params.T               = %1%" % ::params.T)
    }

    #---------------------------------------------------------------------------
    proc ::SetVelocityField( IMAGE vel, NUM coeff ) {
    
      ::velfield = vel
      ::params.velcoeff = coeff
      ::win.Update(-1)
    
    }
    
    
    #---------------------------------------------------------------------------
    proc ::Reset() {
      if (exists(::inls)) {
        ::inls = -1
      }
      ::UpdateViewer()
    }
    
    
    #---------------------------------------------------------------------------
    proc ::ComputeIntensityStats() {
    
      if (exists(::inls)) {
        if (count(::inls>0)>0) {
          ::params.Imean= mean[::inls>0](::input)
          ::params.Isd  = mean[::inls>0] ( (::input-::params.Imean)*(::input-::params.Imean))
          ::params.Isd  = sqrt(::params.Isd)
          printn sprint("mean %f",::params.Imean)
          printn sprint("sd   %f",::params.Isd)
          ::UpdateExpansionCurve()
        } else  {
          InfoDialog "::ComputeIntensityStats() \n No point within initial level set"
        }
        if (exists(::win)) {
          ::win.Update(-1)
        }
      } else {
          InfoDialog "::ComputeIntensityStats() \n ::inls not found"
      }
    }
    
    #---------------------------------------------------------------------------
    // use median instead of mean
    // to be more robust to outliers
    //
    proc ::ComputeIntensityStatsMedian() {
    
      if (exists(::inls)) {
        if (count(::inls>0)>0) {
          ::params.Imean= median[::inls>0](::input)
          tmp = (::input-::params.Imean)*(::input-::params.Imean)
          ::params.Isd  = median[::inls>0] ( tmp)
          ::params.Isd  = sqrt(::params.Isd)
          printn sprint("median: mean %f",::params.Imean)
          printn sprint("median: sd   %f",::params.Isd)
        } else  {
          InfoDialog "::ComputeIntensityStatsMedian() \n No point within initial level set"
        }
        if (exists(::win)) {
          ::win.Update(-1)
        }
      } else {
          InfoDialog "::ComputeIntensityStatsMedian() \n ::inls not found"
      }
    }
    
    #---------------------------------------------------------------------------
    proc ::InitEvolution(  NUM graphics, NUM numit) {
    //   ---------------
    
      # Not ideal to force isotropic voxels !!!
      ::v_x = ::input.vx
      ::v_y = ::input.vy
      ::v_z = ::input.vz
    
      setvoxelsize(::input,  1,1,1)
      setvoxelsize(::inls,1,1,1)
    
      # Parameters:
      #   1. grad threshold
      #   2. iterations
      #   3. attach coeff
      #   4. params.curvcoeff
      #   5. params.dt
      #   6. reinitfreq
    
    
      adv_coeff = 0;
      if (::params.use_advection) {
        adv_coeff = ::params.advcoeff;
      }
      smo_coeff = 0;
      if (::params.use_smoothing) {
        smo_coeff = ::params.curvcoeff;
      }

      # new level set object
      if (exists(::levelset)) { del ::levelset; }
      ::levelset = vtkLevelSets();
      ::levelset.SetParam(0.7,numit,adv_coeff,smo_coeff,::params.dt,::params.NBD_freq)
      ::levelset.SetDistMethod(::params.NBD_method)
      ::levelset.SetThreads(::threads)
      ::levelset.SetMeanCurv(::params.smoothingtype)
      ::levelset.SetAffineCurv(::params.affinecurv)
    
      if (exists(::velfield)) {
        ::levelset.SetVelocity(::velfield,::params.velcoeff)
      }

      if (::params.use_geodesic) {
        if exists(::geodesic_weight) {
          ::levelset.SetCurvWeights(&::geodesic_weight)
          ::levelset.SetAdvectionField( &::geodesic_weight_dx,\
                                        &::geodesic_weight_dy, \
                                        &::geodesic_weight_dz )
        }
      }
    
      print "Compute Expansion Image \n"
    
      print "Mean = "; print ::params.Imean;
      print " SD = ";  print ::params.Isd;
      print "\n"
    
      ::levelset.SetILowTh(::params.minimal_intensity)

      if (::params.use_expansion) {
        if (::params.use_expansion_image) {
          if (!exists(::expansion_image)) {
            ::load_expansion()
          }
          ::levelset.SetExpansionImage(::expansion_image)
        } else {
          ::levelset.SetNumGaussians(1)
          ::levelset.SetGaussian(0,::params.Imean,::params.Isd)
          ::levelset.SetProbThreshold(::params.prob_threshold)
          if (::params.accept_high_intensity) {
            ::levelset.SetProbHighTh(::params.Imean+::params.Isd)
          }
        } 
        # end else / if (::params.use_expansion_image)
    
        ::levelset.SetExpansion(::params.expansioncoeff)
      } else {
        ::levelset.SetExpansion(0)
      }
    
      print "Compute Expansion Image OK \n"
    
      ::levelset.SetBandTube(3,2)
    
      ::lsres = ::levelset.InitWithImage(&::input,&::inls)
    #  ::lsres = ::levelset.init(::input,900)
    
      if (graphics) {
        ::UpdateViewer()
        if (::own_viewer) {
          # sets the isocontour number 0 to the image 'initial' with threshold 0
          ::viewer.SetIsoContour(::isocontour_index,&::inls,0)
          # sets the isocontour number 0 to be active
          ::viewer.DrawIsoContour(::isocontour_index,1)
          ::viewer.SetIsoContour(2,&::lsres,0)
          ::viewer.DrawIsoContour(2,1)
        } else {
          ::viewer.SetIsoContour(::isocontour_index,&::lsres,0)
          ::viewer.DrawIsoContour(::isocontour_index,1)
        }
      }

    }

    #---------------------------------------------------------------------------
    proc ::EndEvolution(  NUM graphics) {
    //   ---------------
      printn "continue commands"
      setvoxelsize( ::input, ::v_x, ::v_y, ::v_z)
      setvoxelsize( ::inls,  ::v_x, ::v_y, ::v_z)
      setvoxelsize( ::lsres, ::v_x, ::v_y, ::v_z)
      del ::v_x
      del ::v_y
      del ::v_z
    
      # invert before ending to be compatible with input convention
      ::levelset.UpdateResult()
      ::lsres = ::levelset.GetOutputImage()
      ::inls = -::lsres
      del ::lsres
      ::levelset.End()

      if (::own_viewer) {
        ::viewer.DrawIsoContour(2,0)
      } else {
        ::viewer.SetIsoContour(::isocontour_index,&::inls,0)
        ::viewer.DrawIsoContour(::isocontour_index,1)
      }

    }

    #---------------------------------------------------------------------------
    proc ::Run(  NUM graphics) {
    //   -----
    
      it = floor(::params.T/::params.dt)+1

      ::InitEvolution(graphics,it)
      ::levelset.Iterate();
      ::levelset.UpdateResult()
      previous_ls = ::levelset.GetOutputImage()
    
      # every how many iterations call the graphic events
      ::displ_freq = 8

      k = 0
      SetProgress(0)
      ::stop = 0;
      
      for n=1 to it {
        #print n; print "/"; printn it
        if (!::stop) {
          #print sprint("::params.T= %0.2f \n",n*::params.dt)
          ::levelset.Iterate();
          k = k+1
          if (graphics)&&(k==::displ_freq) {
            ::levelset.UpdateResult()
            ::lsres = ::levelset.GetOutputImage()
            k = 0
            ::UpdateViewer()
            ProcessEvents(200)
          }
          SetProgress((FLOAT)n/it*100.0)
          if (::params.check_convergence) {
            if ((n % ::params.conv_freq) == 0) {
              # check for convergence
              ::levelset.UpdateResult()
              ::lsres = ::levelset.GetOutputImage()
              stillmoving = count((previous_ls*::lsres)<0)
              print "*** Convergence test = "; printn stillmoving
              if (stillmoving==0) { ::stop=1; }
              previous_ls = ::lsres
            }
          }
        } else {
          printn "stopped!"
          n=it+1;
        }
      }
    
      ::EndEvolution(graphics)
      SetProgress(0)
    
    }
    # ::Run()
    
    
    #---------------------------------------------------------------------------
    proc ::AddSphere() \
    {
      if (!exists(::inls))        { ::load_initial(); }
      if (exists(::viewer)) {
        _x = ::viewer.GetXPos() 
        _y = ::viewer.GetYPos()
        _z = ::viewer.GetZPos()
        print "cursor is at "
        print " %1% " % _x
        print " %1% " %_y
        print " %1% \n" % _z
        ::inls_backup = ::inls
        #global::AddBrightSphere_mm(&::inls,\
        #      _x,_y,_z,\
        #      ::sphere_radius,-1,1)
        ::AS.AddBrightSphere_mm(&::inls,\
              _x,_y,_z,\
              ::sphere_radius,-1,1)
        ::inls0 = ::inls
        ::UpdateViewer()
      } else {
        print "We have to show ::input and position de cursor at the sphere center (using mouse middle button) \n"
      }
    }
    
    //---------------------------------------------------
    proc ::Backup() {
      ::inls_backup = ::inls
    }
    
    #---------------------------------------------------------------------------
    proc ::Undo() {
        if (exists(::inls_backup)) {
          ::inls = ::inls_backup
        } else {
          print "There is no current backup"
        }
    }
    
    
    #---------------------------------------------------------------------------
    proc ::ChangedValues() {
    }
    
    #---------------------------------------------------------------------------
    proc ::ApplyDT() {
      if (exists(::inls)) {
        ::inls = vtkPropDaniel2(::inls,0,::params.DTmin,::params.DTmax)
      } else {
        InfoDialog "No Level Set Image."
      }
    }
    
    #---------------------------------------------------------------------------
    proc ::ReRun() {
      if (!exists(::input)) { ::load_input(); }
      if (!exists(::inls))  { ::load_initial(); }
      ::inls = ::inls0
      ::Run(1)
      ::UpdateViewer()
    }
    
    #---------------------------------------------------------------------------
    proc ::Stop() {
      ::stop = 1
      printn "stopping"
    }
    
    
    #---------------------------------------------------------------------------
    proc ::Continue() {
      ::Run(1)
      ::UpdateViewer()
    }
    
    #---------------------------------------------------------------------------
    proc ::Surface() {
    
      if (exists(::s0)) {
        if (exists(::s0_draw)) { ::s0_draw -= ::s0; }
        del ::s0
      }
      ::s0 = isosurf(::inls0,0.01)
      if (!exists(::s0_draw)) {
        show ::s0
      } else {
        ::s0_draw += ::s0
      }
      if (exists(::s1)) {
        ::s0_draw -= ::s1
        del ::s1
      }
      ::s1 = isosurf(::inls,0.01)
      ::s0_draw += ::s1
      if (exists(::viewer)) {
        ::viewer.setGLwin(&::s0_draw)
      }
    
    }
    
    //---------------------------------------------------
    proc ::SaveResult() {
    
      filename=::result_filename-".gz"-".ami";
      if (::resname_addprob) {
        filename = filename + sprint("_mean%0.0f",::params.Imean) \
                            + sprint("_SD%0.2f",::params.Isd)
      }
      if (::resname_addtime) {
        filename = filename + sprint("_T%0.0f",::params.T)
      }
      filename = filename + ::result_filename_ext
      print "saving file "+filename+"\n"
      ::inls.save filename
    }
    
    #---------------------------------------------------------------------------
    proc ::SaveInsideModel() {
    }
    
    #---------------------------------------------------------------------------
    proc ::SaveOutsideModel() {
    }
    
    #---------------------------------------------------------------------------
    proc ::InitialLevelSetEvent() {
      ::win.EnablePanel(::initial_spheres_page , ::params.init_mode==0)
      ::win.EnablePanel(::initial_image_page ,   ::params.init_mode==1)
      ::win.SelectPage(::init_book,::params.init_mode)
    }

    #---------------------------------------------------------------------------
    proc ::ExpansionForceEvent() {
      ::win.EnablePanel(::intexp_page, !::params.use_expansion_image)
      ::win.EnablePanel(::imexp_page,   ::params.use_expansion_image)
      ::win.SelectPage(::expansion_book,::params.use_expansion_image)
    }

    #---------------------------------------------------------------------------
    proc ::activate_terms() {
      ::win.EnablePanel(::exp_pid,::params.use_expansion)
      ::win.EnablePanel(::adv_pid,::params.use_advection)
      ::win.EnablePanel(::smo_pid,::params.use_smoothing)
    }
    
    #---------------------------------------------------------------------------
    proc ::GuiUpdateIntensityLimits( NUM _min, NUM _max) {
      ::win.FloatConstraints(::imean_id,_min,_max,::params.Imean)
      ::win.FloatConstraints(::isd_id, 0,(_max-_min)/3.0,::params.Isd)
      ::win.Update(-1)
    }

    #---------------------------------------------------------------------------
    proc ::Gui() {
    
    #  ::win = ParamWin("Evolve Active Contours using Level Sets")
      if (exists(::parent_panel)) {
        ::win = ParamPanel("LevelSets",&::parent_panel)
      } else {
        ::win = ParamPanel("LevelSets")
      }
      
      ::win.BeginBook()
      b = ::win.GetBookCtrl()
      b_classname =  b.GetClassInfo().GetClassName()
      if b_classname=="wxAuiNotebook" {
        b.SetWindowStyle( wx.wxAUI_NB_BOTTOM|\
                          wx.wxAUI_NB_WINDOWLIST_BUTTON )
      }
   
        ::win.AddPage("Init")

          ::win.BeginBoxPanel("Input Image")
            # set the input image
            ::win.BeginHorizontal()
              ::win.AddImageChoice( &::input_name, "")
              ::win.AddButton("Load",::load_input)
              #::win.AddButton("Ref",::ref_input)
            ::win.EndHorizontal()
            ::win.AddFloat( &::params.minimal_intensity,"Min. intensity",::inputmin,::inputmax)
          ::win.EndBoxPanel()

          #::win.BeginBoxPanel("Initial Level Set")
            initmode_id = ::win.AddEnum( &::params.init_mode,"Mode")
              ::win.AddEnumChoice(initmode_id,"Manual Spheres")
              ::win.AddEnumChoice(initmode_id,"Initial image")
            ::win.SetCallback( &::InitialLevelSetEvent)

            ::init_book = ::win.BeginBook()
              ::initial_spheres_page = ::win.AddPage("Spheres")
                ::win.BeginHorizontal()
                  ::win.AddButton("Reset", ::Reset)
                  ::win.AddButton("Add",   ::AddSphere)
                  ::win.AddButton("Undo",  ::Undo)
                  ::win.AddButton("Backup",     ::Backup)
                ::win.EndHorizontal()
                ::win.AddFloat( &::sphere_radius,"Radius",0.1,10.0)

              # set the initial level set image
              ::initial_image_page =::win.AddPage("Image")
                ::win.BeginHorizontal()
                  ::win.AddImageChoice( &::initial_name, "")
                  ::win.AddButton("Load",::load_initial)
                  ::win.AddButton("Ref",::ref_initial)
                ::win.EndHorizontal()
                ::initim_threshold_id = ::win.AddFloat(\
                                            ::params.initial_image_threshold,\
                                            "threshold",-10,10)
            ::win.EndBook()
    
          #::win.EndBoxPanel

    
          ::downsample_id = ::win.AddInt( &::downsamplefactor,"Downsample", 1, 4)
          # disable downsampling since it is not used for now
          ::win.Enable(::downsample_id,0)
    
        ::win.AddPage("Param")
          ::win.BeginHorizontal()
            ::win.AddBoolean( &::params.use_expansion,"Expan")
            ::win.SetCallback( &::activate_terms)
            ::win.AddBoolean( &::params.use_advection,"Adv")
            ::win.SetCallback( &::activate_terms)
            ::win.AddBoolean( &::params.use_smoothing,"Smooth")
            ::win.SetCallback( &::activate_terms)
          ::win.EndHorizontal()
          ::win.BeginBook()
            ::exp_pid = ::win.AddPage("Exp")
              ::win.AddFloat( &::params.expansioncoeff,"Weight",0,1)
              ::win.AddBoolean( &::params.use_expansion_image,"Use expansion image")
              ::win.SetCallback(&::ExpansionForceEvent)
              ::expansion_book = ::win.BeginBook()
                ::intexp_page = ::win.AddPage("Intensity-based")
                  ::win.AddButton("Compute stats",::ComputeIntensityStats)
                  ::imean_id = ::win.AddFloat( &::params.Imean,"Mean", ::inputmin,::inputmax)
                  ::win.SetCallback( &::UpdateExpansionCurve)
                  ::isd_id = ::win.AddFloat( &::params.Isd,"StandDev",0,(::inputmax-::inputmin)/2)
                  ::win.SetCallback( &::UpdateExpansionCurve)
                  ::win.AddFloat( &::params.prob_threshold,"Threshold",0,1)
                  ::win.SetCallback( &::UpdateExpansionCurve)
                  ::win.AddBoolean( &::params.accept_high_intensity,"Accept high intensities")
                  # add a Curve Drawing Window
                  ::dw = wxDrawingWindow(&::win.CurrentParent())
                  ::dw.SetMinSize(&wx.wxSize(50,100))
                  ::dw.SetBackgroundColour(\
                      &wx.wxColour(255,255,255))
                  ::win.AddWidget(&::dw,0)

                ::imexp_page = ::win.AddPage("Image")
                  ::win.AddImageChoice( &::params.expansion_image_name,"Exp. Image:")
              ::win.EndBook()
    
            ::adv_pid = ::win.AddPage("Adv")
              ::win.AddFloat( &::params.advcoeff,"Weight",0,1)
      
            ::smo_pid = ::win.AddPage("Smooth")
              ::win.AddFloat( &::params.curvcoeff,"Weight",0,1)
              ::smoothtype_id = ::win.AddEnum( &::params.smoothingtype,"Type")
                ::win.AddEnumChoice(::smoothtype_id,"min curv")
                ::win.AddEnumChoice(::smoothtype_id,"mean curv")
              ::win.AddBoolean( &::params.affinecurv,"Affine curv")
      
            ::vel_pid = ::win.AddPage("Geo")
              ::win.AddBoolean(&::params.use_geodesic, "Use Geodesic Framework")
              ::win.BeginBoxPanel("Input Weight Image")
                ::win.BeginBoxPanel("Load")
                  ::win.AddImageChoice( &::geodesicimage_name, "")
                  ::win.AddButton("Load and apply", &::LoadGeodesicWeightImage)
                ::win.EndBoxPanel()
                ::win.BeginBoxPanel("Compute from initial contour")
                  ::win.AddFloat(&::params.geoweights_sigma,"sigma",0.6,5)
                  ::win.AddFloat(&::params.geoweights_minimum,"weights minimum",0,1)
                  ::win.AddButton("Compute", &::ComputeGeodesicWeightImage)
                ::win.EndBoxPanel()
              ::win.EndBoxPanel()

            ::vel_pid = ::win.AddPage("Vel")
              ::win.AddFloat( &::params.velcoeff,"Weight",0,1)
    
          ::win.EndBook()
    

        ::win.AddPage("Evol")
    
          ::win.BeginBoxPanel("Time")
            ::win.AddFloat( &::params.dt,"dt",0.01,1)
            ::win.AddFloat( &::params.T,"T",0.01,500)
          ::win.EndBoxPanel()
    
          ::win.BeginBoxPanel("Processing")
            ::win.AddInt( &::threads,"Threads",1,20)
            ::win.BeginHorizontal()
              ::win.AddButton("ReRun",     ::ReRun)
              ::win.AddButton("Continue",  ::Continue)
            ::win.EndHorizontal()
            ::win.BeginHorizontal()
              ::win.AddButton("Stop",      ::Stop)
              ::win.AddButton("Surface",   ::Surface)
            ::win.EndHorizontal()
          ::win.EndBoxPanel()

          ::win.BeginBoxPanel("Convergence")
            ::win.AddBoolean( &::params.check_convergence,"Check")
            ::win.AddInt( &::params.conv_freq,"Freq",5,100)
          ::win.EndBoxPanel()

          ::win.BeginBoxPanel("Re-Distancing")
              ::DistType_id = ::win.AddEnum( &::params.NBD_method,"Method")
                ::win.AddEnumChoice(::DistType_id,"Liana")
                ::win.AddEnumChoice(::DistType_id,"Fast Marching")
                ::win.AddEnumChoice(::DistType_id,"Fast Chamfer")
          ::win.EndBoxPanel()

    
        ::win.AddPage("Res")
    
          ::win.BeginBoxPanel("Recompute distance")
            ::win.AddFloat( &::params.DTmin,"min",-100,0)
            ::win.AddFloat( &::params.DTmax,"max",0,100)
            ::win.AddButton("Apply",  ::ApplyDT)
          ::win.EndBoxPanel()

          ::win.BeginBoxPanel("Result filename")
            ::win.AddString( &::result_filename,"base name:")
            ::win.AddString( &::result_filename_ext,"extension:")
            ::win.AddBoolean( &::resname_addtime,"Add evol. time")
            ::win.AddBoolean( &::resname_addprob,"Add prob.")
          ::win.EndBoxPanel()
    
          ::win.BeginBoxPanel("Save")
          ::win.BeginHorizontal()
            ::win.AddButton("Result",   ::SaveResult)
            ::win.AddButton("Parameters", ::LSSaveParameters)
          ::win.EndHorizontal()
    
          ::win.BeginHorizontal()
            ::win.AddButton("Inside model",   ::SaveInsideModel)
            ::win.AddButton("Outside model",  ::SaveOutsideModel)
          ::win.EndHorizontal()
          ::win.EndBoxPanel()
    
        ::AddParamPage(&::win)

        ::AddHelpPage(&::win)
    
      ::win.EndBook()
    
      ::AddStandardButtons(&::win)

      if (exists(::parent_panel)) {
        ::win.ShowPanel()
      } else {
        ::win.Display()
      }
      ::win.Update(-1)

      ::InitialLevelSetEvent()
      ::ExpansionForceEvent()


    }
    ::Init()
    
  }
  # End of class
  
} 
# End of If 
