# command line: improcess

#SetDebugOn


if (!exists(LS_defined)) {
  LS_defined=1

  func "SyntheticImages/AddSphere.amil"

  //---------------------------------------------------
  proc LS_Init(IMAGE _input, IMAGE _init) {
    global_new

      LS_input_name   = ""
      LS_input_name.Comments("Name of the input image variable")
      LS_initial_name = ""
      LS_initial_name.Comments("Name of the initial level set image variable")
      # 0: for spheres 1: for initial image
      LS_init_mode    = INT(0) 
      LS_init_mode.Comments("Contout initialization mode: spheres or zero-crossing of an image ")

      LS_inputmin = 0
      LS_inputmax = 32000

      LS_minimal_intensity = 0
      LS_minimal_intensity.Comments("Minimal Intensity for the input image")

      LS_use_expansion = UCHAR(1,"Use Expansion Force")
      LS_use_advection = UCHAR(1,"Use Advection Force")
      LS_use_smoothing = UCHAR(1,"Use Smoothing Force")
      LS_use_velocity  = UCHAR(0,"Use Velocity Force")

      LS_use_expansion_image = UCHAR(0,\
                                "Set expansion force from an image")

      LS_expansion_image_name = "Image"

      LS_Imean=70
      LS_Imean.Comments("Estimated mean intensity of the structure to segment")

      LS_Isd=50
      LS_Isd.Comments("Estimated intensity standard deviation of the structure to segment")

      # probability threshold belong which expansion becomes negative
      LS_prob_threshold = 0.3 
      LS_prob_threshold.Comments("Expansion force parameter to create negative forces (shrinking force) when the intensity is too distant from the expected intensity based on its mean and standard deviation")

      LS_sphere_radius = 3
      LS_sphere_radius.Comments("Radius in current unit (usually in mm) of the sphere to add")
      LS_accept_high_intensity = UCHAR(1,"If set to true, will allow the maximal expansion force for any intensity higher the given mean intensity")
      LS_expansioncoeff  = 0.5
      LS_expansioncoeff.Comments("Expansion weight in the evolution equation")

      LS_dt = 0.5
      LS_dt.Comments("Evolution time-step")
      LS_T=200
      LS_T.Comments("Total Evolution time")

      LS_NBD_method     = INT(2)     // 0:liana s, 1: fast marching 2: fast chamfer
      LS_NBD_freq       = INT(6)

      LS_check_convergence = UCHAR(1)
      LS_conv_freq         = INT(20)

      LS_stop = 0;
      # number of threads (not used right now)
      LS_threads = INT(2)

      LS_advcoeff  = 0.5

      LS_curvcoeff = 0.5

      LS_smoothingtype = INT(0) // 0: mean curv 1: min curv
      LS_affinecurv    = UCHAR(0) // 0: 2D affine curvature 1: 2D mean curvature

      LS_velcoeff  = 0.0

      LS_downsamplefactor = INT(1)
      LS_downsamplefactor.Comments("Down-sampling factor, unused for the moment")

      #LS_in_draw.SetIsoContour(0,LS_inls0,0)
      #LS_in_draw.DrawIsoContour(0,1)

      DTmin = -50
      DTmax = 50

      LS_result_filename = "LevelSetResult"
      LS_result_filename_ext = ".ami.gz"
      LS_resname_addtime = UCHAR(1)
      LS_resname_addprob = UCHAR(1)

      LS_Gui()
  }


  #-----------------------------------------------
  proc LS_load_input() {

    eval "global::LS_input <<= (FLOAT)"+LS_input_name+";"
    if (LS_input_name=="Image") {
      LS_input_name = "LS_input"
      LS_win.update
    }

    LS_inputmin          = min(LS_input)
    LS_inputmax          = max(LS_input)
    LS_minimal_intensity = LS_inputmin
    LS_win.update

    show LS_input
  }

  #-----------------------------------------------
  proc LS_load_initial() {

    if (!exists(LS_input)) {
      InfoDialog "LS_load_initial() \t Need to load input image first!"
    } else {
      if (LS_init_mode==1) {
        eval "global::LS_inls <<= (FLOAT)"+LS_initial_name+";"
        if (LS_initial_name=="Image") {
          LS_initial_name = "LS_initial_name"
          LS_win.update
        }
        LS_ComputeIntensityStats
      } else {
        global::LS_inls = LS_input*0-1
      }
  
      global::LS_inls0 = LS_inls
      LS_input_draw.SetIsoContour(1,LS_inls,0)
      LS_input_draw.DrawIsoContour(1,1)
    }
  }


  #-----------------------------------------------
  # reads the expansion image
  #
  proc LS_load_expansion() \
  {
    eval "global::LS_expansion_image <<= (FLOAT)"+LS_expansion_image_name+";"
    if (LS_expansion_image_name=="Image") {
      LS_expansion_image_name = "LS_expansion_image"
      LS_win.update
    }
  }

  //--------------------------------------------------
  proc LS_Init1(IMAGE _input) {
    tmp = ((FLOAT)_input)*0-4
    LS_Init(&_input,&tmp)
  }
  
  //--------------------------------------------------
  proc LS_Setinput(IMAGE input) {
    global_new
  
    if (exists(LS_input_draw)) { del LS_input_draw; }
    if (exists(LS_inls))    { del LS_inls; }
    if (exists(LS_inls0))   { del LS_inls0; }
    if (exists(LS_input))      { del LS_input; }
    if (exists(LS_inls_backup))      { del LS_inls_backup; }
  
    LS_input = (FLOAT)_input
    show LS_input
  
  
    LS_inputmin = min(LS_input)
    LS_inputmax = max(LS_input)
    LS_minimal_intensity = LS_inputmin
  
    LS_inls = (FLOAT)LS_input*0-10
    LS_inls0 = LS_inls
  
    LS_input_draw.SetIsoContour(1,LS_inls,0)
    LS_input_draw.DrawIsoContour(1,1)
  
  }
  
  #--------------------------
  proc LS_SaveParams( STRING filename) \
  {
    pfile = open(filename,"w")
    
    #pfile.printn "#"
    #pfile.printn "# amilab"
    #pfile.printn "#"
    #pfile.printn "# Parameters using for the level set evolution:"
    #pfile.printn "#"
    pfile.printn " "
    #pfile.printn "# Initialization:"
    pfile.printn boost_format("LS_init_mode = %1%") % LS_init_mode
    pfile.printn boost_format("LS_inputmin  = %1%") % LS_inputmin
    pfile.printn boost_format("LS_inputmax  = %1%") % LS_inputmax
    pfile.printn boost_format("LS_minimal_intensity = %1%") % LS_minimal_intensity
    pfile.printn boost_format("LS_sphere_radius = %1%") % LS_sphere_radius
    pfile.printn " "
    #pfile.printn "# Evolution equation:"
    pfile.printn boost_format("LS_Imean         = %1%") % LS_Imean
    pfile.printn boost_format("LS_Isd           = %1%") % LS_Isd
    pfile.printn boost_format("LS_accept_high_intensity = %1%") % LS_accept_high_intensity

    pfile.printn boost_format("LS_expansion_coeff = %1%") % LS_expansioncoeff
    pfile.printn boost_format("LS_dt              = %1%") % LS_dt
    pfile.printn boost_format("LS_T               = %1%") % LS_T

  }

  #--------------------------
  proc LS_Close() \
  {
    LS_win.Hide
    delvars "LS_*_draw"
    delvars "LS_*"
  }
  LS_Close.Comments("Close current script and delete its variables")

  //---------------------------------------------------
  proc LS_SetVelocityField( IMAGE vel, NUM coeff ) {
  
    global::LS_velfield = vel
    global::LS_velcoeff = coeff
    LS_win.update
  
  }
  
  
  //---------------------------------------------------
  proc LS_Reset() {
    if (exists(LS_inls)) {
      LS_inls = -1
    }
    show LS_input
  }
  
  
  //---------------------------------------------------
  proc LS_ComputeIntensityStats() {
  
    if (exists(LS_inls)) {
      if (count(LS_inls>0)>0) {
        global::LS_Imean= mean[LS_inls>0](LS_input)
        global::LS_Isd  = mean[LS_inls>0] ( (LS_input-LS_Imean)*(LS_input-LS_Imean))
        LS_Isd  = sqrt(LS_Isd)
        printn sprint("mean %f",LS_Imean)
        printn sprint("sd   %f",LS_Isd)
      } else  {
        InfoDialog "LS_ComputeIntensityStats() \n No point within initial level set"
      }
      if (exists(LS_win)) {
        LS_win.update
      }
    } else {
        InfoDialog "LS_ComputeIntensityStats() \n LS_inls not found"
    }
  }
  
  //---------------------------------------------------
  // use median instead of mean
  // to be more robust to outliers
  //
  proc LS_ComputeIntensityStatsMedian() {
  
    if (exists(LS_inls)) {
      if (count(LS_inls>0)>0) {
        global::LS_Imean= median[LS_inls>0](LS_input)
        tmp = (LS_input-LS_Imean)*(LS_input-LS_Imean)
        global::LS_Isd  = median[LS_inls>0] ( tmp)
        LS_Isd  = sqrt(LS_Isd)
        printn sprint("median: mean %f",LS_Imean)
        printn sprint("median: sd   %f",LS_Isd)
      } else  {
        InfoDialog "LS_ComputeIntensityStatsMedian() \n No point within initial level set"
      }
      if (exists(LS_win)) {
        LS_win.update
      }
    } else {
        InfoDialog "LS_ComputeIntensityStatsMedian() \n LS_inls not found"
    }
  }
  
  //--------------------------------------------------
  proc LS_Run(  NUM graphics) {
  //   -----
  
    // every how many iterations call the graphic events
    LS_displ_freq = 8
    it = floor(LS_T/LS_dt)+1
  
  
    v_x = LS_input.vx
    v_y = LS_input.vy
    v_z = LS_input.vz
  
    setvoxelsize(LS_input,  1,1,1)
    setvoxelsize(LS_inls,1,1,1)
  
    // Parameters:
    //   1. grad threshold
    //   2. iterations
    //   3. attach coeff
    //   4. curvcoeff
    //   5. dt
    //   6. reinitfreq
  
  
    //
    LevelSetsCURV.SetParam(0.7,it,LS_advcoeff,LS_curvcoeff,LS_dt,LS_NBD_freq)
    LevelSetsCURV.SetDistMethod(LS_NBD_method)
    LevelSetsCURV.SetThreads(LS_threads)
    LevelSetsCURV.SetMeanCurv(LS_smoothingtype)
    LevelSetsCURV.SetAffineCurv(LS_affinecurv)
  
    if (exists(LS_velfield)) {
      LevelSetsCURV.SetVelocity(LS_velfield,LS_velcoeff)
    }
  
    print "Compute Expansion Image \n"
  
    print "Mean = "; print LS_Imean;
    print " SD = ";  print LS_Isd;
    print "\n"
  
    LevelSetsCURV.SetILowTh(LS_minimal_intensity)
    if (LS_use_expansion_image) {
      if (!exists(LS_expansion_image)) {
        LS_load_expansion
      }
      LevelSetsCURV.SetExpansionImage(LS_expansion_image)
    } else {
      LevelSetsCURV.SetNumGaussians(1)
      LevelSetsCURV.SetGaussian(0,LS_Imean,LS_Isd)
      LevelSetsCURV.SetProbThreshold(LS_prob_threshold)
      if (LS_accept_high_intensity) {
        LevelSetsCURV.SetProbHighTh(LS_Imean+LS_Isd)
      }
    } 
    # end else / if (LS_use_expansion_image)

    LevelSetsCURV.SetExpansion(LS_expansioncoeff)
  
    print "Compute Expansion Image OK \n"
  
    LevelSetsCURV.SetBandTube(3,2)
  
    lres = LevelSetsCURV.init(LS_input,LS_inls)
  #  lres = LevelSetsCURV.init(LS_input,900)
  
    if (graphics) {
      show LS_input
      // sets the isocontour number 0 to the image 'initial' with threshold 0
      LS_input_draw.SetIsoContour(1,LS_inls,0)
      // sets the isocontour number 0 to be active
      LS_input_draw.DrawIsoContour(1,1)
      LS_input_draw.SetIsoContour(2,lres,0)
      LS_input_draw.DrawIsoContour(2,1)
    }
  
    printn "1"
    LevelSetsCURV.iterate;
    LevelSetsCURV.UpdateResult
    previous_ls = LevelSetsCURV.GetOutput
    printn "2"
  
    k = 0
    SetProgress(0)
    LS_stop = 0;
    
    for n=1 to it {
      #print n; print "/"; printn it
      if (!LS_stop) {
        #print sprint("LS_T= %0.2f \n",n*LS_dt)
        LevelSetsCURV.iterate;
        k = k+1
        if (graphics)&&(k==LS_displ_freq) {
          LevelSetsCURV.UpdateResult
          lres = LevelSetsCURV.GetOutput
          k = 0
          show LS_input
          ProcessXEvents(100)
        }
        SetProgress(n/it*100)
        if (LS_check_convergence) {
          if ((n % LS_conv_freq) == 0) {
            # check for convergence
            LevelSetsCURV.UpdateResult
            lres = LevelSetsCURV.GetOutput
            stillmoving = count((previous_ls*lres)<0)
            print "*** Convergence test = "; printn stillmoving
            if (stillmoving==0) { LS_stop=1; }
            previous_ls = lres
          }
        }
      } else {
        printn "stopped!"
        n=it+1;
      }
    }
  
    printn "continue commands"
    setvoxelsize( LS_input,   v_x, v_y, v_z)
    setvoxelsize( LS_inls, v_x, v_y, v_z)
    setvoxelsize( lres,    v_x, v_y, v_z)
  
    // invert before ending to be compatible with input convention
    LevelSetsCURV.UpdateResult
    lres = LevelSetsCURV.GetOutput
    LS_inls = -lres;
  
    LevelSetsCURV.end
    SetProgress(0)
  
    LS_input_draw.DrawIsoContour(2,0)
  }
  # LS_Run()
  
  
  //---------------------------------------------------
  proc LS_AddSphere() \
  {
    if (!exists(LS_inls))        { LS_load_initial; }
    if (exists(LS_input_draw)) {
      _x = LS_input_draw.GetXPos
      _y = LS_input_draw.GetYPos
      _z = LS_input_draw.GetZPos
      printn "cursor is at "
      printn _x
      printn _y
      printn _z
      global::LS_inls_backup = global::LS_inls
      AddBrightSphere_mm(&global::LS_inls,\
            _x,_y,_z,\
            LS_sphere_radius,-1,1)
      global::LS_inls0 = global::LS_inls
      show global::LS_input;
    } else {
      print "We have to show LS_input and position de cursor at the sphere center (using mouse middle button) \n"
    }
  }
  
  //---------------------------------------------------
  proc LS_Backup() {
    global::LS_inls_backup = LS_inls
  }
  
  //---------------------------------------------------
  proc LS_Undo() {
      if (exists(LS_inls_backup)) {
        LS_inls = LS_inls_backup
      } else {
        print "There is no current backup"
      }
  }
  
  
  //---------------------------------------------------
  proc LS_ChangedValues() {
  }
  
  //---------------------------------------------------
  proc LS_ApplyDT() {
    LS_inls = vtkPropDaniel2(LS_inls,0,DTmin,DTmax)
  }
  
  //---------------------------------------------------
  proc LS_ReRun() {
    if (!exists(LS_input_image)) { LS_load_input; }
    if (!exists(LS_inls))        { LS_load_initial; }
    LS_inls = LS_inls0
    LS_Run(1)
    show LS_input
  }
  
  //---------------------------------------------------
  proc LS_Stop() {
    LS_stop = 1
    printn "stopping"
  }
  
  
  //---------------------------------------------------
  proc LS_Continue() {
    LS_Run(1)
    show LS_input
  }
  
  //---------------------------------------------------
  proc LS_Surface() {
  
    if (exists(LS_s0)) {
      if (exists(LS_s0_draw)) { LS_s0_draw -= LS_s0; }
      del LS_s0
    }
    global::LS_s0 = isosurf(LS_inls0,0.01)
    if (!exists(LS_s0_draw)) {
      show LS_s0
    } else {
      LS_s0_draw += LS_s0
    }
    if (exists(LS_s1)) {
      LS_s0_draw -= LS_s1
      del LS_s1
    }
    global::LS_s1 = isosurf(LS_inls,0.01)
    LS_s0_draw += LS_s1
    if (exists(LS_input_draw)) {
      LS_input_draw.setGLwin(LS_s0_draw)
    }
  
  }
  
  //---------------------------------------------------
  proc LS_SaveResult() {
  
    filename=LS_result_filename-".gz"-".ami";
    if (LS_resname_addprob) {
      filename = filename + sprint("_mean%0.0f",LS_Imean) \
                          + sprint("_SD%0.2f",LS_Isd)
    }
    if (LS_resname_addtime) {
      filename = filename + sprint("_T%0.0f",LS_T)
    }
    filename = filename + LS_result_filename_ext
    print "saving file "+filename+"\n"
    LS_inls.save filename
  }
  
  //---------------------------------------------------
  proc LS_SaveInsideModel() {
  }
  
  //---------------------------------------------------
  proc LS_SaveOutsideModel() {
  }
  
  //---------------------------------------------------
  proc LS_activate_terms() {
    LS_win.EnablePanel(LS_exp_pid,LS_use_expansion)
    LS_win.EnablePanel(LS_adv_pid,LS_use_advection)
    LS_win.EnablePanel(LS_smo_pid,LS_use_smoothing)
  }
  
  //---------------------------------------------------
  proc LS_Gui() {
  
  #  LS_win = ParamWin("Evolve Active Contours using Level Sets")
    global::LS_win = ParamWin("LevelSets")
    LS_win.BeginBook
  
      LS_win.AddPage("Init")

        LS_win.BeginBoxPanel("Input Image")
          # set the input image
          LS_win.BeginHorizontal
            LS_win.AddImageChoice(LS_input_name, "")
            LS_win.AddButton("Load",LS_load_input)
          LS_win.EndHorizontal
          LS_win.AddFloat(LS_minimal_intensity,"Min. intensity",LS_inputmin,LS_inputmax)
        LS_win.EndBoxPanel

        LS_win.BeginBoxPanel("Initial Level Set")
          initmode_id = LS_win.AddEnum(LS_init_mode,"Mode")
            LS_win.AddEnumChoice(initmode_id,"Manual Spheres")
            LS_win.AddEnumChoice(initmode_id,"Initial image")
  
          LS_win.BeginBoxPanel("Spheres")
            LS_win.BeginHorizontal
              LS_win.AddButton("Reset", LS_Reset)
              LS_win.AddButton("Add",   LS_AddSphere)
              LS_win.AddButton("Undo",  LS_Undo)
              LS_win.AddButton("Backup",     LS_Backup)
            LS_win.EndHorizontal
            LS_win.AddFloat(LS_sphere_radius,"Radius",0.1,10.0)
          LS_win.EndBoxPanel

          # set the initial level set image
          LS_win.BeginBoxPanel("Initial Image")
            LS_win.BeginHorizontal
              LS_win.AddImageChoice(LS_initial_name, "")
              LS_win.AddButton("Load",LS_load_initial)
            LS_win.EndHorizontal
          LS_win.EndBoxPanel
  
        LS_win.EndBoxPanel

        LS_win.AddButton("Compute Intensity stats",LS_ComputeIntensityStats)
  
        LS_win.AddInt( LS_downsamplefactor,"Downsample", 1, 4)
  
      LS_win.AddPage("Param")
        LS_win.AddBoolean(LS_use_expansion,"Expansion")
        LS_win.SetCallback(LS_activate_terms)
        LS_win.AddBoolean(LS_use_advection,"Advection")
        LS_win.SetCallback(LS_activate_terms)
        LS_win.AddBoolean(LS_use_smoothing,"Smoothing")
        LS_win.SetCallback(LS_activate_terms)
        LS_win.BeginBook
          global::LS_exp_pid = LS_win.AddPage("Exp")
            LS_win.AddFloat(LS_expansioncoeff,"Weight",0,1)
            LS_win.AddBoolean(LS_use_expansion_image,"Use expansion image")
            LS_win.AddImageChoice(LS_expansion_image_name,"Exp. Image:")
            LS_win.BeginBoxPanel("Intensity-based force")
              LS_win.AddFloat(LS_Imean,"Mean", LS_inputmin,LS_inputmax)
              LS_win.AddFloat(LS_Isd,"StandDev",0,(LS_inputmax-LS_inputmin)/2)
              LS_win.AddFloat(LS_prob_threshold,"Threshold",0,1)
              LS_win.AddBoolean(LS_accept_high_intensity,"Accept high intensities")
            LS_win.EndBoxPanel
  
          global::LS_adv_pid = LS_win.AddPage("Adv")
            LS_win.AddFloat(LS_advcoeff,"Weight",0,1)
    
          global::LS_smo_pid = LS_win.AddPage("Smooth")
            LS_win.AddFloat(LS_curvcoeff,"Weight",0,1)
            LS_smoothtype_id = LS_win.AddEnum(LS_smoothingtype,"Type")
              LS_win.AddEnumChoice(LS_smoothtype_id,"min curv")
              LS_win.AddEnumChoice(LS_smoothtype_id,"mean curv")
            LS_win.AddBoolean(LS_affinecurv,"Affine curv")
    
          global::LS_vel_pid = LS_win.AddPage("Vel")
            LS_win.AddFloat(LS_velcoeff,"Weight",0,1)
  
        LS_win.EndBook
  
      LS_win.AddPage("Band")
        LS_win.BeginBox("Re-Distancing")
            LS_DistType_id = LS_win.AddEnum(LS_NBD_method,"Method")
              LS_win.AddEnumChoice(LS_DistType_id,"Liana")
              LS_win.AddEnumChoice(LS_DistType_id,"Fast Marching")
              LS_win.AddEnumChoice(LS_DistType_id,"Fast Chamfer")
        LS_win.EndBox

      LS_win.AddPage("Evol")
  
        LS_win.BeginBoxPanel("Time")
          LS_win.AddFloat(LS_dt,"dt",0.01,1)
          LS_win.AddFloat(LS_T,"T",0.01,500)
        LS_win.EndBoxPanel
  
        LS_win.BeginBoxPanel("Processing")
          LS_win.AddInt(LS_threads,"Threads",1,10)
          LS_win.BeginHorizontal
            LS_win.AddButton("ReRun",     LS_ReRun)
            LS_win.AddButton("Continue",  LS_Continue)
          LS_win.EndHorizontal
          LS_win.BeginHorizontal
            LS_win.AddButton("Stop",      LS_Stop)
            LS_win.AddButton("Surface",   LS_Surface)
          LS_win.EndHorizontal
        LS_win.EndBoxPanel

        LS_win.BeginBoxPanel("Convergence")
          LS_win.AddBoolean(LS_check_convergence,"Check")
          LS_win.AddInt(LS_conv_freq,"Freq",5,100)
        LS_win.EndBoxPanel
      LS_win.AddPage("Dist")
        LS_win.AddFloat(DTmin,"min",-100,0)
        LS_win.AddFloat(DTmax,"max",0,100)
        LS_win.AddButton("Apply",  LS_ApplyDT)
  
      LS_win.AddPage("Res")
  
        LS_win.BeginBoxPanel("Result filename")
          LS_win.AddString(LS_result_filename,"base name:")
          LS_win.AddString(LS_result_filename_ext,"extension:")
          LS_win.AddBoolean(LS_resname_addtime,"Add evol. time")
          LS_win.AddBoolean(LS_resname_addprob,"Add prob.")
        LS_win.EndBoxPanel
  
        LS_win.BeginBoxPanel("Save")
        LS_win.BeginHorizontal
          LS_win.AddButton("Result",   LS_SaveResult)
        LS_win.EndHorizontal
  
        LS_win.BeginHorizontal
          LS_win.AddButton("Inside model",   LS_SaveInsideModel)
          LS_win.AddButton("Outside model",  LS_SaveOutsideModel)
        LS_win.EndHorizontal
        LS_win.EndBoxPanel
  
  
    LS_win.EndBook
  
    LS_win.AddButton("Close",LS_Close)

    LS_win.update
    LS_win.Display
  }
  
  LS_Init
  if (argc==1) {
    # start with one image
    im     = Image $1
    LS_input_name = "im"
    LS_win.update
  }
  
  if (argc==2) {
    // start with an image and an initialization
    im     = Image $1
    initim = Image $2
    LS_input_name   = "im"
    LS_initial_name = "initim"
    LS_win.update
  }
  
  if (argc==3) {
    # start with an image and an initialization and a threshold
    im     = Image $1
    initim = Image $2
    th = atof($3)
    initim = initim-th
    LS_input_name   = "im"
    LS_initial_name = "initim"
    LS_win.update
  }
} 
# end if (!LS_defined) 