# command line: improcess

#SetDebugOn

if (!exists(LevelSetsClass)){
  func "SyntheticImages/AddSphere.amil"

  Class LevelSetsClass {
  #------------------------------------
    
  //---------------------------------------------------
  proc ::Init(IMAGE _input, IMAGE _init) {
    
      ::class_name  = "global::LevelSetsClass"
      ::input_name   = "","Name of the input image variable"
      ::initial_name = "","Name of the initial level set image variable"
      # 0: for spheres 1: for initial image
      ::init_mode    = INT(0), "Contour initialization mode: spheres or zero-crossing of an image "

      ::inputmin = 0
      ::inputmax = 32000

      ::minimal_intensity = 0, "Minimal Intensity for the input image"

      ::use_expansion = UCHAR(1) ,"Use Expansion Force"
      ::use_advection = UCHAR(1) ,"Use Advection Force"
      ::use_smoothing = UCHAR(1) ,"Use Smoothing Force"
      ::use_velocity  = UCHAR(0) ,"Use Velocity Force"

      ::use_expansion_image = UCHAR(0), "Set expansion force from an image"

      ::expansion_image_name = "Image"

      ::Imean=70, "Estimated mean intensity of the structure to segment"

      ::Isd=50, "Estimated intensity standard deviation of the structure to segment"

      # probability threshold belong which expansion becomes negative
      ::prob_threshold = 0.3, "Expansion force parameter to create negative forces (shrinking force) when the intensity is too distant from the expected intensity based on its mean and standard deviation"

      ::sphere_radius = 3, "Radius in current unit (usually in mm) of the sphere to add"
      ::accept_high_intensity = UCHAR(0) ,"If set to true, will allow the maximal expansion force for any intensity higher the given mean intensity"
      ::expansioncoeff  = 0.5, "Expansion weight in the evolution equation"

      ::dt = 0.5, "Evolution time-step"
      ::T=200, "Total Evolution time"

      ::NBD_method     = INT(2)     // 0:liana s, 1: fast marching 2: fast chamfer
      ::NBD_freq       = INT(6)

      ::check_convergence = UCHAR(1)
      ::conv_freq         = INT(20)

      ::stop = 0,          "Test if the stop button has been pressed"
      # number of threads (not used right now)
      ::threads = INT(2),  "Number of threads used during the evolution (the re-distancing of the narrow band is not multi-threaded)"

      ::advcoeff  = 0.5,   "Advection weight in the PDE"

      ::curvcoeff = 0.5,   "Smoothing weight in the PDE"

      ::smoothingtype = INT(0),\
                            "Smoothing mode: either mean curvature or minimal curvature"
      ::affinecurv    = UCHAR(0),\
                            "Experimental: use of affine curvature"
                         // 0: 2D affine curvature 1: 2D mean curvature

      ::velcoeff  = 0.0

      ::downsamplefactor = INT(1)
      ::downsamplefactor.Comments("Down-sampling factor, unused for the moment")

      #::in_draw.SetIsoContour(0,::inls0,0)
      #::in_draw.DrawIsoContour(0,1)

      ::DTmin = -50
      ::DTmax = 50

      ::result_filename = "LevelSetResult"
      ::result_filename_ext = ".ami.gz"
      ::resname_addtime = UCHAR(1)
      ::resname_addprob = UCHAR(1)

      ::Gui()
  }

    #-----------------------------------------------
    proc ::load_input() {

    eval "::input <<= (FLOAT)"+::input_name+";"
    if (::input_name=="Image") {
      ::input_name = "::input"
      ::win.update
    }

    ::min          = min(::input)
    ::max          = max(::input)
    ::minimal_intensity = ::min
    ::win.update

    show ::input
  }

  #-----------------------------------------------
  proc ::load_initial() {

    if (!exists(::input)) {
      InfoDialog "::load_initial() \t Need to load input image first!"
    } else {
      if (::init_mode==1) {
        eval "::inls <<= (FLOAT)"+::initial_name+";"
        if (::initial_name=="Image") {
          ::initial_name = "::initial_name"
          ::win.update
        }
        ::ComputeIntensityStats
      } else {
        ::inls = ::input*0-1
      }
  
      ::inls0 = ::inls
      ::input_draw.SetIsoContour(1,::inls,0)
      ::input_draw.DrawIsoContour(1,1)
    }
  }
  
 #-----------------------------------------------
  # reads the expansion image
  #
  proc ::load_expansion() \
  {
    eval "::expansion_image <<= (FLOAT)"+::expansion_image_name+";"
    if (::expansion_image_name=="Image") {
      ::expansion_image_name = "::expansion_image"
      ::win.update
    }
  }

  //--------------------------------------------------
  proc ::Init1(IMAGE _input) {
    tmp = ((FLOAT)_input)*0-4
    ::Init(&_input,&tmp)
  }
  
  //--------------------------------------------------
  proc ::Setinput(IMAGE _input) {
    
  
    if (exists(::input_draw)) { del ::input_draw; }
    if (exists(::inls))    { del ::inls; }
    if (exists(::inls0))   { del ::inls0; }
    if (exists(::input))      { del ::input; }
    if (exists(::inls_backup))      { del ::inls_backup; }
  
    ::input = (FLOAT)_input
    show ::input
  
  
    ::inputmin = min(::input)
    ::inputmax = max(::input)
    ::minimal_intensity = ::inputmin
  
    ::inls = (FLOAT)::input*0-10
    ::inls0 = ::inls
  
    ::input_draw.SetIsoContour(1,::inls,0)
    ::input_draw.DrawIsoContour(1,1)
  
  }
  
  #--------------------------
  proc ::SaveParams( STRING filename) \
  {
    pfile = open(filename,"w")
    
    #pfile.printn "#"
    #pfile.printn "# amilab"
    #pfile.printn "#"
    #pfile.printn "# Parameters using for the level set evolution:"
    #pfile.printn "#"
    pfile.printn " "
    #pfile.printn "# Initialization:"
    pfile.printn boost_format("::init_mode = %1%") % ::init_mode
    pfile.printn boost_format("::inputmin  = %1%") % ::inputmin
    pfile.printn boost_format("::inputmax  = %1%") % ::inputmax
    pfile.printn boost_format("::minimal_intensity = %1%") % ::minimal_intensity
    pfile.printn boost_format("::sphere_radius = %1%") % ::sphere_radius
    pfile.printn " "
    #pfile.printn "# Evolution equation:"
    pfile.printn boost_format("::Imean         = %1%") % ::Imean
    pfile.printn boost_format("::Isd           = %1%") % ::Isd
    pfile.printn boost_format("::accept_high_intensity = %1%") % ::accept_high_intensity

    pfile.printn boost_format("::expansion_coeff = %1%") % ::expansioncoeff
    pfile.printn boost_format("::dt              = %1%") % ::dt
    pfile.printn boost_format("::T               = %1%") % ::T

  }
#----------------------------
  proc ::Close() {
    ::win.Hide
    delvars GetObjectName(::Close)
  }
  ::Close.Comments("Will close the interface and delete the corresponding object named '"+GetObjectName(::Close)+"'.")
    
  #----------------------------
  proc ::CloseAll() {
    eval boost_format( "if (exists(%1%)) { del %1%; };" ) % ::class_name 
    ::Close
  }
  ::CloseAll.Comments("Call ::Close() method and delete the class variable")
      
  #------------------------------------
  
   //---------------------------------------------------
  proc ::SetVelocityField( IMAGE vel, NUM coeff ) {
  
    ::velfield = vel
    ::velcoeff = coeff
    ::win.update
  
  }
  
  
  //---------------------------------------------------
  proc ::Reset() {
    if (exists(::inls)) {
      ::inls = -1
    }
    show ::input
  }
  
  
  //---------------------------------------------------
  proc ::ComputeIntensityStats() {
  
    if (exists(::inls)) {
      if (count(::inls>0)>0) {
        ::Imean= mean[::inls>0](::input)
        ::Isd  = mean[::inls>0] ( (::input-::Imean)*(::input-::Imean))
        ::Isd  = sqrt(::Isd)
        printn sprint("mean %f",::Imean)
        printn sprint("sd   %f",::Isd)
      } else  {
        InfoDialog "::ComputeIntensityStats() \n No point within initial level set"
      }
      if (exists(::win)) {
        ::win.update
      }
    } else {
        InfoDialog "::ComputeIntensityStats() \n ::inls not found"
    }
  }
  
  //---------------------------------------------------
  // use median instead of mean
  // to be more robust to outliers
  //
  proc ::ComputeIntensityStatsMedian() {
  
    if (exists(::inls)) {
      if (count(::inls>0)>0) {
        ::Imean= median[::inls>0](::input)
        tmp = (::input-::Imean)*(::input-::Imean)
        ::Isd  = median[::inls>0] ( tmp)
        ::Isd  = sqrt(::Isd)
        printn sprint("median: mean %f",::Imean)
        printn sprint("median: sd   %f",::Isd)
      } else  {
        InfoDialog "::ComputeIntensityStatsMedian() \n No point within initial level set"
      }
      if (exists(::win)) {
        ::win.update
      }
    } else {
        InfoDialog "::ComputeIntensityStatsMedian() \n ::inls not found"
    }
  }
  
  //--------------------------------------------------
  proc ::Run(  NUM graphics) {
  //   -----
  
    // every how many iterations call the graphic events
    ::displ_freq = 8
    it = floor(::T/::dt)+1
  
  
    v_x = ::input.vx
    v_y = ::input.vy
    v_z = ::input.vz
  
    setvoxelsize(::input,  1,1,1)
    setvoxelsize(::inls,1,1,1)
  
    // Parameters:
    //   1. grad threshold
    //   2. iterations
    //   3. attach coeff
    //   4. curvcoeff
    //   5. dt
    //   6. reinitfreq
  
  
    adv_coeff = 0;
    if (::use_advection) {
      adv_coeff = ::advcoeff;
    }
    smo_coeff = 0;
    if (::use_smoothing) {
      smo_coeff = ::curvcoeff;
    }
    //
    LevelSetsCURV.SetParam(0.7,it,adv_coeff,smo_coeff,::dt,::NBD_freq)
    LevelSetsCURV.SetDistMethod(::NBD_method)
    LevelSetsCURV.SetThreads(::threads)
    LevelSetsCURV.SetMeanCurv(::smoothingtype)
    LevelSetsCURV.SetAffineCurv(::affinecurv)
  
    if (exists(::velfield)) {
      LevelSetsCURV.SetVelocity(::velfield,::velcoeff)
    }
  
    print "Compute Expansion Image \n"
  
    print "Mean = "; print ::Imean;
    print " SD = ";  print ::Isd;
    print "\n"
  
    LevelSetsCURV.SetILowTh(::minimal_intensity)

    if (::use_expansion) {
      if (::use_expansion_image) {
        if (!exists(::expansion_image)) {
          ::load_expansion
        }
        LevelSetsCURV.SetExpansionImage(::expansion_image)
      } else {
        LevelSetsCURV.SetNumGaussians(1)
        LevelSetsCURV.SetGaussian(0,::Imean,::Isd)
        LevelSetsCURV.SetProbThreshold(::prob_threshold)
        if (::accept_high_intensity) {
          LevelSetsCURV.SetProbHighTh(::Imean+::Isd)
        }
      } 
      # end else / if (::use_expansion_image)
  
      LevelSetsCURV.SetExpansion(::expansioncoeff)
    } else {
      LevelSetsCURV.SetExpansion(0)
    }
  
    print "Compute Expansion Image OK \n"
  
    LevelSetsCURV.SetBandTube(3,2)
  
    lres = LevelSetsCURV.init(::input,::inls)
  #  lres = LevelSetsCURV.init(::input,900)
  
    if (graphics) {
      show ::input
      // sets the isocontour number 0 to the image 'initial' with threshold 0
      ::input_draw.SetIsoContour(1,::inls,0)
      // sets the isocontour number 0 to be active
      ::input_draw.DrawIsoContour(1,1)
      ::input_draw.SetIsoContour(2,lres,0)
      ::input_draw.DrawIsoContour(2,1)
    }
  
    printn "1"
    LevelSetsCURV.iterate;
    LevelSetsCURV.UpdateResult
    previous_ls = LevelSetsCURV.GetOutput
    printn "2"
  
    k = 0
    SetProgress(0)
    ::stop = 0;
    
    for n=1 to it {
      #print n; print "/"; printn it
      if (!::stop) {
        #print sprint("::T= %0.2f \n",n*::dt)
        LevelSetsCURV.iterate;
        k = k+1
        if (graphics)&&(k==::displ_freq) {
          LevelSetsCURV.UpdateResult
          lres = LevelSetsCURV.GetOutput
          k = 0
          show ::input
          ProcessXEvents(100)
        }
        SetProgress(n/it*100)
        if (::check_convergence) {
          if ((n % ::conv_freq) == 0) {
            # check for convergence
            LevelSetsCURV.UpdateResult
            lres = LevelSetsCURV.GetOutput
            stillmoving = count((previous_ls*lres)<0)
            print "*** Convergence test = "; printn stillmoving
            if (stillmoving==0) { ::stop=1; }
            previous_ls = lres
          }
        }
      } else {
        printn "stopped!"
        n=it+1;
      }
    }
  
    printn "continue commands"
    setvoxelsize( ::input,   v_x, v_y, v_z)
    setvoxelsize( ::inls, v_x, v_y, v_z)
    setvoxelsize( lres,    v_x, v_y, v_z)
  
    // invert before ending to be compatible with input convention
    LevelSetsCURV.UpdateResult
    lres = LevelSetsCURV.GetOutput
    ::inls = -lres;
  
    LevelSetsCURV.end
    SetProgress(0)
  
    ::input_draw.DrawIsoContour(2,0)
  }
  # ::Run()
  
  
  //---------------------------------------------------
  proc ::AddSphere() \
  {
    if (!exists(::inls))        { ::load_initial; }
    if (exists(::input_draw)) {
      _x = ::input_draw.GetXPos
      _y = ::input_draw.GetYPos
      _z = ::input_draw.GetZPos
      printn "cursor is at "
      printn _x
      printn _y
      printn _z
      ::inls_backup = ::inls
      global::AddBrightSphere_mm(&::inls,\
            _x,_y,_z,\
            ::sphere_radius,-1,1)
      ::inls0 = ::inls
      show ::input;
    } else {
      print "We have to show ::input and position de cursor at the sphere center (using mouse middle button) \n"
    }
  }
  
  //---------------------------------------------------
  proc ::Backup() {
    ::inls_backup = ::inls
  }
  
  //---------------------------------------------------
  proc ::Undo() {
      if (exists(::inls_backup)) {
        ::inls = ::inls_backup
      } else {
        print "There is no current backup"
      }
  }
  
  
  //---------------------------------------------------
  proc ::ChangedValues() {
  }
  
  //---------------------------------------------------
  proc ::ApplyDT() {
    ::inls = vtkPropDaniel2(::inls,0,::DTmin,::DTmax)
  }
  
  //---------------------------------------------------
  proc ::ReRun() {
    if (!exists(::input_image)) { ::load_input; }
    if (!exists(::inls))        { ::load_initial; }
    ::inls = ::inls0
    ::Run(1)
    show ::input
  }
  
  //---------------------------------------------------
  proc ::Stop() {
    ::stop = 1
    printn "stopping"
  }
  
  
  //---------------------------------------------------
  proc ::Continue() {
    ::Run(1)
    show ::input
  }
  
  //---------------------------------------------------
  proc ::Surface() {
  
    if (exists(::s0)) {
      if (exists(::s0_draw)) { ::s0_draw -= ::s0; }
      del ::s0
    }
    ::s0 = isosurf(::inls0,0.01)
    if (!exists(::s0_draw)) {
      show ::s0
    } else {
      ::s0_draw += ::s0
    }
    if (exists(::s1)) {
      ::s0_draw -= ::s1
      del ::s1
    }
    ::s1 = isosurf(::inls,0.01)
    ::s0_draw += ::s1
    if (exists(::input_draw)) {
      ::input_draw.setGLwin(::s0_draw)
    }
  
  }
  
  //---------------------------------------------------
  proc ::SaveResult() {
  
    filename=::result_filename-".gz"-".ami";
    if (::resname_addprob) {
      filename = filename + sprint("_mean%0.0f",::Imean) \
                          + sprint("_SD%0.2f",::Isd)
    }
    if (::resname_addtime) {
      filename = filename + sprint("_T%0.0f",::T)
    }
    filename = filename + ::result_filename_ext
    print "saving file "+filename+"\n"
    ::inls.save filename
  }
  
  //---------------------------------------------------
  proc ::SaveInsideModel() {
  }
  
  //---------------------------------------------------
  proc ::SaveOutsideModel() {
  }
  
  //---------------------------------------------------
  proc ::activate_terms() {
    ::win.EnablePanel(::exp_pid,::use_expansion)
    ::win.EnablePanel(::adv_pid,::use_advection)
    ::win.EnablePanel(::smo_pid,::use_smoothing)
  }
  
  //---------------------------------------------------
  proc ::Gui() {
  
  #  ::win = ParamWin("Evolve Active Contours using Level Sets")
    ::win = ParamWin("LevelSets")
    ::win.BeginBook
  
      ::win.AddPage("Init")

        ::win.BeginBoxPanel("Input Image")
          # set the input image
          ::win.BeginHorizontal
            ::win.AddImageChoice(::input_name, "")
            ::win.AddButton("Load",::load_input)
          ::win.EndHorizontal
          ::win.AddFloat(::minimal_intensity,"Min. intensity",::inputmin,::inputmax)
        ::win.EndBoxPanel

        ::win.BeginBoxPanel("Initial Level Set")
          initmode_id = ::win.AddEnum(::init_mode,"Mode")
            ::win.AddEnumChoice(initmode_id,"Manual Spheres")
            ::win.AddEnumChoice(initmode_id,"Initial image")
  
          ::win.BeginBoxPanel("Spheres")
            ::win.BeginHorizontal
              ::win.AddButton("Reset", ::Reset)
              ::win.AddButton("Add",   ::AddSphere)
              ::win.AddButton("Undo",  ::Undo)
              ::win.AddButton("Backup",     ::Backup)
            ::win.EndHorizontal
            ::win.AddFloat(::sphere_radius,"Radius",0.1,10.0)
          ::win.EndBoxPanel

          # set the initial level set image
          ::win.BeginBoxPanel("Initial Image")
            ::win.BeginHorizontal
              ::win.AddImageChoice(::initial_name, "")
              ::win.AddButton("Load",::load_initial)
            ::win.EndHorizontal
          ::win.EndBoxPanel
  
        ::win.EndBoxPanel

        ::win.AddButton("Compute Intensity stats",::ComputeIntensityStats)
  
        ::win.AddInt( ::downsamplefactor,"Downsample", 1, 4)
  
      ::win.AddPage("Param")
        ::win.AddBoolean(::use_expansion,"Expansion")
        ::win.SetCallback(::activate_terms)
        ::win.AddBoolean(::use_advection,"Advection")
        ::win.SetCallback(::activate_terms)
        ::win.AddBoolean(::use_smoothing,"Smoothing")
        ::win.SetCallback(::activate_terms)
        ::win.BeginBook
          ::exp_pid = ::win.AddPage("Exp")
            ::win.AddFloat(::expansioncoeff,"Weight",0,1)
            ::win.AddBoolean(::use_expansion_image,"Use expansion image")
            ::win.AddImageChoice(::expansion_image_name,"Exp. Image:")
            ::win.BeginBoxPanel("Intensity-based force")
              ::win.AddFloat(::Imean,"Mean", ::inputmin,::inputmax)
              ::win.AddFloat(::Isd,"StandDev",0,(::inputmax-::inputmin)/2)
              ::win.AddFloat(::prob_threshold,"Threshold",0,1)
              ::win.AddBoolean(::accept_high_intensity,"Accept high intensities")
            ::win.EndBoxPanel
  
          ::adv_pid = ::win.AddPage("Adv")
            ::win.AddFloat(::advcoeff,"Weight",0,1)
    
          ::smo_pid = ::win.AddPage("Smooth")
            ::win.AddFloat(::curvcoeff,"Weight",0,1)
            ::smoothtype_id = ::win.AddEnum(::smoothingtype,"Type")
              ::win.AddEnumChoice(::smoothtype_id,"min curv")
              ::win.AddEnumChoice(::smoothtype_id,"mean curv")
            ::win.AddBoolean(::affinecurv,"Affine curv")
    
          ::vel_pid = ::win.AddPage("Vel")
            ::win.AddFloat(::velcoeff,"Weight",0,1)
  
        ::win.EndBook
  
      ::win.AddPage("Band")
        ::win.BeginBoxPanel("Re-Distancing")
            ::DistType_id = ::win.AddEnum(::NBD_method,"Method")
              ::win.AddEnumChoice(::DistType_id,"Liana")
              ::win.AddEnumChoice(::DistType_id,"Fast Marching")
              ::win.AddEnumChoice(::DistType_id,"Fast Chamfer")
        ::win.EndBoxPanel

      ::win.AddPage("Evol")
  
        ::win.BeginBoxPanel("Time")
          ::win.AddFloat(::dt,"dt",0.01,1)
          ::win.AddFloat(::T,"T",0.01,500)
        ::win.EndBoxPanel
  
        ::win.BeginBoxPanel("Processing")
          ::win.AddInt(::threads,"Threads",1,10)
          ::win.BeginHorizontal
            ::win.AddButton("ReRun",     ::ReRun)
            ::win.AddButton("Continue",  ::Continue)
          ::win.EndHorizontal
          ::win.BeginHorizontal
            ::win.AddButton("Stop",      ::Stop)
            ::win.AddButton("Surface",   ::Surface)
          ::win.EndHorizontal
        ::win.EndBoxPanel

        ::win.BeginBoxPanel("Convergence")
          ::win.AddBoolean(::check_convergence,"Check")
          ::win.AddInt(::conv_freq,"Freq",5,100)
        ::win.EndBoxPanel
      ::win.AddPage("Dist")
        ::win.AddFloat(::DTmin,"min",-100,0)
        ::win.AddFloat(::DTmax,"max",0,100)
        ::win.AddButton("Apply",  ::ApplyDT)
  
      ::win.AddPage("Res")
  
        ::win.BeginBoxPanel("Result filename")
          ::win.AddString(::result_filename,"base name:")
          ::win.AddString(::result_filename_ext,"extension:")
          ::win.AddBoolean(::resname_addtime,"Add evol. time")
          ::win.AddBoolean(::resname_addprob,"Add prob.")
        ::win.EndBoxPanel
  
        ::win.BeginBoxPanel("Save")
        ::win.BeginHorizontal
          ::win.AddButton("Result",   ::SaveResult)
        ::win.EndHorizontal
  
        ::win.BeginHorizontal
          ::win.AddButton("Inside model",   ::SaveInsideModel)
          ::win.AddButton("Outside model",  ::SaveOutsideModel)
        ::win.EndHorizontal
        ::win.EndBoxPanel
  
  
    ::win.EndBook
  
    ::win.BeginHorizontal
      ::win.AddButton("Close",          ::Close)
      ::win.AddButton("Close All",          ::CloseAll)
    ::win.EndHorizontal  

    ::win.update
    ::win.Display
  }
  ::Init
  
  } #End of class
  
} #End of If

#----------------------------
# Main
#----------------------------

if (!exists(lsobjetct)) {
  LevelSetsClass lsobject
  if (argc==1) {
    # start with one image
    im     = Image $1
    lsobject->input_name = "global::im"
    lsobject->win.update
  }
  
  if (argc==2) {
    // start with an image and an initialization
    im     = Image $1
    initim = Image $2
    lsobject->input_name   = "global::im"
    lsobject->initial_name = "global::initim"
    lsobject->win.update
  }
  
  if (argc==3) {
    # start with an image and an initialization and a threshold
    im     = Image $1
    initim = Image $2
    th = atof($3)
    initim = initim-th
    lsobject->input_name   = "global::im"
    lsobject->initial_name = "global::initim"
    lsobject->win.update
  } 
} else {
InfoDialog "The script seems to be already loaded." 
}
