
#
# based on 3 points, stored in global variables p{1,2,3}{x,y,z}
# and in real coordinates,
# crop the image to contain these points + a given margins in mm (real coord unit)
#

if (!exists(CropImageFromPointsClass)) {

  Class CropImageFromPointsClass \
  {
    ::class_name = "global::CropImageFromPointsClass"
    proc ::CropImageFromPoints( IMAGE input, STRING nameresult, NUM marginxy, NUM marginztop, NUM marginzbot ) \
    {
      // 1. compute min-max for each coordinates
      xmin = input.trx+(input.tx-1)*input.vx
      ymin = input.try+(input.ty-1)*input.vy
      zmin = input.trz+(input.tz-1)*input.vz
      xmax = 0
      ymax = 0
      zmax = 0
      if (global::p1x<xmin) { xmin = global::p1x; }
      if (global::p1x>xmax) { xmax = global::p1x; }
      if (global::p2x<xmin) { xmin = global::p2x; }
      if (global::p2x>xmax) { xmax = global::p2x; }
      if (global::p3x<xmin) { xmin = global::p3x; }
      if (global::p3x>xmax) { xmax = global::p3x; }

      if (global::p1y<ymin) { ymin = global::p1y; }
      if (global::p1y>ymax) { ymax = global::p1y; }
      if (global::p2y<ymin) { ymin = global::p2y; }
      if (global::p2y>ymax) { ymax = global::p2y; }
      if (global::p3y<ymin) { ymin = global::p3y; }
      if (global::p3y>ymax) { ymax = global::p3y; }

      if (global::p1z<zmin) { zmin = global::p1z; }
      if (global::p1z>zmax) { zmax = global::p1z; }
      if (global::p2z<zmin) { zmin = global::p2z; }
      if (global::p2z>zmax) { zmax = global::p2z; }
      if (global::p3z<zmin) { zmin = global::p3z; }
      if (global::p3z>zmax) { zmax = global::p3z; }
      
      # - add margins
      xmin = xmin-marginxy
      xmax = xmax+marginxy
      ymin = ymin-marginxy
      ymax = ymax+marginxy
      zmin = zmin-marginzbot
      zmax = zmax+marginztop

      # -- convert limits to voxel coordinates
      xmin_vox = (xmin-input.trx)/input.vx
      xmax_vox = (xmax-input.trx)/input.vx

      ymin_vox = (ymin-input.try)/input.vy
      ymax_vox = (ymax-input.try)/input.vy

      zmin_vox = (zmin-input.trz)/input.vz
      zmax_vox = (zmax-input.trz)/input.vz

      # -- check that it fits in the image
      if (xmin_vox<0) { xmin_vox = 0; }
      if (xmax_vox>=input.tx) { xmax_vox = input.tx-1; }

      if (ymin_vox<0) { ymin_vox = 0; }
      if (ymax_vox>=input.ty) { ymax_vox = input.ty-1; }

      if (zmin_vox<0) { zmin_vox = 0; }
      if (zmax_vox>=input.tz) { zmax_vox = input.tz-1; }
      
      # -- create the cropped image as a global variable with the given name 
      eval nameresult + " <<= input[xmin_vox:xmax_vox,ymin_vox:ymax_vox,zmin_vox:zmax_vox];"

    }
    
    proc ::Close() \
    {
      delvars GetObjectName(::Close)
    }
    ::Close.Comments("Will close the interface and delete the corresponding object named '"+GetObjectName(::Close)+"'.")
    
    proc ::CloseAll() {
      eval boost_format( "if (exists(%1%)) { del %1%; };" ) % ::class_name 
      ::Close
    }
    ::CloseAll.Comments("Call ::Close() method and delete the class variable")
  }
}
