#!/usr/bin/amilab

#
# Noise Reducing Anisotropic Diffusion
#
# Based on the paper of Yu and Acton: Speckle Reducing Anisotropic Diffusion TIP 2002
# and
# Krissian and Aja-Fernandez TIP 2009
#

# call 
# ::CreateParams( IMAGE)
# and
# ::CreateWindow()
#
# result in ::res
#
# Style Conventions:
#   all variables and functions will start with ::
#   function variables will start with an uppercase character after
#   other variables will start with a lowercase character
#
# ::resultname = $2

if (!exists(AnisoNRADClass)) {

  ami_import->Filters()

  Class AnisoNRADClass {

  #----------------------------
  
  proc ::Init() \
  {
      ::class_name ="global::AnisoNRADClass"
      ::input_name = ""
      # suggested 1/6 in 3D and 1/4 in 2D
      ::dt   = 1.0/6.0, "Time step for the Partial Differential Equation"
      ::t    = 2.0, "Total diffusion time of the equation"

      # 0: Lee, 1: Kuan, 2: Additive, 3: MRI
      ::scalar_mode = INT(3), "Scalar mode: Lee, Kuan, Additive or MRI"

      # 0: Grad, 1: MRI,  2:MRI_NEW 
      ::matrix_mode = INT(2), "Matrix mode: 0:Gradient, 1:MRI or 2:MRI_new"

      ::neighborhood = INT(1), "Size of the neighborhood for local statistics, the window size is (2n+1)^3, where n is the parameter"

      ::sigma = 0.7, "Gaussian convolution standard deviation for computing the local structure"
      # Local Structure 0: princ. curv 1: struct tensor
      ::local_struct = INT(1), "Local Structure mode: either gradient and principal curvature directions, or structure tensor eigenvectors"
      # Eigenvalues mode 0: SUM 1: MAX
      ::eigen_mode = INT(0), "Eigenvalues mode, decides how to combine the diffusions along each line, plane and local volume: either the sum, or the maximum (default is sum)"

      # 0: scalar diffusion, 1: matrix diffusion equation
      ::equation_type = INT(0), "Equation type: 0:scalar or 1:matrix"

      # Scheme, 0: explicit 1: semi-implicit
      ::scheme = INT(1), "Numerical scheme: explicit or semi-implicit"
  
      ::run_on_roi = UCHAR(0), "Run only on the selected region-of-interest"

      ::result_imagename = "global::AnisoNRAD_result"
      ::result_filename = "AnisoNRAD_result.ami.gz"


      ::wiki_help = "http://www.ctm.ulpgc.es/amilab_dokuwiki/dokuwiki/doku.php?id=tutorial-nrad"

      ::html_filename = GetScriptsDir+"/Denoising/AnisoNRAD/Doc/AnisoNRAD_gui/index.html"

      ::CreateWindow()
      # ::ROI 
  }
  
  #----------------------------
  proc ::Close() {
    ::win.HidePanel
    delvars GetObjectName(::Close)
  }
  ::Close.Comments("Will close the interface and delete the corresponding object named '"+GetObjectName(::Close)+"'.")
    
  #----------------------------
  proc ::CloseAll() {
    eval  "if (exists(%1%)) { del %1%; };"  % ::class_name 
    ::Close
  }
  ::CloseAll.Comments("Call ::Close() method and delete the class variable")
    
  #----------------------------
  
  proc ::load_input() {
    if (::input_name=="Image") {
      # read image using browser
      ::input <<== Image
      ::input_name = "::input"
      ::win.Update(-1)
    } else {
      eval "::input <<="+::input_name+";"
    }
  }

  #------------------------------------
  proc ::SetGroundTruth( IMAGE gt, NUM sigma) {
    
  
    ::groundtruth = gt
    ::noisesigma  = sigma
  }
  
  #------------------------------------
  proc ::ComputeMSE( IMAGE res) {
    res1=res*res-2*::noisesigma*::noisesigma
    res1 = sqrt(res1*(res1>0))
    printn sprint("MSE %3.2f \n",mean((res1-::groundtruth)*(res1-::groundtruth)))
  
    res1=res*res-2*::noisesigma*::noisesigma
    res1 = sqrt(res1*(res1>0))
    printn sprint("MSE %3.2f (I>0) \n",mean[::groundtruth>0]((res1-::groundtruth)*(res1-::groundtruth)))
  }
  
  #------------------------------------
  proc ::ReloadInput() \
  {
    if (exists(::input)) {
      delvars "::*_draw"
      if (exists(::roi)) { del ::roi; }
      if (exists(::imbox)) { del ::imbox; }
    }
    ::load_input
    ::Display()
  }
  
  #------------------------------------
  proc ::SetRoiImage( IMAGE _roi) \
  {
    ::roi <<= _roi
  }

  #------------------------------------
  proc ::GetRoi() \
  {
    if (!exists(::input)) {
      ::load_input
      ::Display()
    }
    if (exists(::input_draw)) {
      ::roi <<= ::input[::input_draw]
    }
    ::Display()
  }
  
   #------------------------------------
  proc ::FilterFlux() \
  {
    if (!exists(::input)) {
      ::load_input
    }
    numit = ::t/::dt
    local::input1 = ::input*::input
    if (::run_on_roi) {
      input1 <<= input1[::roi.GetExtent]
    }
  
    if (exists(::NRADfilter)) { del ::NRADfilter; }
    ::NRADfilter = global::filters.AnisoGS()
    # sigma = 0.7
    # threshold = 1 // not used
    # data attachment = 0
    ::NRADfilter.Init(input1,::sigma,1,0)
    ::NRADfilter.Setneighborhood(::neighborhood)
    ::NRADfilter.Setdt(::dt)
    # diffusion coefficient in minimal and maximal curvature directions
    ::NRADfilter.setcoeff(0.5,0.01)
  
    if (::matrix_mode==1) {
      # set Rician Noise Reducing Anisotropic Diffusion and the ROI
      # important here to use reference to the image, otherwise the temporary copy will be automatically deleted !!!
      ::NRADfilter.SetRNRADROI(&::roi)
    }
    if (::matrix_mode==2) {
      # set Rician Noise Reducing Anisotropic Diffusion and the ROI
      # same comment as above
      ::NRADfilter.SetRNRADROI_NEW(&::roi)
    }
  
    ::NRADfilter.SetLocalStruct(::local_struct)
    ::NRADfilter.SetEigenMode(  ::eigen_mode)
  
    # process iterations
    ::res0 <<= ::NRADfilter.GetOutput()
    if (::run_on_roi) {
      ::res <<= ::input
      ::res0 = sqrt(::res0)
      ::res.putimage(::res0)
    } else {
      ::res <<= sqrt(::res0)
    }
  #  show ::res
  #  ::input_draw.compare(::res)
    SetProgress(0)
    InitTime
    for k=1 to numit {
      ::NRADfilter.Iterate
      ::res0 = ::NRADfilter.GetOutput()
      ::res0 = ::res0*(::res0>0)
      if (::run_on_roi) {
        ::res0 = sqrt(::res0)
        ::res.putimage(::res0)
      } else {
        ::res = sqrt(::res0)
      }
      if (exists(::groundtruth)) {
        ComputeMSE(::res);
      }
      SetProgress(k/numit*100)
      show ::res
      ProcessXEvents(50)
    }
    EndTime
    SetProgress(0)
  
  //  ::NRADfilter.end
  //  hide ::res
  }
  
   #------------------------------------
  proc ::Filter() {
    if (!exists(::input)) {
      ::load_input
    }
    if (!exists(::roi)) {
      InfoDialog "Region of Interest not selected taking the full image by default"
      ::roi = ::input
    }

    if (::equation_type==1) {
      ::FilterFlux()
    } else {
      numit = ::t/::dt
      if (::scalar_mode==3) {
          printn "running on squared image"
          local::input1 = ::input*::input
          ::res <<= AnisoNRAD(input1,::scalar_mode,\
                      ::dt,numit,::neighborhood,::roi.GetExtent)
          ::res <<= sqrt(::res)
      } else {
          ::res <<= AnisoNRAD(::input,::scalar_mode,\
                      ::dt,numit,::neighborhood,::roi.GetExtent)
      }
    }
  }
  
  #------------------------------------
  proc ::Display() {
    
    if (!exists(::input)) {
      ::load_input
    }
    if (!exists(::input_draw)) {
      show ::input
    }
    // draw limits of ROI
    if exists(::roi) {
      local::roibox = ::roi*0+1
      ::imbox  <<= ::input*0
      ::imbox.putimage(roibox)
      del roibox
      ::input_draw.SetIsoContour(0,::imbox,0.5)
      ::input_draw.DrawIsoContour(0,1)
      show ::input
    }
    if exists(::res) {
      show ::res
      ::input_draw.compare(::res_draw)
    }
    local_new
  }
  
  proc ::CompareSurfaces(IMAGE i1, IMAGE i2) {
    
      delvars "::*_surf_draw"
      delvars "::*_surf"
      ::input_surf = CreateFlatMesh(i1,0)
      ::res_surf   = CreateFlatMesh(i2,0)
      ::input_surf.ElevateMesh(i1/10)
      ::res_surf.ElevateMesh(i2/10)
      ::input_surf.Normals
      ::res_surf.Normals
      show ::input_surf
      show ::res_surf
      ::input_surf_draw.compare(::res_surf_draw)
  }

  proc ::DisplaySurfaces() {
    if (::input.tz==1) {
      ::CompareSurfaces(&::input,&::res)
    } else {
      if (exists(::input_draw)) {
        InfoDialog "Taking the current slice from input image viewer"
        zpos = ::input_draw.GetZPos
      } else {
        InfoDialog "Taking the middle slice of the image"
        zpos = ::input.tz/2 
      }
      inslice = ::input[:,:,zpos:zpos]
      resslice = ::res[:,:,zpos:zpos]
      ::CompareSurfaces(&inslice,&resslice)
    }
  }
  
  proc ::Save() {
    ::res.save ::result_filename
  }
  ::Save.Comments("Save image to disk.")

  proc ::SaveToImage() {
    eval ::result_imagename+" <<= ::res;"
  }
  ::SaveToImage.Comments("Save to global image variable.")
  
  proc ::new_eq_type() {
    ::win.EnablePanel(::mat_boxid, ::equation_type==1)
    #::win.Enable(::sigma_id, ::equation_type==1)
    #::win.Enable(::matrix_mode_id, ::equation_type==1)
    #::win.Enable(::localstruct_id, ::equation_type==1)
    #::win.Enable(::eigenmode_id, ::equation_type==1)

    ::win.EnablePanel(::scal_boxid,::equation_type!=1)
    #::win.Enable(::scalar_mode_id,::equation_type!=1)
  }
  
  //---------------------------------------------------
  proc ::LaunchWiki() {
    import = &global::ami_import
    wx1 = import->WxFunctions()
    res = wx1->LaunchDefaultBrowser(::wiki_help)
  }
  ::LaunchWiki.Comments("Launch the corresponding wiki tutorial page on the default browser.")

  //---------------------------------------------------
  proc ::HtmlHome() {
    ::html.LoadFile( ::html_filename)
  }
  ::HtmlHome.Comments("Back to the initial page.")

  //---------------------------------------------------
  proc ::HtmlBack() {
    res = ::html.HistoryBack()
  }
  ::HtmlBack.Comments("Back to the previous page.")

  //---------------------------------------------------
  proc ::HtmlForward() {
    res = ::html.HistoryForward()
  }
  ::HtmlForward.Comments("Go to the forward page.")


  #------------------------------------
  proc ::CreateWindow() {
    # parameters window
    import = &global::ami_import;
    ::win = import->ParamPanel("NRAD")

    ::win.BeginBook()
      ::win.AddPage("Param")
        ::win.AddImageChoice( &::input_name, "Input")
        ::win.AddFloat( &::dt,"dt",0.01,1)
        ::win.AddFloat( &::t,"T",0,10)
        
        ::win.AddInt( &::neighborhood,"Neighborhood",0,4)
    
        ::scheme_id       = ::win.AddEnum( &::scheme,"Scheme")
          ::win.AddEnumChoice(::scheme_id,"Explicit")
          ::win.AddEnumChoice(::scheme_id,"Semi-implicit")
        
        ::eq_type_id      = ::win.AddEnum( &::equation_type)
          ::win.AddEnumChoice(::eq_type_id,"Scalar")
          ::win.AddEnumChoice(::eq_type_id,"Matrix")
        ::win.SetCallback( &::new_eq_type)
    
        ::scal_boxid = ::win.BeginBoxPanel("Scalar diffusion parameters")
          ::scalar_mode_id = ::win.AddEnum( &::scalar_mode,"Scalar mode")
            ::win.AddEnumChoice(::scalar_mode_id,"Lee")
            ::win.AddEnumChoice(::scalar_mode_id,"Kuan")
            ::win.AddEnumChoice(::scalar_mode_id,"Additive")
            ::win.AddEnumChoice(::scalar_mode_id,"MRI")
            ::win.AddEnumChoice(::scalar_mode_id,"MRI new")
        ::win.EndBoxPanel

        ::mat_boxid = ::win.BeginBoxPanel("Matrix diffusion parameters")
          ::sigma_id = ::win.AddFloat( &::sigma,"sigma",0.01,10)
          ::matrix_mode_id = ::win.AddEnum( &::matrix_mode,"Matrix mode")
            ::win.AddEnumChoice(::matrix_mode_id,"Grad")
            ::win.AddEnumChoice(::matrix_mode_id,"MRI")
            ::win.AddEnumChoice(::matrix_mode_id,"MRI new")
  
          ::localstruct_id = ::win.AddEnum( &::local_struct,"Local Struct.")
            ::win.AddEnumChoice(::localstruct_id,"Grad & Curv. Dir.")
            ::win.AddEnumChoice(::localstruct_id,"Struct. Tensor")
      
          ::eigenmode_id = ::win.AddEnum( &::eigen_mode,"Eigen mode")
            ::win.AddEnumChoice(::eigenmode_id,"Sum")
            ::win.AddEnumChoice(::eigenmode_id,"Max")
        ::win.EndBoxPanel
        
        ::win.AddPage("Controls")
          ::win.AddBoolean( &::run_on_roi,"Run on ROI")
          ::win.BeginHorizontal
            ::win.AddButton("Reload input", ::ReloadInput)
            ::win.AddButton("Select ROI", ::GetRoi)
            ::win.AddButton("Filter",     ::Filter)
          ::win.EndHorizontal
          ::win.BeginHorizontal
            ::win.AddButton("Display",          ::Display)
            ::win.AddButton("Display Surfaces", ::DisplaySurfaces)
          ::win.EndHorizontal
          ::win.BeginBoxPanel("Result --> disk")
            ::win.AddString(&::result_filename,"Filename")
            ::win.AddButton("Save",       ::Save)
          ::win.EndBoxPanel
          ::win.BeginBoxPanel("Result --> global variable")
            ::win.AddString(&::result_imagename,"Name")
            ::win.AddButton("SaveImage",  ::SaveToImage)
          ::win.EndBoxPanel
        ::win.AddPage("Help")
          ::win.BeginHorizontal
            # make nice wiki button
            wikipng = wx.wxImage(GetScriptsDir+"/Bitmaps/dokuwiki-128.png")
            
            ::win.AddBitmapButton("Wiki", ::LaunchWiki, \
              wx.wxBitmap(wikipng.Scale2(32,32)))
            
            ::win.AddBitmapButton("Home",   ::HtmlHome, \
              wx.wxBitmap(wx.wxImage(GetScriptsDir+"/Icons/png/32x32/Home.png")))
            ::win.AddButton("<--",    ::HtmlBack)
            ::win.AddButton("-->",    ::HtmlForward)
          ::win.EndHorizontal
          # add html widget
          d = ::win.CurrentParent()
          ::html = wx.wxHtmlWindow(&d)
          ::html.LoadFile( ::html_filename)
          ::win.AddWidget(&::html,1)

    ::win.EndBook

    ::win.BeginHorizontal
      ::win.AddButton("Close",          ::Close)
      ::win.AddButton("Close All",          ::CloseAll)
    ::win.EndHorizontal  
    
    ::win.Display
    ::win.Update(-1)
    ::new_eq_type
  }
  
  #------------------------------------
  
  ::Init
  
  }#End of Class

}#End of if

#----------------------------
# Main
#----------------------------

if (!exists(aniNRAD)) {

  AnisoNRADClass aniNRAD  
   
  if (argc>=1) {
    printn "reading image"
    input_arg = Image($1)
    ::input_image = "input_arg"
    ::win.Update(-1)
    #NRAD_CreateParams( input)
    #NRAD_CreateWindow()
  }
} else {
InfoDialog "The script seems to be already loaded." 
}
