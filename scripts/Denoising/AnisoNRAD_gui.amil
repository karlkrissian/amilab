#!/usr/bin/amilab

#
# Noise Reducing Anisotropic Diffusion
#
# Based on the paper of Yu and Acton: Speckle Reducing Anisotropic Diffusion TIP 2002
# and
# Krissian and Aja-Fernandez TIP 2009
#

# call 
# ::CreateParams( IMAGE)
# and
# ::CreateWindow()
#
# result in ::res
#
# Style Conventions:
#   all variables and functions will start with ::
#   function variables will start with an uppercase character after
#   other variables will start with a lowercase character
#
# ::resultname = $2

if (!exists(AnisoNRADClass)) {

  Class AnisoNRADClass {

  #----------------------------
  
  proc ::Init() \
  {
      ::class_name ="global::AnisoNRADClass"
      ::input_name = ""
      # suggested 1/6 in 3D and 1/4 in 2D
      ::dt   = 1.0/6.0, "Time step for the Partial Differential Equation"
      ::t    = 2.0, "Total diffusion time of the equation"

      # 0: Lee, 1: Kuan, 2: Additive, 3: MRI
      ::scalar_mode = INT(3), "Scalar mode: Lee, Kuan, Additive or MRI"

      # 0: Grad, 1: MRI,  2:MRI_NEW 
      ::matrix_mode = INT(2), "Matrix mode: Gradient, MRI or MRI_new"

      ::neighborhood = INT(1), "Size of the neighborhood for local statistics, the window size is (2n+1)^3, where n is the parameter"

      ::sigma = 0.7, "Gaussian convolution standard deviation for computing the local structure"
      # Local Structure 0: princ. curv 1: struct tensor
      ::local_struct = INT(1), "Local Structure mode: either gradient and principal curvature directions, or structure tensor eigenvectors"
      # Eigenvalues mode 0: SUM 1: MAX
      ::eigen_mode = INT(0), "Eigenvalues mode, decides how to combine the diffusions along each line, plane and local volume: either the sum, or the maximum (default is sum)"

      # 0: scalar diffusion, 1: matrix diffusion equation
      ::equation_type = INT(0), "Equation type: scalar or matrix"

      # Scheme, 0: explicit 1: semi-implicit
      ::scheme = INT(1), "Numerical scheme: explicit or semi-implicit"
  
      ::run_on_roi = UCHAR(0), "Run only on the selected region-of-interest"

      ::CreateWindow()
      # ::ROI 
  }
  
  #----------------------------
  proc ::Close() {
    ::win.Hide
    delvars GetObjectName(::Close)
  }
  ::Close.Comments("Will close the interface and delete the corresponding object named '"+GetObjectName(::Close)+"'.")
    
  #----------------------------
  proc ::CloseAll() {
    eval boost_format( "if (exists(%1%)) { del %1%; };" ) % ::class_name 
    ::Close
  }
  ::CloseAll.Comments("Call ::Close() method and delete the class variable")
    
  #----------------------------
  
  proc ::load_input() {
    if (::input_name=="Image") {
      # read image using browser
      ::input <<== Image
      ::input_name = "::input"
      ::win.update
    } else {
      eval "::input <<="+::input_name+";"
    }
  }

  #------------------------------------
  proc ::SetGroundTruth( IMAGE gt, NUM sigma) {
    
  
    ::groundtruth = gt
    ::noisesigma  = sigma
  }
  
  #------------------------------------
  proc ::ComputeMSE( IMAGE res) {
    res1=res*res-2*::noisesigma*::noisesigma
    res1 = sqrt(res1*(res1>0))
    printn sprint("MSE %3.2f \n",mean((res1-::groundtruth)*(res1-::groundtruth)))
  
    res1=res*res-2*::noisesigma*::noisesigma
    res1 = sqrt(res1*(res1>0))
    printn sprint("MSE %3.2f (I>0) \n",mean[::groundtruth>0]((res1-::groundtruth)*(res1-::groundtruth)))
  }
  
  #------------------------------------
  proc ::ReloadInput() \
  {
    if (exists(::input)) {
      delvars "::*_draw"
      del ::roi
      del ::imbox
    }
    ::load_input
    ::Display()
  }
  
  #------------------------------------
  proc ::GetRoi() \
  {
    if (!exists(::input)) {
      ::load_input
      ::Display()
    }
    if (exists(::input_draw)) {
      ::roi <<= ::input[::input_draw]
    }
    ::Display()
  }
  
   #------------------------------------
  proc ::FilterFlux() \
  {
    if (!exists(::input)) {
      ::load_input
    }
    numit = ::t/::dt
    local::input1 = ::input*::input
    if (::run_on_roi) {
      input1 <<= input1[::roi]
    }
  
    # sigma = 0.7
    # threshold = 1 // not used
    # data attachment = 0
    AnisoGS.init(input1,::sigma,1,0)
    AnisoGS.Setneighborhood(::neighborhood)
    AnisoGS.Setdt(::dt)
    # diffusion coefficient in minimal and maximal curvature directions
    AnisoGS.setcoeff(0.5,0.01)
  
    if (::matrix_mode==1) {
      # set Rician Noise Reducing Anisotropic Diffusion and the ROI
      AnisoGS.SetRNRADROI(::roi)
    }
    if (::matrix_mode==2) {
      # set Rician Noise Reducing Anisotropic Diffusion and the ROI
      AnisoGS.SetRNRADROI_NEW(::roi)
    }
  
    AnisoGS.SetLocalStruct(::local_struct)
    AnisoGS.SetEigenMode(  ::eigen_mode)
  
    # process iterations
    ::res0 = AnisoGS.GetOutput
    if (::run_on_roi) {
      ::res <<= ::input
      ::res0 = sqrt(::res0)
      ::res.putimage(::res0)
    } else {
      ::res <<= sqrt(::res0)
    }
  #  show ::res
  #  ::input_draw.compare(::res)
    SetProgress(0)
    InitTime
    for k=1 to numit {
      AnisoGS.iterate
      ::res0 = AnisoGS.GetOutput
      ::res0 = ::res0*(::res0>0)
      if (::run_on_roi) {
        ::res0 = sqrt(::res0)
        ::res.putimage(::res0)
      } else {
        ::res = sqrt(::res0)
      }
      if (exists(::groundtruth)) {
        ComputeMSE(::res);
      }
      SetProgress(k/numit*100)
      show ::res
      ProcessXEvents(50)
    }
    EndTime
  
  //  AnisoGS.end
  //  hide ::res
  }
  
   #------------------------------------
  proc ::Filter() {
    if (!exists(::input)) {
      ::load_input
    }
    if (!exists(::roi)) {
      InfoDialog "Region of Interest not selected taking the full image by default"
      ::roi = ::input
    }

    if (::equation_type==1) {
      ::FilterFlux()
    } else {
      numit = ::t/::dt
      if (::scalar_mode==3) {
          printn "running on squared image"
          local::input1 = ::input*::input
          ::res = AnisoNRAD(input1,::scalar_mode,\
                      ::dt,numit,::neighborhood,::roi)
          ::res = sqrt(::res)
      } else {
          ::res = AnisoNRAD(::input,::scalar_mode,\
                      ::dt,numit,::neighborhood,::roi)
      }
    }
  }
  
  #------------------------------------
  proc ::Display() {
    
    if (!exists(::input)) {
      ::load_input
    }
    if (!exists(::input_draw)) {
      show ::input
    }
    // draw limits of ROI
    if exists(::roi) {
      local::roibox = ::roi*0+1
      ::imbox  <<= ::input*0
      ::imbox.putimage(roibox)
      del roibox
      ::input_draw.SetIsoContour(0,::imbox,0.5)
      ::input_draw.DrawIsoContour(0,1)
      show ::input
    }
    if exists(::res) {
      show ::res
      ::input_draw.compare(::res_draw)
    }
    local_new
  }
  
  proc ::CompareSurfaces(IMAGE i1, IMAGE i2) {
    
      delvars "::*_surf_draw"
      delvars "::*_surf"
      ::input_surf = CreateFlatMesh(i1,0)
      ::res_surf   = CreateFlatMesh(i2,0)
      ::input_surf.ElevateMesh(i1/10)
      ::res_surf.ElevateMesh(i2/10)
      ::input_surf.Normals
      ::res_surf.Normals
      show ::input_surf
      show ::res_surf
      ::input_surf_draw.compare(::res_surf_draw)
  }

  proc ::DisplaySurfaces() {
    if (::input.tz==1) {
      ::CompareSurfaces(&::input,&::res)
    } else {
      if (exists(::input_draw)) {
        InfoDialog "Taking the current slice from input image viewer"
        zpos = ::input_draw.GetZPos
      } else {
        InfoDialog "Taking the middle slice of the image"
        zpos = ::input.tz/2 
      }
      inslice = ::input[:,:,zpos:zpos]
      resslice = ::res[:,:,zpos:zpos]
      ::CompareSurfaces(&inslice,&resslice)
    }
  }
  
  proc ::Save() {
    ::res.save "::result.ami.gz"
  }
  
  proc ::new_eq_type() {
    ::win.EnablePanel(::mat_boxid, ::equation_type==1)
    #::win.Enable(::sigma_id, ::equation_type==1)
    #::win.Enable(::matrix_mode_id, ::equation_type==1)
    #::win.Enable(::localstruct_id, ::equation_type==1)
    #::win.Enable(::eigenmode_id, ::equation_type==1)

    ::win.EnablePanel(::scal_boxid,::equation_type!=1)
    #::win.Enable(::scalar_mode_id,::equation_type!=1)
  }
  
  #------------------------------------
  
  proc ::CreateWindow() {
    # parameters window
    ::win = ParamWin("NRAD")

    ::win.BeginBook
      ::win.AddPage("Param")
        ::win.AddImageChoice(::input_name, "Input")
        ::win.AddFloat(::dt,"dt",0.01,10)
        ::win.AddFloat(::t,"T",0,100)
        
        ::win.AddInt(::neighborhood,"Neighborhood",0,4)
    
        ::scheme_id       = ::win.AddEnum(::scheme,"Scheme")
          ::win.AddEnumChoice(::scheme_id,"Explicit")
          ::win.AddEnumChoice(::scheme_id,"Semi-implicit")
        
        ::eq_type_id      = ::win.AddEnum(::equation_type)
          ::win.AddEnumChoice(::eq_type_id,"Scalar")
          ::win.AddEnumChoice(::eq_type_id,"Matrix")
        ::win.SetCallback(::new_eq_type)
    
        ::scal_boxid = ::win.BeginBoxPanel("Scalar diffusion parameters")
          ::scalar_mode_id = ::win.AddEnum(::scalar_mode,"Scalar mode")
            ::win.AddEnumChoice(::scalar_mode_id,"Lee")
            ::win.AddEnumChoice(::scalar_mode_id,"Kuan")
            ::win.AddEnumChoice(::scalar_mode_id,"Additive")
            ::win.AddEnumChoice(::scalar_mode_id,"MRI")
            ::win.AddEnumChoice(::scalar_mode_id,"MRI new")
        ::win.EndBoxPanel

        ::mat_boxid = ::win.BeginBoxPanel("Matrix diffusion parameters")
          ::sigma_id = ::win.AddFloat(::sigma,"sigma",0.01,10)
          ::matrix_mode_id = ::win.AddEnum(::matrix_mode,"Matrix mode")
            ::win.AddEnumChoice(::matrix_mode_id,"Grad")
            ::win.AddEnumChoice(::matrix_mode_id,"MRI")
            ::win.AddEnumChoice(::matrix_mode_id,"MRI new")
  
          ::localstruct_id = ::win.AddEnum(::local_struct,"Local Struct.")
            ::win.AddEnumChoice(::localstruct_id,"Grad & Curv. Dir.")
            ::win.AddEnumChoice(::localstruct_id,"Struct. Tensor")
      
          ::eigenmode_id = ::win.AddEnum(::eigen_mode,"Eigen mode")
            ::win.AddEnumChoice(::eigenmode_id,"Sum")
            ::win.AddEnumChoice(::eigenmode_id,"Max")
        ::win.EndBoxPanel
        
        ::win.AddPage("Controls")
          ::win.AddBoolean(::run_on_roi,"Run on ROI")
          ::win.BeginHorizontal
            ::win.AddButton("Reload input", ::ReloadInput)
            ::win.AddButton("Select ROI", ::GetRoi)
            ::win.AddButton("Filter",     ::Filter)
          ::win.EndHorizontal
          ::win.BeginHorizontal
            ::win.AddButton("Display",    ::Display)
            ::win.AddButton("Display Surfaces",  ::DisplaySurfaces)
            ::win.AddButton("Save",       ::Save)
          ::win.EndHorizontal

    ::win.EndBook

    ::win.BeginHorizontal
      ::win.AddButton("Close",          ::Close)
      ::win.AddButton("Close All",          ::CloseAll)
    ::win.EndHorizontal  
    
    ::win.CreateWin
    ::win.Display
    ::win.update
    ::new_eq_type
  }
  
  #------------------------------------
  
  ::Init
  
  }#End of Class

}#End of if

#----------------------------
# Main
#----------------------------

if (!exists(aniNRAD)) {

  AnisoNRADClass aniNRAD  
   
  if (argc>=1) {
    printn "reading image"
    input_arg = Image($1)
    ::input_image = "input_arg"
    ::win.update
    #NRAD_CreateParams( input)
    #NRAD_CreateWindow()
  }
} else {
InfoDialog "The script seems to be already loaded." 
}
