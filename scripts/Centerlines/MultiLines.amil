#!/home/karl/projects/bin/OS/improcess

#
# multiscale analysis for detecting 3D centerlines
#
# parameters:
#
# param 1: input image
# param 2: output image
# param 3: minimal radius
# param 4: maximal radius
# param 5: number of radii
#
#

#
# set gamma and theta
#

#
# To do: local extrema,
#        radius image ...
#

#SetDebugOn
# no interface here
if (!exists(MultilinesClass)) {

  ami_import->Filters()
  if (argc==1) {
    inputname=$1
    emptyargs
  } else {
    inputname = ""
  }
  
  Class MultilinesClass {

    ::filters=&global::filters

    #----------------------------
    proc ::Init() {
      ::class_name = "global::MultilinesClass"
      ::input_name   = "", "Input image name"
      ::mask_name    = "", "Mask of the pixels to process, this image must be of type UCHAR and the values > 127 are considered part of the mask"

      # circle integration
      # a value of 0 desactivates the SD feature
      # should better create a boolean variable here for clarity
      ::use_SD       = UCHAR(0), "Take into account standard deviation of boundary information along the integration circle"
      ::SD_th        = 2, "Standard Deviation Coefficient to weight the response function"
      # a value of 0 desactivates the EXC feature
      ::use_EXC      = UCHAR(0), "Take into account the excentricity of the boundary vectors along the integration circle"
      ::EXC_th       = 5, "Excentricity coefficient to weight the response function"
      ::pairs_mode   = INT(0)
      ::keephighest  = 100

      # multiscale evolution
      ::radmin       = 0.5
      ::radmax       = 5
      ::numrad       = INT(5)

      # Compute local maxima
      ::local_maxima      = UCHAR(0), "Compute local maxima"

      ::keep_orientations = UCHAR(0), "Keep orientations image"
      ::keep_radii        = UCHAR(0), "Keep radii image"

      # 0: Hessian Matrix 1: Structure Tensor
      ::mode         = INT(0)

      # normalization
      ::gamma           = 1
      ::theta           = sqrt(3)
      # this coefficient is recomputed at each scale
      ::rad2sigma_coeff = 1

      # Progress information
      ::current_progress = 0;
      ::current_step     = 0;

      ::output_name="Multilines-maxresponse.ami.gz"

      ::Gui()
    }
  #----------------------------
    proc ::Close() {
      ::win.Hide
      delvars GetObjectName(::Close)
    }
    ::Close.Comments("Will close the interface and delete the corresponding object named '"+GetObjectName(::Close)+"'.")
    
    #----------------------------
    proc ::CloseAll() {
      eval boost_format( "if (exists(%1%)) { del %1%; };" ) % ::class_name 
      ::Close
    }
    ::CloseAll.Comments("Call ::Close() method and delete the class variable")
        
    #------------------------------------
    proc ::load_input() {  
      eval "::input <<= (FLOAT)"+::input_name+";"
      if (::input_name=="Image") {
        ::input_name = "ML_input"
      }
    
      if (::mask_name=="Image") {
        ::mask <<= (UCHAR) ((::input>0.1)*255)
        ::mask_name = "ML_mask"
      } else {
        eval "::mask <<="+::mask_name+";"
      }
      ::win.update
    }
    
    #-----------------------------------------------
    proc ::SetMask( IMAGE mask) \
    {
      ::mask <<= (UCHAR) (mask>0.1)*255
    }
    
    #--------------------------------------------------
    proc ::h(NUM gamma, NUM theta, NUM res) {
    #    ----
      tmp1=2*(gamma-1)
      theta2 = theta*theta
      tmp2=theta2-tmp1
      tmp2=tmp2*tmp2
      delta = tmp2+16-tmp1*tmp1
      res= sqrt((sqrt(delta)+tmp1-theta2)/(2*(3-gamma)))
    }
    
    #--------------------------------------------------
    proc ::rad2sigma(NUM rad, NUM sigma) {
    #    ------------
      sigma=::rad2sigma_coeff*rad
    }
    
    #--------------------------------------------------
    proc ::ComputeResponse(NUM sigma, IMAGE _response,  IMAGE _v1, IMAGE _v2, IMAGE _v3) \
    {
    #    ---------------
      printn "ML_ComputeResponse"
    
      _response.initvalue(0)
    
      // Computation of the direction
      // the results are 
      // _input_Hvep1, _input_Hvep2, _input_Hvep3
      // _input_Hvap1, _input_Hvap2, _input_Hvap3
      //
      // 1. Gamma normalized with the coefficient _gamma
      // 2. the eigenvalues are arranged into descending order of absolute values
      //
    
      // Old way: HessianMatrix(_input,sigma,_gamma)
      //
      // 2,2,0,1 means:
      // 3: 1st eigenvector & eigenvalue
      // 3: 2st eigenvector & eigenvalue
      // 0: don't need the third eigen(vector/value)
      // 1: gradient vector
      //
    
    
      if (::mode==0) {
        Derivatives(::input,sigma,::gamma,3,3,1,1,::mask)
        vap1 = _input_Hvap1
        vap2 = _input_Hvap2
        _v1  = _input_Hvep1
        _v2  = _input_Hvep2
        _v3  = _input_Hvep3
        del _input_Hvap1
        del _input_Hvap2
        del _input_Hvep1
        del _input_Hvep2
    
        // create a region of interest
        _mask1 = (UCHAR) ((::mask>0)*(vap1<0)*(vap2<0)*255)
    
        del vap1
        del vap2
    
      }  else {
    
        // Compute Structure Tensor
        printn "Structure Tensor"
    
        StructTensorH(::input,sigma,1,::mask,1)
        _v1  = _input_STHvep1
        _v2  = _input_STHvep2    
        _v3  = _input_STHvep3
        _input_grad = _input_STHgrad
        del _input_STHvap1
        del _input_STHvap2
        del _input_STHvap3
        del _input_STHvep1
        del _input_STHvep2
        del _input_STHvep3
        del _input_STHgrad
    
        _mask1 = ::mask
      }
    
      // run the circle integration on a region of interest
      // Integrate the border information on a circle of radius theta*sigma
      _response = CircleInt( _input_grad, _v1, _v2, ::theta*sigma, _mask1)
      // _response   = CircleIntSdExc( _input_grad,_v1,_v2,_theta*sigma,_mask1,1,1.5)
    
    
    } // ML_ComputeResponse
    
    proc ML_ComputeResponse_new( NUM sigma, IMAGE _response) {
      printn "ML_ComputeResponse_new"
    
      _response.initvalue(0)
    
      // Computation of the direction
      // the results are 
      //
      // 1. Gamma normalized with the coefficient _gamma
      // 2. the eigenvalues are arranged into descending order of absolute values
      //
    
      // Compute Structure Tensor
      printn "Structure Tensor"
      sth = ::filters->StructureTensorH(&::input,sigma,1,&::mask)
    
      SetProgress(::current_progress+::current_step*0.25)
    
      # EigenDecomp, parameters:  the structure tensor,
      # the eigenvalues flag: 0
      # the eigenvectors flag 3
      eig = ::filters->EigenDecomp(&sth,0,3,&::mask)
      SetProgress(::current_progress+::current_step*0.5)
      del sth
    
      # do we get the gradient separately to avoid the mask here??
      grad = gradient(::input,sigma)
      SetProgress(::current_progress+::current_step*0.75)
    
      // create a region of interest
      //_mask1 = (UCHAR) ((_mask>0)*(vap1<0)*(vap2<0)*255)
    
    
      _response = CircleMinIntSdExc(grad,\
                          eig[3],\
                          eig[4],\
                          ::theta*sigma, \
                          ::mask,\
                          ::SD_th*::use_SD,\
                          ::EXC_th*::use_EXC, \
                          ::pairs_mode, \
                          ::keephighest)
    
      // run the circle integration on a region of interest
      // Integrate the border information on a circle of radius theta*sigma
    
      // Error: I did not comment this line for the challenge !!!!
      //_response = CircleInt( grad, eig[3], eig[4],\
      //                        _theta*sigma, _mask)
    
      if (::local_maxima) {
        # copy the 2 eigenvectors
        global::::current_v1 <<= eig[3]
        global::::current_v2 <<= eig[4]
      }
    
    } // ML_ComputeResponse_new
    #--------------------------------------------------
    #
    # mode is 0: use Hessian matrix
    # mode is 1: use Structure tensor
    #
    proc ::MultiLines( ) \
    {
      InitTime

      #  Load input images
      ::load_input()

      # Precompute coefficient of proportionality
      ::h(::gamma,::theta,&::rad2sigma_coeff)
    
      ::current_rad=::radmin
    
      ::current_sigma=0
      if (::numrad>1) {
        _step=exp((ln(::radmax)-ln(::radmin))/(::numrad-1))
      } else {
        _step = 1
      }
    
      #
      # main loop 
      #
    
      response=Image(FLOAT,1,::input)
      response.initvalue(0)
    
      v1=Image(FLOAT,3,::input)
      v1.initvalue(0,0,0)
      v2=Image(FLOAT,3,::input)
      v2.initvalue(0,0,0)
      v3=Image(FLOAT,3,::input)
      v3.initvalue(0,0,0)
    
      for _i=0 to ::numrad-1 {
    
        print "----------\n"
        print "iteration ";print _i; print "\n"
        print "----------\n"
    
        ::rad2sigma(rad,&::current_sigma)
      
        ::ComputeResponse( ::current_sigma, \
                            ::input,\
                            ::gamma,::theta,\
                            &response, \
                            &v1, &v2,&v3,\
                            ::mask, \
                            ::mode)
    
        // save response to file
        #response_filename=result.GetName-".gz"-".inr"-".ami"-".vtk"
        #response_filename = "multilines"
        #response_filename = sprint("rep%02.0f.ami.gz",_i)
        #response.save response_filename
        #response.save sprint("rep%02.0f.ami.gz",_i)
    
    
        // Compute and Update Local Maxima
        print "Compute and Update Local Maxima\n"
    
        // keep maximal response
        if (_i==0) {
          max_response=response
          prev_response=response
          maxima = response*0
          ::maxima = response*0
          v1_max=v1
          v2_max=v2
          v3_max=v3
          radius = (response>0)*rad;
        } else {
    
          // Update the maxima
          // only keep the first maxima found
          ::maxima = (::maxima!=0)*::maxima+(::maxima==0)*(maxima>response)*maxima
    
          v1_max = v1_max*(max_response>=response)+v1*(max_response<response)
          v2_max = v2_max*(max_response>=response)+v2*(max_response<response)
          v3_max = v3_max*(max_response>=response)+v3*(max_response<response)
          radius = (max_response>=response)*radius+(max_response<response)*rad
          max_response=max(response,max_response)
          // Compute local maxima
          maxima = LocalExtrema(response,v1,v2,_mask)
          maxima = maxima*(response>prev_response)
          
        }
    
    
        ::current_rad = ::current_rad*_step
      }
    
      
      v3_max.save sprint("v3_max_%01.0f.ami.gz",mode)
    #  v2_max.save sprint("v2_max_%01.0f.ami.gz",mode)
    
      # computing local maxima on the maximum response accross scales
      real_maxima2 = LocalExtrema(max_response,v1_max,v2_max,::mask)
    
      # save maximal response to file
      result    = max_response
      maxresult = real_maxima2
      radii     = radius
    
      EndTime
    } 
    # end MultiLines()
    #--------------------------------------------------
    #
    # mode is 0: use Hessian matrix
    # mode is 1: use Structure tensor
    #
    proc ::MultiLines_new( ) \
    {
      current_proc = "ML_MultiLines_new()"
      if (!exists(::SD_th)) {
        InfoDialog "MultiLines_new Multilines not initialized"
      }

      # TODO: adapt for ROI
      InitTime

      #  Load input images
      ::load_input()

      # Precompute coefficient of proportionality
      ::h(::gamma,::theta,&::rad2sigma_coeff)
    
      ::current_rad   = ::radmin
      ::current_sigma = 0

      if (::numrad>1) {
        _step=exp((ln(::radmax)-ln(::radmin))/(::numrad-1))
      } else {
        _step = 1
      }
    
      #
      # main loop 
      #
      response=Image(FLOAT,1,::input)
      response.initvalue(0)
    
      for local::i=0 to ::numrad-1 {
        iteration_mess = boost_format(" Iteration %1%") % i
        SetStatusText( current_proc+iteration_mess )
        ::current_progress = i/::numrad*100
        ::current_step     = 1/::numrad*100
        SetProgress(::current_progress)
    
    
        ::rad2sigma(::current_rad,&::current_sigma)
    
        printn sprint(" radius = %0.2f",::current_rad)
        printn sprint(" sigma = %0.2f", ::current_sigma)
    
        ::ComputeResponse_new(::current_sigma, &response)
    
        // Compute and Update Local Maxima
        SetStatusText( iteration_mess + \
                        "Compute and Update Local Maxima")
    
        # keep maximal response
        if (i==0) {
          max_response=response
          if (::local_maxima) {
            # 3 more images in memory
            prev_response=response
            maxima = response*0
            ::maxima <<= response*0
            if (::keep_orientations) {
              # check how to get the vectors here, or keep the symmetric matric??
              #v1_max=v1
              #v2_max=v2
              #v3_max=v3
            }
            if (::keep_radii) {
              radius = (response>0)*::current_rad;
            }
          }
        } else {
          max_response=max(response,max_response)

          if (::local_maxima) {
            # Update the maxima
            # only keep the first maxima found
            ::maxima = (::maxima!=0)*::maxima+(::maxima==0)*(maxima>response)*maxima
            if (::keep_orientations) {
              # to do
              #v1_max = v1_max*(max_response>=response)+v1*(max_response<response)
              #v2_max = v2_max*(max_response>=response)+v2*(max_response<response)
              #v3_max = v3_max*(max_response>=response)+v3*(max_response<response)
            }
            if (::keep_radii) {
              radius = (max_response>=response)*radius+(max_response<response)*rad
            }
            # Compute local maxima
            maxima = LocalExtrema(response,::current_v1,::current_v2,::mask)
            maxima = maxima*(response>prev_response)
          } 
          # end if (::local_maxima)
        }
    
        ::current_rad = ::current_rad*_step
        SetProgress(i/::numrad*100)
      }

      # free memory from global images used for the computation
      if (::local_maxima) {
        del ::current_v1
        del ::current_v2
      }

      # set the result image
      ::result <<= max_response

      SetProgress(0)
      SetStatusText( "Finished MultiLines_new" )
      EndTime
    } // MultiLines_new
    #-----------------------------------------------
    proc ::CB_ROI() {
      global
      if (exists(::input_draw)) {
        ::roi <<= ::input[::input_draw]
        ::roi_contour = (UCHAR) ::input*0
        ::roi = 1
        ::roi_contour.putimage(::roi)
        ::Display()
      }
    }

    #-----------------------------------------------
    proc ::Display() {
      show ::input
      if (exists(::result)) {
        ::input_draw.compare(::result)
      }
      if (exists(::roi_contour)) {
        ::input_draw.SetIsoContour(0,::roi_contour,0.5)
        ::input_draw.DrawIsoContour(0,1)
      }
    }
    
    #-----------------------------------------------
    proc ::Save() {
      ::result.save ::output_name
    }
    #-----------------------------------------------
    proc ::Gui() \
    {
      ::win = ParamWin("MultiLines")
    
      ::win.BeginBook
        ::win.AddPage("Main")
          # set the input image
          ::win.AddImageChoice(::input_name, "Input")
          # set the mask image
          ::win.AddImageChoice(::mask_name, "Mask")
        

          modeid = ::win.AddEnum(::mode)
            ::win.AddEnumChoice(modeid,"Hessian Matrix")
            ::win.AddEnumChoice(modeid,"Structure Tensor")

          ::win.BeginBoxPanel("Controls")
            ::win.BeginHorizontal
              ::win.AddButton("Select ROI", ::CB_ROI)
              ::win.AddButton("Run",        ::MultiLines)
              ::win.AddButton("Run new",    ::MultiLines_new)
            ::win.EndHorizontal
            ::outputname_id = ::win.AddString(  ::output_name, "Output")
            ::win.BeginHorizontal
                display_id = ::win.AddButton("Display",    ::Display)
                display_id = ::win.AddButton("Save",       ::Save)
            ::win.EndHorizontal
          ::win.EndBoxPanel
        ::win.AddPage("Circle")

          ::win.AddBoolean(::use_SD,"Use StdDev")
          ::win.AddFloat(::SD_th,"StdDev_thres", 0,10)
          ::win.AddBoolean(::use_EXC,"Use Exc")
          ::win.AddFloat(::EXC_th,"Exc_thres",0,10)
          pairmodeid = ::win.AddEnum(::pairs_mode)
            ::win.AddEnumChoice(pairmodeid,"Min")
            ::win.AddEnumChoice(pairmodeid,"Max")
            ::win.AddEnumChoice(pairmodeid,"Mean")
          ::win.AddFloat(::keephighest,0,100)

        ::win.AddPage("Scales")
          ::win.BeginBoxPanel("Radii (or scales)")
            ::win.AddFloat(::radmin,"min.",0.01,10)
            ::win.AddFloat(::radmax,"max.",0.01,10)
            ::win.AddInt(  ::numrad,"number",1,20)
          ::win.EndBoxPanel
        
          ::win.AddBoolean(::local_maxima,"Local maxima")
          ::win.AddBoolean(::keep_orientations,"Orientations")
          ::win.AddBoolean(::keep_radii,"Radii")


      ::win.EndBook
    
      ::win.BeginHorizontal
        ::win.AddButton("Close",      ::Close)
        ::win.AddButton("Close All",  ::CloseAll)
      ::win.EndHorizontal
    
    
      ::win.update
      ::win.Display
    }
    
    ::Init
    
    #if (inputname != "") {
     # in = Image(inputname)
     # ::input_name = "in"
     # ::win.update
    #}
  
  } #End of class
  
} # End of if

#----------------------------
# Main
#----------------------------

if (!exists(multiobj)) {

  MultilinesClass multiobj
} else {
  InfoDialog "The script seems to be already loaded."
}
      