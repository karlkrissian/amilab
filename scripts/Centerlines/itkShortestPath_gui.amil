#
# Find Shortest path between 2 points
# using a speed image
#
if (!exists(itkSPClass)) {
  func "SyntheticImages/AddSphere.amil"
  ami_import->ITK()
  
  Class itkSPClass {
    global::AddSphereClass ::AS
    ::class_name = "global::itkSPClass"
    ::itk=&global::itk
      
    #----------------------------
    proc ::init() {
      # input image name
      ::input_name = ""
      # speed image name
      ::speed_name = ""

      # save the Fast Marching image
      ::save_FM = UCHAR(0)

      ::epsilon = 0.02
      ::maxcost = 1000
    
      ::use_input_speed = UCHAR(0)
      ::input_Imin  = 0
      ::input_Imax  = 1000
      ::input_speed = 1

      # start point
      ::startx = 0
      ::starty = 0
      ::startz = 0

      # stop mode -- 0: point, 1: mask
      ::end_mode = INT(0) 

      ::endmask_name = ""
      # end point
      ::endx = 0
      ::endy = 0
      ::endz = 0
    
      ::step_size = 0.1
      ::maxlength = 500
      ::delta = 0.05
    
      #::Gui
    }
    #-----------------------------------------------
    proc ::load_input() \
    {
      eval "::input <<="+::input_name+";"
      if (::input_name=="Image") {
        ::input_name = "SP_input"
        ::win.Update(-1)
      }
    }
    
    proc ::load_speed() \
    {
      eval "::speed <<="+::speed_name+";"
      if (::speed_name=="Speed") {
        ::speed_name = "SP_speed"
        ::win.Update(-1)
      }
    }
    
    proc ::set_input( IMAGE im) \
    {
      ::input <<= im
    }
    
    proc ::set_speed( IMAGE im) \
    {
      ::speed <<= im
    }
    
    proc ::set_endmask( IMAGE im) \
    {
      ::endmask <<= im
    }
    
    #-----------------------------------------------
    proc ::StartPoint() \
    {
      ::load_input
      show ::input
      if (exists(::input_draw)) {
        ::SetStartPoint( \
                          ::input_draw.GetXPos, \
                          ::input_draw.GetYPos, \
                          ::input_draw.GetZPos \
                        )
      }
    }
    #-----------------------------------------------
    proc ::SetStartPoint( NUM x, NUM y, NUM z) \
    {
      ::startx = x
      ::starty = y
      ::startz = z
      ::Px1 = ::input.trx + x*::input.vx
      ::Py1 = ::input.try + y*::input.vy
      ::Pz1 = ::input.trz + z*::input.vz
    }
    
    
    #-----------------------------------------------
    proc ::SetStartPointWorld( NUM x, NUM y, NUM z) \
    {
      ::Px1 = x
      ::Py1 = y
      ::Pz1 = z
      ::startx = (x-::input.trx)/::input.vx
      ::starty = (y-::input.try)/::input.vy
      ::startz = (z-::input.trz)/::input.vz
    }
    
    #-----------------------------------------------
    proc ::EndPoint() \
    {
      if (!exists(::input)) { ::load_input; }
      if (!exists(::input_draw)) { show ::input; }
      if (exists(::input_draw)) {
        ::SetEndPoint( \
                          ::input_draw.GetXPos, \
                          ::input_draw.GetYPos, \
                          ::input_draw.GetZPos \
                        )
      }
      ::Px2 = ::input.trx + ::endx*::input.vx
      ::Py2 = ::input.try + ::endy*::input.vy
      ::Pz2 = ::input.trz + ::endz*::input.vz
    }
    
    
    #-----------------------------------------------
    proc ::SetEndPoint( NUM x, NUM y, NUM z) \
    {
      ::endx = x
      ::endy = y
      ::endz = z
      ::Px2 = ::input.trx + x*::input.vx
      ::Py2 = ::input.try + y*::input.vy
      ::Pz2 = ::input.trz + z*::input.vz
    }
    
    
    #-----------------------------------------------
    proc ::SetEndPointWorld( NUM x, NUM y, NUM z) \
    {
      ::Px2 = x
      ::Py2 = y
      ::Pz2 = z
      ::endx = (x-::input.trx)/::input.vx
      ::endy = (y-::input.try)/::input.vy
      ::endz = (z-::input.trz)/::input.vz
    }
    #-----------------------------------------------
    proc ::Display() \
    {
      ::load_input
      ::load_speed
      show ::input
      show ::speed
      ::input_draw.compare(::speed)
      if (exists(global::path)) { show global::path; }
    }  
    #----------------------------
    proc ::Close() \
    {
      if (exists(::win)) {
        ::win.HidePanel
      }
      delvars GetObjectName(::Close)
    }
    Comments( ::Close, "Will close the interface and delete the corresponding object named '"+GetObjectName(::Close)+"'.")
  
    proc ::CloseAll() {
      eval boost_format( "if (exists(%1%)) { del %1%; };" ) % ::class_name 
      ::Close
    }
    Comments( ::CloseAll, "Call ::Close() method and delete the class variable")
    
    #-----------------------------------------------
    proc ::Run() \
    {
      if (!exists (::input)) {::load_input();}
      if (!exists (::speed)) {::load_speed();}
    
      # force a minimal value of ::epsilon
      maxrepim_crop = ::speed+::epsilon
      if (::use_input_speed) {
        maxrepim_crop = maxrepim_crop + \
                        (::input>::input_Imin)*\
                        (::input<::input_Imax)*::input_speed
      }
    
      # Add Spheres around extremities to facilitate
      # their connections
      ::AS->AddBrightSphere_mm( &maxrepim_crop,\
                          ::startx,::starty,::startz,\
                          3,0.01,0.5)

      # Run a Fast Marching start from End (point or mask) 
      # up to distance 1000
      fminit <<= (FLOAT) maxrepim_crop*0+::maxcost
      
      if (::end_mode==0) {
        ::AS->AddBrightSphere_mm( &maxrepim_crop,\
                            ::endx,::endy,::endz,\
                            3,0.01,0.5)
        if (::endx<2) { ::endx=2; }
        if (::endy<2) { ::endy=2; }
        if (::endz<2) { ::endz=2; }
        fminit.setpos(::endx,::endy,::endz)
        fminit.set(-::maxcost)
      } else {
        fminit = fminit*(::endmask<=0.5)+(::endmask>=0.5)*-::maxcost
      }
    
      # running fast marching until the point 1 is reached
      printn "FMT"
      if (::end_mode == 0){
        res = ::itk->FastMarchingImageFilter3D(maxrepim_crop,\
              ::endx,::endy,::endz,\
              ::maxcost,0)
        res = (res>::maxcost)*::maxcost+(res<=::maxcost)*res
        res.info
      } else {
        res = vtkFastMarchingTarget(maxrepim_crop,fminit,::maxcost,::startx+0.5,::starty+0.5,::startz+0.5)
      }
    
      if (::save_FM) {
        ::FM <<= res
      }

      # reset the maximum to limit gradient and lower side effects of linear interpolation
      epsilon = 0.0001
      maxdist = max[res<::maxcost-epsilon](res)
      res = res*(res<=(maxdist+epsilon))+(res>(maxdist+epsilon))*(maxdist+epsilon)

      printn "FMT done"
      if (exists(::path)) { del ::path; }
      ::path = ::itk->BackTrackingMeshFilter3D( res,\
                                  ::Px1,::Py1,::Pz1,\
                                  ::step_size,\
                                  ::maxlength,\
                                  ::delta) 
    }
    
    proc ::SetParentPanel(OBJECT pp) \
    {
      ::parent_panel = &pp
    }
    
    #-------------------------------------------
    proc ::Gui() \
    {
      import = &global::ami_import;
      if (exists(::parent_panel)) {
        ::win = import->ParamPanel("Path",&::parent_panel)
      } else {
        ::win = import->ParamPanel("Path")
      }
    
      ::win.BeginBook()

        ::win.AddPage("Init")
          # set the input image
          ::win.BeginHorizontal
            ::win.AddImageChoice( &::input_name, "Input")
            ::win.AddButton("Load",::load_input)
          ::win.EndHorizontal
          # set the speed image
          ::win.BeginHorizontal
            ::win.AddImageChoice( &::speed_name, "Speed")
            ::win.AddButton("Load",::load_speed)
          ::win.EndHorizontal
        
          ::win.BeginBoxPanel("Extremities")
            # set the first point
            ::win.AddButton("Set Start Point",::StartPoint)

            # set the second point
            ::win.AddButton("Set End Point",  ::EndPoint)
            
          ::win.EndBoxPanel
    
        ::win.AddPage("Param")
        
          ::win.AddBoolean( &::save_FM)
    
          ::win.AddFloat( &::epsilon,  "::epsilon", 0.01,10)
          ::win.AddFloat( &::maxcost,  "::maxcost", 1,100000)
      
          ::win.BeginBoxPanel("Input intensity-based speed")
            ::win.AddBoolean( &::use_input_speed)
            ::win.AddFloat( &::input_Imin,  "::input_Imin", 0,10000)
            ::win.AddFloat( &::input_Imax,  "::input_Imax", 0,10000)
            ::win.AddFloat( &::input_speed,  "::input_speed", 0,100)
          ::win.EndBoxPanel
    
          ::win.AddFloat( &::step_size,  "::step_size", 0.01,1)
          ::win.AddFloat( &::maxlength,  "::maxlength", 0,1000)
    
          ::win.BeginHorizontal
            # run
            ::win.AddButton("Run",      ::Run)
            # display
            ::win.AddButton("Display",  ::Display)
          ::win.EndHorizontal  
      ::win.EndBook

      # close
      ::win.BeginHorizontal
        ::win.AddButton("Close",      ::Close)
        ::win.AddButton("Close All",  ::CloseAll)
      ::win.EndHorizontal
    
      if (exists(::parent_panel)) {
        ::win.ShowPanel()
      } else {
        ::win.Display()
      }
      ::win.Update(-1)
    }
    
    ::init
    } #End of class
  
} # End of if
