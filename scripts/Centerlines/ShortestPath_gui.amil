#
# Find Shortest path between 2 points
# using a speed image
#

if (!exists(SP_defined)) {
  SP_defined = 1

  func "SyntheticImages/AddSphere"
  
  proc SP_init() {
    global_new
  
    # input image name
    SP_input_name = ""
    # speed image name
    SP_speed_name = ""

    # save the Fast Marching image
    SP_save_FM = UCHAR(0)

    SP_epsilon = 0.02
    SP_maxcost = 1000
  
    SP_use_input_speed = UCHAR(0)
    SP_input_Imin  = 0
    SP_input_Imax  = 1000
    SP_input_speed = 1

    # start point
    SP_startx = 0
    SP_starty = 0
    SP_startz = 0

    # stop mode -- 0: point, 1: mask
    SP_end_mode = INT(0) 

    SP_endmask_name = ""
    # end point
    SP_endx = 0
    SP_endy = 0
    SP_endz = 0
  
    SP_step_size = 0.1
    SP_maxlength = 500
    # Path mode 0 or 1
  
    SP_Gui
  }
  
  
  #-----------------------------------------------
  proc SP_load_input() \
  {
    eval "global::SP_input <<="+SP_input_name+";"
    if (SP_input_name=="Image") {
      SP_input_name = "SP_input"
      SP_win.update
    }
  }
  
  #-----------------------------------------------
  proc SP_load_speed() \
  {
    eval "global::SP_speed <<="+SP_speed_name+";"
    if (SP_speed_name=="Image") {
      SP_speed_name = "SP_speed"
      SP_win.update
    }
  }
  
  #-----------------------------------------------
  proc SP_load_endmask() \
  {
    eval "global::SP_endmask <<="+SP_endmask_name+";"
    if (SP_endmask_name=="Image") {
      SP_endmask_name = "SP_endmask"
      SP_win.update
    }
  }

  #-----------------------------------------------
  proc SP_StartPoint() \
  {
    SP_load_input
    show SP_input
    if (exists(SP_input_draw)) {
      SP_SetStartPoint( \
                        SP_input_draw.GetXPos, \
                        SP_input_draw.GetYPos, \
                        SP_input_draw.GetZPos \
                      )
    }
  }
  
  
  #-----------------------------------------------
  proc SP_SetStartPoint( NUM x, NUM y, NUM z) \
  {
    global::SP_startx = x
    global::SP_starty = y
    global::SP_startz = z
    global::SP_Px1 = SP_input.trx + x*SP_input.vx
    global::SP_Py1 = SP_input.try + y*SP_input.vy
    global::SP_Pz1 = SP_input.trz + z*SP_input.vz
  }
  
  
  #-----------------------------------------------
  proc SP_SetStartPointWorld( NUM x, NUM y, NUM z) \
  {
    global::SP_Px1 = x
    global::SP_Py1 = y
    global::SP_Pz1 = z
    global::SP_startx = (x-SP_input.trx)/SP_input.vx
    global::SP_starty = (y-SP_input.try)/SP_input.vy
    global::SP_startz = (z-SP_input.trz)/SP_input.vz
  }
  
  #-----------------------------------------------
  proc SP_EndPoint() \
  {
    SP_load_input
    show SP_input
    if (exists(SP_input_draw)) {
      SP_SetEndPoint( \
                        SP_input_draw.GetXPos, \
                        SP_input_draw.GetYPos, \
                        SP_input_draw.GetZPos \
                      )
    }
    global::SP_Px2 = SP_input.trx + SP_endx*SP_input.vx
    global::SP_Py2 = SP_input.try + SP_endy*SP_input.vy
    global::SP_Pz2 = SP_input.trz + SP_endz*SP_input.vz
  }
  
  
  #-----------------------------------------------
  proc SP_SetEndPoint( NUM x, NUM y, NUM z) \
  {
    global::SP_endx = x
    global::SP_endy = y
    global::SP_endz = z
    global::SP_Px2 = SP_input.trx + x*SP_input.vx
    global::SP_Py2 = SP_input.try + y*SP_input.vy
    global::SP_Pz2 = SP_input.trz + z*SP_input.vz
  }
  
  
  #-----------------------------------------------
  proc SP_SetEndPointWorld( NUM x, NUM y, NUM z) \
  {
    global::SP_Px2 = x
    global::SP_Py2 = y
    global::SP_Pz2 = z
    global::SP_endx = (x-SP_input.trx)/SP_input.vx
    global::SP_endy = (y-SP_input.try)/SP_input.vy
    global::SP_endz = (z-SP_input.trz)/SP_input.vz
  }
  
  
  #-----------------------------------------------
  proc SP_Display() \
  {
    SP_load_input
    SP_load_speed
    show SP_input
    show SP_speed
    SP_input_draw.compare(SP_speed)
    if (exists(SP_path)) { show SP_path; }
  }
  
  
  #-----------------------------------------------
  proc SP_Close() \
  {
    SP_win.Hide
    delvars "SP_*_draw"
    delvars "SP_*"
  }
  
  
  #-----------------------------------------------
  proc SP_Run() \
  {
    SP_load_input()
    SP_load_speed()
  
    # force a minimal value of SP_epsilon
    maxrepim_crop = SP_speed+SP_epsilon
    if (SP_use_input_speed) {
      maxrepim_crop = maxrepim_crop + \
                      (SP_input>SP_input_Imin)*\
                      (SP_input<SP_input_Imax)*SP_input_speed
    }
  
    # Add Spheres around extremities to facilitate
    # their connections
    AddBrightSphere_mm( &maxrepim_crop,\
                        SP_startx,SP_starty,SP_startz,\
                        3,0.01,0.5)

    # Run a Fast Marching start from End (point or mask) 
    # up to distance 1000
    fminit = (FLOAT) maxrepim_crop*0+SP_maxcost

    if (SP_end_mode==0) {
      AddBrightSphere_mm( &maxrepim_crop,\
                          SP_endx,SP_endy,SP_endz,\
                          3,0.01,0.5)
      if (SP_endx<2) { SP_endx=2; }
      if (SP_endy<2) { SP_endy=2; }
      if (SP_endz<2) { SP_endz=2; }
      fminit.setpos(SP_endx,SP_endy,SP_endz)
      fminit.set(-SP_maxcost)
    } else {
      # load end mask
      SP_load_endmask()
      fminit = fminit*(SP_endmask<=0.5)+(SP_endmask>=0.5)*-SP_maxcost
    }
  
  
    #maxrepim_crop = maxrepim_crop/10
    # running fast marching until the point 1 is reached
    printn "FMT"
    res = vtkFastMarchingTarget(maxrepim_crop,fminit,SP_maxcost,\
                          SP_startx+0.5,SP_starty+0.5,SP_startz+0.5)
    res.info
  
    if (SP_save_FM) {
      global::SP_FM = res
    }

    # reset the maximum to limit gradient and lower side effects of linear interpolation
    epsilon = 0.0001
    maxdist = max[res<SP_maxcost-epsilon](res)
    res = res*(res<=(maxdist+epsilon))+(res>(maxdist+epsilon))*(maxdist+epsilon)

    printn "FMT done"
    if (exists(global::SP_path)) { del global::SP_path; }
    if (SP_end_mode==0) {
      global::SP_path = PathFromVectField( res,\
                                SP_step_size,\
                                SP_maxlength,\
                                SP_Px1,SP_Py1,SP_Pz1,\
                                SP_Px2,SP_Py2,SP_Pz2)
    } else {
      global::SP_path = PathFromVectField( res,\
                                SP_step_size,\
                                SP_maxlength,\
                                SP_Px1,SP_Py1,SP_Pz1)
    }
  }
  
  
  #-------------------------------------------
  proc SP_Gui() \
  {
    global::SP_win = ParamWin("Path")
  
    SP_win.BeginBook

      SP_win.AddPage("Init")
        # set the input image
        SP_win.AddImageChoice(SP_input_name, "Input")
        # set the speed image
        SP_win.AddImageChoice(SP_speed_name, "Speed")
      
        SP_win.BeginBox("Extremities")
          # set the first point
          SP_win.AddButton("Set Start Point",SP_StartPoint)

          #
          stopmode_id = SP_win.AddEnum( SP_end_mode)
            SP_win.AddEnumChoice(stopmode_id,"Point")
            SP_win.AddEnumChoice(stopmode_id,"Mask")

          # set the second point
          SP_win.AddButton("Set End Point",  SP_EndPoint)
          # set the end mask
          SP_win.AddImageChoice(SP_endmask_name,"Stopping mask" )

        SP_win.EndBox
  
      SP_win.AddPage("Param")
      
        SP_win.AddBoolean(SP_save_FM)
  
        SP_win.AddFloat(SP_epsilon,0.01,10)
        SP_win.AddFloat(SP_maxcost,1,100000)
    
        SP_win.BeginBox("Input intensity-based speed")
          SP_win.AddBoolean(SP_use_input_speed)
          SP_win.AddFloat(SP_input_Imin,0,10000)
          SP_win.AddFloat(SP_input_Imax,0,10000)
          SP_win.AddFloat(SP_input_speed,0,100)
        SP_win.EndBox
  
        SP_win.AddFloat(SP_step_size,0.01,1)
        SP_win.AddFloat(SP_maxlength,0,1000)
  
        SP_win.BeginHorizontal
          # run
          SP_win.AddButton("Run",      SP_Run)
          # display
          SP_win.AddButton("Display",  SP_Display)
        SP_win.EndHorizontal  
    SP_win.EndBook

    # close
    SP_win.AddButton("Close",    SP_Close)
  
    SP_win.update
    SP_win.Display
  }
  
  SP_init

}
# end if (!SP_defined)
