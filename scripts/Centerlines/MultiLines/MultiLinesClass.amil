#!/home/karl/projects/bin/OS/improcess

#
# multiscale analysis for detecting 3D centerlines
#
# parameters:
#
# param 1: input image
# param 2: output image
# param 3: minimal radius
# param 4: maximal radius
# param 5: number of radii
#
#

#
# set gamma and theta
#

#
# To do: local extrema,
#        radius image ...
#

func "Common/ScriptGui"

#SetDebugOn
# no interface here
if (!exists(MultiLinesClass)) {

#  if (argc==1) {
#    inputname=$1
#    emptyargs
#  } else {
#    inputname = ""
#  }
  
  Class MultiLinesClass : public ScriptGui {
  

    func "Centerlines/Skeleton/SkeletonClass"
    SkeletonClass ::skeleton_obj

    #----------------------------
    proc ::Init() {
      ::input_name   = "", "Input image name"

      ::mask_mode      = INT(0), "Mask mode 0: threshold from input image, 1: mask image"
      ::mask_threshold = 0, "Low threshold for the mask"
      ::mask_name      = "", "Mask of the pixels to process, this image must be of type UCHAR and the values > 127 are considered part of the mask"

      # circle integration
      # a value of 0 desactivates the SD feature
      # should better create a boolean variable here for clarity
      ::use_SD       = UCHAR(0), "Take into account standard deviation of boundary information along the integration circle"
      ::SD_th        = 2, "Standard Deviation Coefficient to weight the response function"
      # a value of 0 desactivates the EXC feature
      ::use_EXC      = UCHAR(0), "Take into account the excentricity of the boundary vectors along the integration circle"
      ::EXC_th       = 5, "Excentricity coefficient to weight the response function"
      ::pairs_mode   = INT(0)
      ::keephighest  = 100

      # multiscale evolution
      ::radmin       = 0.5, "minimal radius."
      ::radmax       = 5, "maximal radius"
      ::numrad       = INT(5), "number of radii."

      # Compute local maxima
      ::local_maxima      = UCHAR(0), "Compute local maxima"

      ::keep_orientations = UCHAR(0), "Keep orientations image"
      ::keep_eigenratio   = UCHAR(0), "Keep ratio between 2 highest eigenvalues"
      ::keep_radii        = UCHAR(0), "Keep radii image"

      ::use_linearinterp  = UCHAR(1), "Use linear interpolation"

      # 0: Hessian Matrix 1: Structure Tensor
      ::mode         = INT(0)

      # normalization
      ::gamma           = 1
      ::theta           = sqrt(3)
      # this coefficient is recomputed at each scale
      ::rad2sigma_coeff = 1

      # keep all scales
      ::keep_all_scales = UCHAR(0), "Keep responses at all scales in memory"

      # Progress information
      ::current_progress = 0;
      ::current_step     = 0;

      ::output_name="Multilines-maxresponse.ami.gz"

      ::normalize_gradient = UCHAR(1), "normalize gradient"
      ::PSF_stddev = 0, "Standard deviation (in voxels) of the point spread function"

      ::upsample_recons = UCHAR(0), "Reconstruct the vessel in an image with double resolution compared to the input image"

      ::smoothradii_std = 1, "Gaussian standard deviation for smoothing the lines radii"
      #::Gui()
      ::html_filename = op_system.GetCurrentScriptDir()+"/Doc/MultiLines/index.html"
      ::wiki_help = "http://www.ctm.ulpgc.es/amilab/doku.php?id=tutorial-mainalgorithms-multilines"
      
      ::trackvoxel_x = INT(0),"X position of voxel to track"
      ::trackvoxel_y = INT(0),"Y position of voxel to track"
      ::trackvoxel_z = INT(0),"Z position of voxel to track"
      ::enable_track = UCHAR(0)

    }

        
    #------------------------------------
    proc ::load_input() {  
      eval "::input <<= (FLOAT)"+::input_name+";"
      if (::input_name=="Image") {
        ::input_name = "::input"
      }
    
      if (exists(::win)) {
        ::inputmin          = min(::input)
        ::inputmax          = max(::input)
        ::GuiUpdateIntensityLimits(::inputmin,::inputmax)
      }
    }
    Comments(::load_input,"Loads the selected input image, making a local copy in float voxel type.")
    
    //---------------------------------------------------
    proc ::GuiUpdateIntensityLimits( NUM _min, NUM _max) {
      ::win.FloatConstraints(::mask_threshold_id,_min,_max,(_max-_min)/2)
      ::win.Update(-1)
    }

    #------------------------------------
    proc ::update_mask() \
    {  
      if (::mask_mode==0) {
        ::mask <<= (UCHAR) ((::input>::mask_threshold)*255)
      }
      if (::mask_mode==1) {
        if (::mask_name=="Image") {
          ::mask <<= (UCHAR) ((::input>0.1)*255)
          ::mask_name = "::mask"
        } else {
          eval "::mask <<="+::mask_name+";"
        }
      }
    }

    #-----------------------------------------------
    proc ::set_mask( IMAGE mask) \
    {
      ::mask <<= (UCHAR) (mask>0.1)*255
      ::mask_name = "::mask"
    }
    
    #-----------------------------------------------
    proc ::set_gradient_mask( IMAGE gmask) \
    {
      del ::grad_mask
      ::grad_mask = &gmask
    }

    #--------------------------------------------------
    proc ::set_input(IMAGE im)  \
    {
      ::input <<= im
      ::input_name = "::input"
    }
    
    #--------------------------------------------------
    proc ::set_result(IMAGE im) \
    {
      ::result <<= im
    }
    
    #--------------------------------------------------
    proc ::set_maxima(IMAGE im) \
    {
      ::maxima <<= im
    }

    #--------------------------------------------------
    proc ::set_radii(IMAGE im) \
    {
      ::radii <<= im
    }
    
    #--------------------------------------------------
    proc ::h(NUM gamma, NUM theta, NUM res) {
    #    ----
      tmp1=2*(gamma-1)
      theta2 = theta*theta
      tmp2=theta2-tmp1
      tmp2=tmp2*tmp2
      delta = tmp2+16-tmp1*tmp1
      res= sqrt((sqrt(delta)+tmp1-theta2)/(2*(3-gamma)))
    }
    
    #--------------------------------------------------
    proc ::rad2sigma(NUM rad, NUM sigma) {
    #    ------------
      sigma=::rad2sigma_coeff*rad
    }
    
    #--------------------------------------------------
    proc ::ComputeResponse(NUM sigma, IMAGE response,  IMAGE v1, IMAGE v2, IMAGE v3) \
    {
    #    ---------------
      printn "ComputeResponse with sigma = %1%" % sigma
    
      response.initvalue(0)
    
      # Computation of the direction
      # the results are 
      # _input_Hvep1, _input_Hvep2, _input_Hvep3
      # _input_Hvap1, _input_Hvap2, _input_Hvap3
      #
      # 1. Gamma normalized with the coefficient _gamma
      # 2. the eigenvalues are arranged into descending order of absolute values
      #
    
      # Old way: HessianMatrix(_input,sigma,_gamma)
      #
      # 2,2,0,1 means:
      # 3: 1st eigenvector & eigenvalue
      # 3: 2st eigenvector & eigenvalue
      # 0: don't need the third eigen(vector/value)
      # 1: gradient vector
      #
    
    
      if (::mode==0) {
        if (sigma<0.6) {
          InfoDialog "sigma = %1% is too small for second order derivatives: this scale is ignored." % sigma
        } else {
          Derivatives(::input,sigma,::gamma,3,3,1,1,::mask)
          vap1 = input_Hvap1
          vap2 = input_Hvap2
          v1  = input_Hvep1
          v2  = input_Hvep2
          v3  = input_Hvep3
          del input_Hvap1
          del input_Hvap2
          del input_Hvep1
          del input_Hvep2
      
          # create a region of interest
          mask1 = (UCHAR) ((::mask>0)*(vap1<0)*(vap2<0)*255)
      
          del vap1
          del vap2
        }
    
      }  else {
    
        # Compute Structure Tensor
        printn "Structure Tensor"
    
        StructTensorH(::input,sigma,1,::mask,1)
        v1  = input_STHvep1
        v2  = input_STHvep2    
        v3  = input_STHvep3
        input_grad = input_STHgrad
        del input_STHvap1
        del input_STHvap2
        del input_STHvap3
        del input_STHvep1
        del input_STHvep2
        del input_STHvep3
        del input_STHgrad
    
        mask1 = ::mask
      }
    
      # run the circle integration on a region of interest
      # Integrate the border information on a circle of radius theta*sigma
      if (::mode==0)&&(sigma<0.6) {
        response = 0
      } else {
        response = CircleInt( input_grad, v1, v2, ::theta*sigma, mask1)
      }
      # _response   = CircleIntSdExc( _input_grad,_v1,_v2,_theta*sigma,_mask1,1,1.5)
    
    
    } # ComputeResponse
    
    #-------------------------------------------------------------
    proc ::ComputeResponse_new( NUM sigma, IMAGE response) {
      printn "::ComputeResponse_new"
    
      response.initvalue(0)
    
      # Computation of the direction
      # the results are 
      #
      # 1. Gamma normalized with the coefficient _gamma
      # 2. the eigenvalues are arranged into descending order of absolute values
      #
    
      # Compute Structure Tensor
      printn "Structure Tensor"
      inittime = wx.wxDateTime.UNow()
      sth = filters.StructureTensorH(&::input,sigma,1,&::mask)
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "time: "+time_elapsed
    
      SetProgress(::current_progress+::current_step*0.25)
    
      ## EigenDecomp, parameters:  the structure tensor,
      ## the eigenvalues flag: 0
      ## the eigenvectors flag 3
      #inittime = wx.wxDateTime.UNow()
      #eig = filters.EigenDecomp(&sth,0,3,&::mask)
      ## using eig[3] and eig[4]
      #diff=wx.wxDateTime.UNow()-inittime
      #time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      #printn "EigenDecomp time: "+time_elapsed
      
      #
      p = algorithms.ami_ImageToImageFilterParam.ImageToImageFilterParam()
      p.SetNumberOfThreads(wx.wxThread.GetCPUCount())
      p.SetInput(&sth)

      inittime = wx.wxDateTime.UNow()
      del ed
      ed = algorithms.ami_EigenDecomp.EigenDecomp()
      ed.SetParameters(&p)
      ed.Setdiag_algorithm(algorithms.ami_EigenDecomp.KOPP_HYBRID)
      ed.Setenable_eigenvalue1(::keep_eigenratio)
      ed.Setenable_eigenvalue2(::keep_eigenratio)
      ed.Setenable_eigenvalue3(false)
      ed.Setenable_eigenvector1(true)
      ed.Setenable_eigenvector2(true)
      ed.Setenable_eigenvector3(false)
      ed.Setmask(&::mask)
      ed.Run()
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "EigenDecomp2 time: "+time_elapsed

      if (::keep_eigenratio) {
        ::current_eigen_ratio <<= sqrt(ed.Geteigenvalue1())/\
                                       (sqrt(ed.Geteigenvalue2())+0.01)
      }

      # check that the 2 ways are identical
      #::eig_3 <<= eig[3]
      #::eig_3_new <<= ed.Geteigenvector1()
      #m = min(norm(eig[3]-ed.Geteigenvector1()),norm(eig[3]+ed.Geteigenvector1()))
      #printn  max(m)
      #m = min(norm(eig[4]-ed.Geteigenvector2()),norm(eig[4]+ed.Geteigenvector2()))
      #printn  max(m)

      SetProgress(::current_progress+::current_step*0.5)
      del sth
    
      # do we get the gradient separately to avoid the mask here??
      # normalized gradient
      #grad = gradient(::input,sigma)
      #if (::normalize_gradient) {
      #  grad = grad*sigma
      #}
      grad_algo = algorithms.Gradient(&::input,sigma,::normalize_gradient)
      grad_algo.SetPSF(::PSF_stddev,::PSF_stddev,::PSF_stddev)
      grad = grad_algo.Execute()
      if (exists(::grad_mask)) {
        grad = grad*(::grad_mask>0)
      }

      SetProgress(::current_progress+::current_step*0.75)
    
      # create a region of interest
      #_mask1 = (UCHAR) ((_mask>0)*(vap1<0)*(vap2<0)*255)
    
    
      #response = CircleMinIntSdExc(grad,\
                          #eig[3],\
                          #eig[4],\
                          #::theta*sigma, \
                          #::mask,\
                          #::SD_th*::use_SD,\
                          #::EXC_th*::use_EXC, \
                          #::pairs_mode, \
                          #::keephighest)
    
      # second response new way to do it
      inittime = wx.wxDateTime.UNow()
      repcircle = algorithms.CalculRepCercle(&grad,algorithms.CalculRepCercle.circle_mean)
      repcircle.SetGradient(&grad)
      repcircle.SetNoLinearInterp(!::use_linearinterp)
      repcircle.useSD(::SD_th*::use_SD)
      repcircle.useEXC(::EXC_th*::use_EXC)
      repcircle.ReducePairs(true,::pairs_mode)
      repcircle.KeepHighest(::keephighest)
      repcircle.FixeRayon(::theta*sigma,1)

      cb3d = algorithms.CircleBoundaries3D()
      cb3d.SetBoundaryComputationClass(&repcircle)
      cb3d.SetMask(&::mask)

      #e3 = eig[3]
      #e4 = eig[4]
      e3 = ed.Geteigenvector1()
      e4 = ed.Geteigenvector2()

      cb3d.SetOrientations(&e3,&e4)
      #::grad0 = grad
      #response
      cb3d.Execute(&response)
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "Circle boundaries time: "+time_elapsed

      #diff = max(norm(response-::response2))
      #printn "Maximal difference = %1%" % diff

      # run the circle integration on a region of interest
      # Integrate the border information on a circle of radius theta*sigma
    
      # Error: I did not comment this line for the challenge !!!!
      #response = CircleInt( grad, eig[3], eig[4],
      #                        ::theta*sigma, ::mask)
    
      if (::local_maxima) {
        # copy the 2 eigenvectors
        ::current_v1 <<= e3
        ::current_v2 <<= e4
      }
    
    } 
    # ::ComputeResponse_new

    #--------------------------------------------------
    #
    # mode is 0: use Hessian matrix
    # mode is 1: use Structure tensor
    #
    proc ::MultiLines( ) \
    {
      current_proc = "::MultiLines()"
      InitTime

      #  Load input images
      if (!exists(::input)) {
        ::load_input()
      }
      if (!exists(::mask)) {
        ::update_mask()
      }

      # Precompute coefficient of proportionality
      ::h(::gamma,::theta,&::rad2sigma_coeff)
    
      ::current_rad=::radmin
    
      ::current_sigma=0
      if (::numrad>1) {
        _step=exp((ln(::radmax)-ln(::radmin))/(::numrad-1))
      } else {
        _step = 1
      }
    
      #
      # main loop 
      #
    
      response=Image(FLOAT,1,::input)
      response.initvalue(0)
    
      if (::keep_all_scales) {
        ::all_responses <<= Image(FLOAT,::input.tx,::input.ty,::input.tz,::numrad)
      }

      v1=Image(FLOAT,3,::input)
      v1.initvalue(0,0,0)
      v2=Image(FLOAT,3,::input)
      v2.initvalue(0,0,0)
      v3=Image(FLOAT,3,::input)
      v3.initvalue(0,0,0)
    
#      ::all_responses     = VarVector()
#      ::all_maxresponses  = VarVector()
#      ::all_radii         = VarVector()
#      ::all_current_radii = VarVector()

      for i=0 to ::numrad-1 {
        iteration_mess = " Iteration %1%" % i
        SetStatusText( current_proc+iteration_mess )
        ::current_progress = (FLOAT)i/::numrad*100
        ::current_step     = 1/::numrad*100
        SetProgress(::current_progress)
    
        ::rad2sigma(::current_rad,&::current_sigma)
#        ::all_current_radii.push_back(::current_rad)
      
        ::ComputeResponse( ::current_sigma, \
                            &response, \
                            &v1, &v2,&v3)
#        ::all_responses.push_back(response)

        if (::keep_all_scales) {
          ::all_responses.SetComponent(i,response)
        }
    
        # save response to file
        #response_filename=result.GetName-".gz"-".inr"-".ami"-".vtk"
        #response_filename = "multilines"
        #response_filename = sprint("rep%02.0f.ami.gz",_i)
        #response.save response_filename
        #response.save sprint("rep%02.0f.ami.gz",_i)
    
    
        # Compute and Update Local Maxima
        print "Compute and Update Local Maxima\n"
    
        # keep maximal response
        if (i==0) {
          max_response=response
 #        ::all_maxresponses.push_back(max_response)
          
          prev_response=response
          current_maxima <<= response*0
          ::maxima <<= response*0
          v1_max=v1
          v2_max=v2
          v3_max=v3
          radius = (response>0)*::current_rad;
        } else {
          printn "get here"
          # Update the maxima
          # only keep the first maxima found
          ::maxima = (::maxima!=0)*::maxima+(::maxima==0)*(current_maxima>response)*current_maxima
    
          v1_max = v1_max*(max_response>=response)+v1*(max_response<response)
          v2_max = v2_max*(max_response>=response)+v2*(max_response<response)
          v3_max = v3_max*(max_response>=response)+v3*(max_response<response)
          radius = (response<max_response)*radius+(response>=max_response)*::current_rad
          max_response=max(response,max_response)
 #        ::all_maxresponses.push_back(max_response)
         # Compute local maxima
          current_maxima = LocalExtrema(response,v1,v2,::mask)
          current_maxima = current_maxima*(response>prev_response)
        }
    
 #       ::all_radii.push_back(radius)
        ::current_rad = ::current_rad*_step
        SetProgress(i/::numrad*100)
        # process several graphic events
        ProcessEvents(100)
      }
    
      
    #  v3_max.save sprint("v3_max_%01.0f.ami.gz",::mode)
    #  v2_max.save sprint("v2_max_%01.0f.ami.gz",mode)
    
      # computing local maxima on the maximum response accross scales
      ::maxima2 = LocalExtrema(max_response,v1_max,v2_max,::mask)
    
      # save maximal response to file
      ::result    = max_response
      ::radii     <<= radius
    
      SetProgress(0)
      SetStatusText( "Finished MultiLines" )
      EndTime
    } 
    # end MultiLines()
    #--------------------------------------------------
    #
    # mode is 0: use Hessian matrix
    # mode is 1: use Structure tensor
    #
    proc ::MultiLines_new( ) \
    {
      current_proc = "::MultiLines_new()"
      if (!exists(::SD_th)) {
        InfoDialog "MultiLines_new Multilines not initialized"
      }

      # TODO: adapt for ROI
      InitTime

      #  Load input images
      if (!exists(::input)) {
        ::load_input()
      }
      
      if (!exists(::mask)) {
        ::update_mask()
      }

      # Precompute coefficient of proportionality
      ::h(::gamma,::theta,&::rad2sigma_coeff)
    
      ::current_rad   = ::radmin
      ::current_sigma = 0

      if (::numrad>1) {
        _step=exp((ln(::radmax)-ln(::radmin))/(::numrad-1))
      } else {
        _step = 1
      }
    
      #
      # main loop 
      #
      response<<=Image(FLOAT,1,::input)
      response.initvalue(0)

      if (::keep_all_scales) {
        ::all_responses <<= Image(FLOAT,::input.tx,::input.ty,::input.tz,::numrad)
      }
    
      for i=0 to ::numrad-1 {
        iteration_mess = " Iteration %1%" % i
        SetStatusText( current_proc+iteration_mess )
        ::current_progress = (FLOAT)i/::numrad*100
        ::current_step     = 1/::numrad*100
        SetProgress(::current_progress)
    
    
        ::rad2sigma(::current_rad,&::current_sigma)
    
        printn sprint(" radius = %0.2f",::current_rad)
        printn sprint(" sigma = %0.2f", ::current_sigma)
    
        ::ComputeResponse_new(::current_sigma, &response)
        if (::enable_track) {
          printn "Iteration %1%" %i
          printn "Response obtained = %1%" % \
                    response(::trackvoxel_x,::trackvoxel_y,::trackvoxel_z)
        }
    
        if (::keep_all_scales) {
          ::all_responses.SetComponent(i,response)
        }

        # Compute and Update Local Maxima
        SetStatusText( iteration_mess + \
                        "Compute and Update Local Maxima")
    
        # keep maximal response
        if (i==0) {
          max_response=response
          if (::local_maxima) {
            # 3 more images in memory
            current_maxima <<= response*0
            ::num_lmax <<= ((UCHAR) response)*0
            ::maxima       <<= response*0
            if (::keep_orientations) {
              # check how to get the vectors here, or keep the symmetric matric??
              #v1_max=v1
              #v2_max=v2
              #v3_max=v3
            }
            if (::keep_radii) {
              radius = (response>0)*::current_rad;
            }
            if (::keep_eigenratio) {
              ::eigen_ratio = ::current_eigen_ratio
            }
          }
        } else {

          if (::local_maxima) {
            # Update the maxima
            # only keep the first maxima found
            ::maxima =  (::maxima!=0)*::maxima+\
                        (::maxima==0)*(current_maxima>response)*current_maxima
            # we are only interested in positive responses ...
            ::num_lmax = ::num_lmax+(current_maxima>response)*(response>0)
            if (::keep_orientations) {
              # to do
              #v1_max = v1_max*(max_response>=response)+v1*(max_response<response)
              #v2_max = v2_max*(max_response>=response)+v2*(max_response<response)
              #v3_max = v3_max*(max_response>=response)+v3*(max_response<response)
            }
            if (::keep_radii) {
              radius = (max_response>=response)*radius+(max_response<response)*::current_rad
            }
            if (::keep_eigenratio) {
              ::eigen_ratio = ::current_eigen_ratio*(max_response>=response)+\
                              ::eigen_ratio*(max_response<response)
              del ::current_eigen_ratio
            }
            # Compute local maxima
            current_maxima = LocalExtrema(response,::current_v1,::current_v2,::mask)
            if (::enable_track) {
              printn "Local Extrema value =  %1%" % \
                   current_maxima(::trackvoxel_x,::trackvoxel_y,::trackvoxel_z)
            }
            current_maxima = current_maxima*(response>prev_response)
          } 
          # end if (::local_maxima)
          max_response=max(response,max_response)
        } 
    
        if (::local_maxima) {
          # keep current response as previous response for next iteration
          prev_response=response
        }
        ::current_rad = ::current_rad*_step
        SetProgress(i/::numrad*100)
      }

      # free memory from global images used for the computation
      if (::local_maxima) {
        del ::current_v1
        del ::current_v2
      }

      # set the result image
      ::result <<= max_response
      if ((::local_maxima)&&(::keep_radii)) {
        ::radii  <<= radius
      }

      # check for NaN
      nan_count_rep = ami_count(::result!=::result)
      if (nan_count_rep) {
        InfoDialog "Nan values found in response : %1% !" % nan_count_rep
      }
      if (::local_maxima) {
        nan_count_lmax = ami_count(::maxima!=::maxima)
        if (nan_count_lmax) {
          InfoDialog "Nan values found in local maxima : %1% !" % nan_count_lmax
        }
      }

      SetProgress(0)
      SetStatusText( "Finished MultiLines_new" )
      EndTime
    } # MultiLines_new

    #-----------------------------------------------
    proc ::CB_ROI() {
      if (exists(::input_draw)) {
        ::roi <<= ::input[::input_draw]
        ::roi_contour = (UCHAR) ::input*0
        ::roi = 1
        ::roi_contour.putimage(::roi)
        ::Display()
      }
    }

    #-----------------------------------------------
    proc ::DisplayResult() {
      show ::input
      if (exists(::result)) {
        show ::result
        ::input_draw.compare(&::result_draw)
      }
      if (exists(::roi_contour)) {
        ::input_draw.SetIsoContour(0,::roi_contour,0.5)
        ::input_draw.DrawIsoContour(0,1)
      }
    }
    
    #-----------------------------------------------
    proc ::DisplayLMax() {
      show ::input
      if (exists(::maxima)) {
        show ::maxima
        ::input_draw.compare(&::maxima_draw)
      }
    }

    #-----------------------------------------------
    proc ::DisplayRadii() {
      show ::input
      if (exists(::radii)) {
        show ::radii
        ::input_draw.compare(&::radii_draw)
      }
    }

    #-----------------------------------------------
    proc ::Save() {
      ::result.save ::output_name
    }
    
    #-----------------------------------------------
    proc ::OnLocalMaxima() \
    {
      printn "::OnLocalMaxima()"
      printn " val = %1%" % ::local_maxima>0
      ::win.Enable(::keep_or_id, ::local_maxima>0)
      ::win.Enable(::keep_rad_id,::local_maxima>0)
      ::win.Update(-1)
    }

    #-----------------------------------------------
    proc ::CreateSkeleton() \
    {
      ::skeleton_obj.Execute()
    }

    #-----------------------------------------------
    proc ::PruneSkeleton() \
    {
      ::skeleton_obj.SelectPrune()
      ::skeleton_obj.RemovePrune()
    }

    #-----------------------------------------------
    proc ::SmoothSkeleton() \
    {
      ::skeleton_obj.Smooth_Lines()
    }

    #-----------------------------------------------
    proc ::DisplaySkeleton() \
    {
      ::skeleton_obj.Display()
    }

    #-----------------------------------------------
    proc ::SmoothedReconstruction() \
    {
      if (!exists(::radii)) { 
        InfoDialog "Radii image has not been created, enable saving the radii !" 
      } else {
        if (!exists(::skeleton_obj->lines)) {
          InfoDialog "No centerlines"
        } else {
          # smooth radii
          ::radii_smoothed <<= ::radii
          nl = ::skeleton_obj.lines.GetNumberOfLines()
          for l=0 to nl-1 {
            printn "Processing line %1%" % (l+1) + " of %1%" % nl
            line <<= ::skeleton_obj.lines.GetLine(l)
            line_radii <<= ::radii(line)
            line_radii_smoothed <<= filter(line_radii,::smoothradii_std,0,0,0)
            # put back the smooth values in the image
            for k=0 to line.tx-1 {
              ::radii_smoothed.setpos(line(k,0,0,0),line(k,0,0,1),line(k,0,0,2))
              ::radii_smoothed.set(line_radii_smoothed(k,0,0,0))
            }
          }
          # reconstruction
          rad_info = ::skeleton_obj.lines.GetIntensities(&::radii_smoothed)
          if exists(::skeleton_obj->slines) { l = &::skeleton_obj.slines; } else { l = &::skeleton_obj.lines; }
          func "ShortCuts/ShortCuts.amil"
          if (::upsample_recons) {
            in2 = Resize(::input,::input.tx*2,::input.ty*2,::input.tz*2,0)
            ::s_recons <<= LineRecons(l, in2, rad_info)            
          } else {
            ::s_recons <<= LineRecons(l, ::input, rad_info)
          }
        }
      }
    }

    #-----------------------------------------------
    proc ::CreateReconstruction() \
    {
      # check existence of radius image or use constant radius
      if (!exists(::radii)) { 
        InfoDialog "Radii image has not been created, enable saving the radii !" 
      } else {
        # check existence of centerlines
        if (!exists(::skeleton_obj->lines)) {
          InfoDialog "No centerlines"
        } else {
          rad_info = ::skeleton_obj.lines.GetIntensities(&::radii)
          if exists(::skeleton_obj->slines) { l = &::skeleton_obj.slines; } else { l = &::skeleton_obj.lines; }
          func "ShortCuts/ShortCuts.amil"
          if (::upsample_recons) {
            in2 = Resize(::input,::input.tx*2,::input.ty*2,::input.tz*2,0)
            ::recons <<= LineRecons(l, in2, rad_info)            
          } else {
            ::recons <<= LineRecons(l, ::input, rad_info)
          }
        }
      }
      
    }

    #-----------------------------------------------
    proc ::DisplayReconstruction() \
    {
      if (exists(::recons)) {
        show ::recons
        ::recons_surf = isosurf(::recons,255*exp(-0.5))
        if (exists(::s_recons)) {
          ::s_recons_surf = isosurf(::s_recons,255*exp(-0.5))
        }
        ::viewer = Viewer3D("Reconstruction")
        if exists(::used_lines)  { del ::used_lines; }
        if exists(::skeleton_obj->slines) { ::used_lines = &::skeleton_obj.slines; } else {  ::used_lines = &::skeleton_obj.lines; }
        ::viewer += ::used_lines
        ::viewer += ::recons_surf
        if (exists(::s_recons_surf)) {
          ::viewer += ::s_recons_surf
        }
      }
    }

    #-----------------------------------------------
    proc ::Gui() \
    {
      if (exists(::parent_panel)) {
        ::win = ParamPanel("MultiLines",&::parent_panel)
      } else {
        ::win = ParamPanel("MultiLines")
      }
      ::win.BeginBook()
        ::win.AddPage("IO")
          # set the input image
          ::win.BeginHorizontal()
            ::win.AddImageChoice( &::input_name, "Input")
            ::AddBitmapButton(&::win, &::icons._Copy,   16, "load_input")
            ::win.SetPositionProp(-1,0)
          ::win.EndHorizontal()

          ::win.BeginBoxPanel("Mask")
            maskmode_id = ::win.AddEnum(&::mask_mode, "Mode")
              ::win.AddEnumChoice(maskmode_id,"Threshold from input")
              ::win.AddEnumChoice(maskmode_id,"Mask image")

            # set the mask threshold
            ::mask_threshold_id = ::win.AddFloat(&::mask_threshold,"Threshold",0,100)

            # set the mask image
            ::win.AddImageChoice( &::mask_name, "Mask")
            ::win.AddButton("Update",&::update_mask)
          ::win.EndBoxPanel()
        
        ::win.AddPage("Circle")

          ::win.AddBoolean( &::use_SD,"Use StdDev")
          ::win.AddFloat( &::SD_th,"StdDev_thres", 0,10)
          ::win.AddBoolean( &::use_EXC,"Use Exc")
          ::win.AddFloat( &::EXC_th,"Exc_thres",0,10)
          pairmodeid = ::win.AddEnum( &::pairs_mode)
            ::win.AddEnumChoice(pairmodeid,"Min")
            ::win.AddEnumChoice(pairmodeid,"Max")
            ::win.AddEnumChoice(pairmodeid,"Mean")
          ::win.AddFloat( &::keephighest,  "Keephighest", 0,100)

        ::win.AddPage("Scales")
          ::win.BeginBoxPanel("Radii (or scales)")
            ::win.AddFloat( &::radmin,"min.",0.5,10)
            ::win.AddFloat( &::radmax,"max.",0.5,10)
            ::win.AddInt( &::numrad,"number",1,20)
          ::win.EndBoxPanel()
        
          ::localmax_id = ::win.AddBoolean( &::local_maxima,"Local maxima")
          ::win.SetCallback(&::OnLocalMaxima)
          ::keep_or_id  = ::win.AddBoolean( &::keep_orientations,"Orientations")
          ::keep_rad_id = ::win.AddBoolean( &::keep_radii,"Radii")
          ::keep_ratio_id = ::win.AddBoolean( &::keep_eigenratio,"Eigenvalue ratio")

        ::run_page = ::win.AddPage("Run")
          modeid = ::win.AddEnum( &::mode)
            ::win.AddEnumChoice(modeid,"Hessian Matrix")
            ::win.AddEnumChoice(modeid,"Structure Tensor")

          ::win.AddBoolean( &::keep_all_scales, "Keep all scales")
          ::win.AddBoolean( &::normalize_gradient, "Normalize gradient")
          ::win.AddFloat( &::PSF_stddev, "PSF")
          ::win.AddBoolean( &::use_linearinterp, "Linear Interpolation")

          ::win.BeginBoxPanel("Controls")
            ::win.BeginHorizontal()
              ::win.AddButton("Select ROI", ::CB_ROI)
              ::win.AddButton("Run",        ::MultiLines)
              ::win.AddButton("Run new",    ::MultiLines_new)
            ::win.EndHorizontal()
            ::outputname_id = ::win.AddString( &::output_name, "Output")
            ::win.BeginBoxPanel("Display")
              ::win.BeginHorizontal()
                display_id = ::win.AddButton("Result",    &::DisplayResult)
                display_id = ::win.AddButton("Local max", &::DisplayLMax)
                display_id = ::win.AddButton("Radii",     &::DisplayRadii)
              ::win.EndHorizontal()
            ::win.EndBoxPanel
            display_id = ::win.AddButton("Save",       ::Save)
          ::win.EndBoxPanel()

        ::recons_page = ::win.AddPage("Recons")

          ::win.BeginBoxPanel("Skeleton")
            ::win.BeginHorizontal()
              ::win.AddButton("Create", &::CreateSkeleton)
              ::win.AddButton("Display",&::DisplaySkeleton)
              ::win.AddButton("Prune",  &::PruneSkeleton)
              ::win.AddButton("Smooth", &::SmoothSkeleton)
            ::win.EndHorizontal()
          ::win.EndBoxPanel()

          ::win.BeginBoxPanel("Reconstruction")
            ::win.AddBoolean(&::upsample_recons,"Upsample x2")
            ::win.BeginHorizontal()
              ::win.AddButton("Create",   &::CreateReconstruction)
              ::win.AddButton("Create Smoothed", &::SmoothedReconstruction)
              ::win.AddButton("Display",  &::DisplayReconstruction)
            ::win.EndHorizontal()
          ::win.EndBoxPanel()

          ::win.BeginBook()
            ::skeleton_obj.SetParentPanel(&::win)
            ::skeleton_obj.Gui()
            ::win.AddPage("Skeleton",&::skeleton_obj.win)
          ::win.EndBook()

        ::recons_page = ::win.AddPage("Track")
          ::win.BeginBoxPanel("Voxel to track")
            ::win.AddInt(::trackvoxel_x,"X=",0,1024)
            ::win.AddInt(::trackvoxel_y,"Y=",0,1024)
            ::win.AddInt(::trackvoxel_z,"Z=",0,1024)
          ::win.EndBoxPanel()
          ::win.AddBoolean(::enable_track,"Enable tracking")
      ::win.EndBook()
    
      ::AddStandardButtons(&::win)

    
      if (exists(::parent_panel)) {
        ::win.ShowPanel()
      } else {
        ::win.Display()
      }
      ::OnLocalMaxima()
      ::win.Update(-1)
      
    }
    
    ::Init()
    
  
  } #End of class
  
} # End of if

      