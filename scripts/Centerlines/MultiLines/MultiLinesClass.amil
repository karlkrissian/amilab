#!/home/karl/projects/bin/OS/improcess

#
# multiscale analysis for detecting 3D centerlines
#
# parameters:
#
# param 1: input image
# param 2: output image
# param 3: minimal radius
# param 4: maximal radius
# param 5: number of radii
#
#

#
# set gamma and theta
#

#
# To do: local extrema,
#        radius image ...
#

func "Common/ScriptGui"

#SetDebugOn
# no interface here
if (!exists(MultiLinesClass)) {

#  if (argc==1) {
#    inputname=$1
#    emptyargs
#  } else {
#    inputname = ""
#  }
  
  Class MultiLinesClass : public ScriptGui {
  

    func "Centerlines/Skeleton/SkeletonClass"
    SkeletonClass ::skeleton_obj

    #----------------------------
    proc ::Init() {
      ::param_description = "Default parameters", "Param: Description of the"+\
                          " parameters set"
                          
      ::input_name   = "", "Param: Input image name"

      ::mask_mode      = INT(0),  "Param: "+\
              "Mask mode 0: threshold from input image, 1: mask image"
      ::mask_lowthreshold = 0,    "Param: "+\
                                  "Low threshold for the mask"
      ::mask_highthreshold = 255, "Param: "+\
                                  "High threshold for the mask"
      ::mask_name      = "",      "Param: "+\
              "Mask of the pixels to process, this image must be of "+\
              "type UCHAR and the values > 127 are considered part of the mask"

      # circle integration
      # a value of 0 desactivates the SD feature
      # should better create a boolean variable here for clarity
      ::use_SD       = UCHAR(0), "Param: "+\
              "Take into account standard deviation of boundary "+\
              "information along the integration circle"
      ::SD_th        = 2, "Param: "+\
              "Standard Deviation Coefficient to weight the response function"
      # a value of 0 desactivates the EXC feature
      ::use_EXC      = UCHAR(0), "Param: "+\
              "Take into account the excentricity of the boundary vectors "+\
              "along the integration circle"
      ::EXC_th       = 5, "Param: "+\
              "Excentricity coefficient to weight the response function"
      ::pairs_mode   = INT(0), "Param: "
      ::keephighest  = 100,    "Param: "

      # multiscale evolution
      ::radmin       = 0.5,     "Param: minimal radius."
      ::radmax       = 5,       "Param: maximal radius"
      ::numrad       = INT(5),  "Param: number of radii."

      # Compute local maxima
      ::local_maxima      = UCHAR(0), "Param: Compute local maxima"

      ::keep_orientations = UCHAR(0), "Param: Keep orientations image"
      ::keep_eigenratio   = UCHAR(0), "Param: Keep ratio between 2 highest eigenvalues"
      ::keep_radii        = UCHAR(0), "Param: Keep radii image"

      ::use_linearinterp  = UCHAR(1), "Param: Use linear interpolation"

      # 0: Hessian Matrix 1: Structure Tensor
      ::mode         = INT(0), "Param"

      # normalization
      ::gamma           = 1, "Param: Gamma normalization parameter"
      ::theta           = sqrt(3), "Param: proportionality coefficient "+\
                          "between the radius of the circle and the scale"
      # this coefficient is recomputed at each scale
      ::rad2sigma_coeff = 1

      # keep all scales
      ::keep_all_scales = UCHAR(0), "Param: Keep responses at all scales in memory"

      # Progress information
      ::current_progress = 0;
      ::current_step     = 0;

      ::output_name="Multilines-maxresponse.ami.gz"

      ::normalize_gradient = true, "Param: normalize gradient"
      ::PSF_stddev = 0, "Param: Standard deviation (in voxels) of the point spread function"
      ::use_StructTensorGrad = true, "Param: use the gradient computed by the structure tensor"

      ::upsample_recons = false, "Param: Reconstruct the vessel in an image with double resolution compared to the input image"

      ::smoothradii_std = 1, "Param: Gaussian standard deviation for smoothing the lines radii"
      #::Gui()
      ::html_filename = op_system.GetCurrentScriptDir()+"/Doc/MultiLines/index.html"
      ::wiki_help = "http://www.ctm.ulpgc.es/amilab/doku.php?id=tutorial-mainalgorithms-multilines"
      
      ::trackvoxel_x = INT(0),"X position of voxel to track"
      ::trackvoxel_y = INT(0),"Y position of voxel to track"
      ::trackvoxel_z = INT(0),"Z position of voxel to track"
      ::enable_track = false

      
      ::max_memory_usage = INT(1000), "Param: Expected memory usage in Mb"
      ::split_image = false, "Param: Split image to avoid excess of RAM usage"
      
      ::speedup_convolutions = false, "Param: Reduce time of big convolutions"
      
      ::abort = false, "Abort current processing"
    }

        
    #------------------------------------
    proc ::load_input() {  
      eval "::input <<= (FLOAT)"+::input_name+";"
      if (::input_name=="Image") {
        ::input_name = "::input"
      }
    
      if (exists(::win)) {
        ::inputmin          = min(::input)
        ::inputmax          = max(::input)
        ::GuiUpdateIntensityLimits(::inputmin,::inputmax)
      }
    }
    Comments(::load_input,"Loads the selected input image, making a local copy in float voxel type.")
    
    //---------------------------------------------------
    proc ::GuiUpdateIntensityLimits( NUM _min, NUM _max) {
      ::win.FloatConstraints(::mask_lowthreshold_id, _min,_max,(_max-_min)/2)
      ::win.FloatConstraints(::mask_highthreshold_id,_min,_max,(_max-_min)/2)
      ::win.Update(-1)
    }

    #------------------------------------
    proc ::update_mask() \
    {  
      if (::mask_mode==0) {
        ::mask <<= (UCHAR) ((::input>::mask_lowthreshold)*\
                            (::input<::mask_highthreshold)*255)
      }
      if (::mask_mode==1) {
        if (::mask_name=="Image") {
          ::mask <<= (UCHAR) ((::input>0.1)*255)
          ::mask_name = "::mask"
        } else {
          eval "::mask <<="+::mask_name+";"
        }
      }
    }

    #-----------------------------------------------
    proc ::set_mask( IMAGE mask) \
    {
      ::mask <<= (UCHAR) (mask>0.1)*255
      ::mask_name = "::mask"
    }
    
    #-----------------------------------------------
    proc ::set_gradient_mask( IMAGE gmask) \
    {
      del ::grad_mask
      ::grad_mask = &gmask
    }

    #--------------------------------------------------
    proc ::set_input(IMAGE im)  \
    {
      ::input <<= im
      ::input_name = "::input"
    }
    
    #--------------------------------------------------
    proc ::set_result(IMAGE im) \
    {
      ::result <<= im
    }
    
    #--------------------------------------------------
    proc ::set_maxima(IMAGE im) \
    {
      ::maxima <<= im
    }

    #--------------------------------------------------
    proc ::set_radii(IMAGE im) \
    {
      ::radii <<= im
    }
    
    #--------------------------------------------------
    proc ::h(NUM gamma, NUM theta, NUM res) {
    #    ----
      tmp1=2*(gamma-1)
      theta2 = theta*theta
      tmp2=theta2-tmp1
      tmp2=tmp2*tmp2
      delta = tmp2+16-tmp1*tmp1
      res= sqrt((sqrt(delta)+tmp1-theta2)/(2*(3-gamma)))
    }
    
    #--------------------------------------------------
    proc ::rad2sigma(NUM rad, NUM sigma) {
    #    ------------
      sigma=::rad2sigma_coeff*rad
    }
    
    #--------------------------------------------------
    proc ::ComputeResponse(NUM sigma, IMAGE response,  IMAGE v1, IMAGE v2, IMAGE v3) \
    {
    #    ---------------
      printn "ComputeResponse with sigma = %1%" % sigma
    
      InitZero(response)
    
      # Computation of the direction
      # the results are 
      # _input_Hvep1, _input_Hvep2, _input_Hvep3
      # _input_Hvap1, _input_Hvap2, _input_Hvap3
      #
      # 1. Gamma normalized with the coefficient _gamma
      # 2. the eigenvalues are arranged into descending order of absolute values
      #
    
      # Old way: HessianMatrix(_input,sigma,_gamma)
      #
      # 2,2,0,1 means:
      # 3: 1st eigenvector & eigenvalue
      # 3: 2st eigenvector & eigenvalue
      # 0: don't need the third eigen(vector/value)
      # 1: gradient vector
      #
    
    
      if (::mode==0) {
        if (sigma<0.6) {
          InfoDialog "sigma = %1% is too small for second order derivatives: this scale is ignored." % sigma
        } else {
          Derivatives(::input,sigma,::gamma,3,3,1,1,::mask)
          vap1 = input_Hvap1
          vap2 = input_Hvap2
          v1  = input_Hvep1
          v2  = input_Hvep2
          v3  = input_Hvep3
          del input_Hvap1
          del input_Hvap2
          del input_Hvep1
          del input_Hvep2
      
          # create a region of interest
          mask1 = (UCHAR) ((::mask>0)*(vap1<0)*(vap2<0)*255)
      
          del vap1
          del vap2
        }
    
      }  else {
    
        # Compute Structure Tensor
        printn "Structure Tensor"
    
        StructTensorH(::input,sigma,1,::mask,1)
        v1  = input_STHvep1
        v2  = input_STHvep2    
        v3  = input_STHvep3
        input_grad = input_STHgrad
        del input_STHvap1
        del input_STHvap2
        del input_STHvap3
        del input_STHvep1
        del input_STHvep2
        del input_STHvep3
        del input_STHgrad
    
        mask1 = ::mask
      }
    
      # run the circle integration on a region of interest
      # Integrate the border information on a circle of radius theta*sigma
      if (::mode==0)&&(sigma<0.6) {
        response = 0
      } else {
        response = CircleInt( input_grad, v1, v2, ::theta*sigma, mask1)
      }
      # _response   = CircleIntSdExc( _input_grad,_v1,_v2,_theta*sigma,_mask1,1,1.5)
    
    
    } # ComputeResponse
    
    #-------------------------------------------------------------
    # inputs:
    #   Images
    #   - ::input
    #   - ::mask
    #   Other
    #   - sigma
    #   - ::current_progress
    #   - ::current_step
    #   - ::keep_eigenratio
    #   - ::normalize_gradient
    #   - ::PSF_stddev
    #   - ::grad_mask
    #   - ::use_linearinterp
    #   - ::SD_th
    #   - ::use_SD
    #   - ::EXC_th
    #   - ::use_EXC
    #   - ::local_maxima
    #
    # outputs:
    #   Images
    #   - response
    #   - ::current_eigenratio
    #   - ::current_v1
    #   - ::current_v2
    #
    #
    proc ::ComputeResponse_new( NUM sigma, IMAGE response) {
      printn "::ComputeResponse_new"
    
      InitZero(response)
    
      # Computation of the direction
      # the results are 
      #
      # 1. Gamma normalized with the coefficient _gamma
      # 2. the eigenvalues are arranged into descending order of absolute values
      #
    
      # Compute Structure Tensor
      inittime = wx.wxDateTime.UNow()
      sth = filters.StructureTensorH(&::input,sigma,1,&::mask)
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "Structure Tensor"
      printn "%|40t|time:%1%" % time_elapsed
      ::total_structtensor_time += diff
    
      SetProgress(::current_progress+::current_step*0.25)
    
      ## EigenDecomp, parameters:  the structure tensor,
      ## the eigenvalues flag: 0
      ## the eigenvectors flag 3
      #inittime = wx.wxDateTime.UNow()
      #eig = filters.EigenDecomp(&sth,0,3,&::mask)
      ## using eig[3] and eig[4]
      #diff=wx.wxDateTime.UNow()-inittime
      #time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      #printn "EigenDecomp time: "+time_elapsed
      
      #
      p = algorithms.ami_ImageToImageFilterParam.ImageToImageFilterParam()
      p.SetNumberOfThreads(wx.wxThread.GetCPUCount())
      p.SetInput(&sth)

      inittime = wx.wxDateTime.UNow()
      del ed
      ed = algorithms.ami_EigenDecomp.EigenDecomp()
      ed.SetParameters(&p)
      ed.Setdiag_algorithm(algorithms.ami_EigenDecomp.KOPP_HYBRID)
      ed.Setenable_eigenvalue1(::keep_eigenratio)
      ed.Setenable_eigenvalue2(::keep_eigenratio)
      ed.Setenable_eigenvalue3(false)
      ed.Setenable_eigenvector1(true)
      ed.Setenable_eigenvector2(true)
      ed.Setenable_eigenvector3(false)
      ed.Setmask(&::mask)
      ed.Run()
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "EigenDecomp2 time: %|40t|%1%" % time_elapsed
      #printn "EigenDecomp2 time: "+time_elapsed
      ::total_eigen_time        += diff

      if (::keep_eigenratio) {
        ::current_eigen_ratio <<= sqrt(ed.Geteigenvalue1())/\
                                       (sqrt(ed.Geteigenvalue2())+0.01)
      }

      # check that the 2 ways are identical
      #::eig_3 <<= eig[3]
      #::eig_3_new <<= ed.Geteigenvector1()
      #m = min(norm(eig[3]-ed.Geteigenvector1()),norm(eig[3]+ed.Geteigenvector1()))
      #printn  max(m)
      #m = min(norm(eig[4]-ed.Geteigenvector2()),norm(eig[4]+ed.Geteigenvector2()))
      #printn  max(m)

      SetProgress(::current_progress+::current_step*0.5)
      del sth
    
      # do we get the gradient separately to avoid the mask here??
      # normalized gradient
      #grad = gradient(::input,sigma)
      #if (::normalize_gradient) {
      #  grad = grad*sigma
      #}
      inittime = wx.wxDateTime.UNow()
      grad_algo = algorithms.Gradient(&::input,sigma,::normalize_gradient)
      grad_algo.SetPSF(::PSF_stddev,::PSF_stddev,::PSF_stddev)
      grad = grad_algo.Execute()
      if (exists(::grad_mask)) {
        grad = grad*(::grad_mask>0)
      }
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "Gradient time: %|40t|%1%" % time_elapsed
      ::total_gradient_time       += diff

      SetProgress(::current_progress+::current_step*0.75)
    
      # create a region of interest
      #_mask1 = (UCHAR) ((_mask>0)*(vap1<0)*(vap2<0)*255)
    
    
      #response = CircleMinIntSdExc(grad,\
                          #eig[3],\
                          #eig[4],\
                          #::theta*sigma, \
                          #::mask,\
                          #::SD_th*::use_SD,\
                          #::EXC_th*::use_EXC, \
                          #::pairs_mode, \
                          #::keephighest)
    
      # second response new way to do it
      inittime = wx.wxDateTime.UNow()
      repcircle = algorithms.CalculRepCercle(&grad,algorithms.CalculRepCercle.circle_mean)
      repcircle.SetGradient(&grad)
      repcircle.SetNoLinearInterp(!::use_linearinterp)
      repcircle.useSD(::SD_th*::use_SD)
      repcircle.useEXC(::EXC_th*::use_EXC)
      repcircle.ReducePairs(true,::pairs_mode)
      repcircle.KeepHighest(::keephighest)
      repcircle.FixeRayon(::theta*sigma,1)

      cb3d = algorithms.CircleBoundaries3D()
      cb3d.SetBoundaryComputationClass(repcircle)
      cb3d.SetMask(::mask)

      #e3 = eig[3]
      #e4 = eig[4]
      e3 = ed.Geteigenvector1()
      e4 = ed.Geteigenvector2()

      cb3d.SetOrientations(e3,e4)
      #::grad0 = grad
      #response
      cb3d.GetParameters().SetNumberOfThreads(wx.wxThread.GetCPUCount())
      cb3d.Execute(response)
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "Circle boundaries time: %|40t|%1%" % time_elapsed
      ::total_circle_time       += diff

      #diff = max(norm(response-::response2))
      #printn "Maximal difference = %1%" % diff

      # run the circle integration on a region of interest
      # Integrate the border information on a circle of radius theta*sigma
    
      # Error: I did not comment this line for the challenge !!!!
      #response = CircleInt( grad, eig[3], eig[4],
      #                        ::theta*sigma, ::mask)
    
      if (::local_maxima) {
        # copy the 2 eigenvectors
        ::current_v1 <<= e3
        ::current_v2 <<= e4
      }
    
    } 
    
    #---------------------------------------------------------------------------
    proc ::PrintExtent(OBJECT e, STRING mess) {
      # ::ComputeResponse_new
      printn  mess + "  %1%" % e.Xmin() + ", %1%" % e.Xmax() + \
                     "; %1%" % e.Ymin() + ", %1%" % e.Ymax() + \
                     "; %1%" % e.Zmin() + ", %1%" % e.Zmax() + \
                     " mode = %1%" % e.GetMode()
    }
      
    #---------------------------------------------------------------------------
    # run within an extent only
    #
    proc ::ComputeResponse_new_extent(  NUM sigma, \
                                        IMAGE response, \
                                        OBJECT extent) \
    {
      main_inittime = wx.wxDateTime.UNow()

      inittime = wx.wxDateTime.UNow()
      # add a margin to the extent?
      ::PrintExtent(extent, "extent")
      extent2 = extent
      #::PrintExtent(extent2,"extent2")
      # need to check the right margin to add
      imextent = response.GetExtent
      imextent.SetRelative(response)
      #::PrintExtent(imextent,"imextent")
      extent2.AddMargin(max(4,::theta*sigma*3),imextent)
      #::PrintExtent(extent2,"extent2")
      
      
      sub_response  = response[extent2]
      sub_mask      = ::mask  [extent2]
      sub_input     = ::input [extent2]
      #sub_response  = response[extent]
      #sub_mask      = ::mask  [extent]
      #sub_input     = ::input [extent]
      
      ::PrintExtent(extent2,"extent2")
      #sub_response.info

      printn "::ComputeResponse_new_extent"
      #sub_response.initvalue(0)
      InitZero(sub_response)
    
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "Initialization"
      printn "%|40t|time:%1%" % time_elapsed

      # Computation of the direction
      # the results are 
      #
      # 1. Gamma normalized with the coefficient _gamma
      # 2. the eigenvalues are arranged into descending order of absolute values
      #
    
      # Compute Structure Tensor
      inittime = wx.wxDateTime.UNow()
      #sth = filters.StructureTensorH(sub_input,sigma,1,sub_mask)
      # get the gradient at the same time
      
      #del ::grad0
      if (::use_StructTensorGrad) {
        grad0 = Image(FLOAT,3,sub_input)
        # decide on initial filtering
        max_vs = max(sub_input.vx,sub_input.vy)
        max_vs = max(max_vs,sub_input.vz)
        if (::speedup_convolutions)&&(sigma>4*max_vs) {
          #
          sigma0 = sqrt(sigma*sigma-4*max_vs*max_vs)
          printn "running filter with sigma0 = %1%" % sigma0
          # should set the support factor to max 5 ...
          sub_input_smoothed = filter(sub_input,sigma0,0,0,0)

          # should adjust PSF acording to voxel spacing
          psf = vector_float(3)
          psf[0] = (::PSF_stddev+sigma0)/sub_input.vx
          psf[1] = (::PSF_stddev+sigma0)/sub_input.vy
          psf[2] = (::PSF_stddev+sigma0)/sub_input.vz
          printn "running tensor with std = %1%" % (2*max_vs)
          sth = Func_StructureTensorHessianNew( sub_input_smoothed,\
                                                2*max_vs,\
                                                1,sub_mask,grad0,psf)
        } else {
          # should adjust PSF acording to voxel spacing
          psf = vector_float(3)
          psf[0] = ::PSF_stddev/sub_input.vx
          psf[1] = ::PSF_stddev/sub_input.vy
          psf[2] = ::PSF_stddev/sub_input.vz
          sth = Func_StructureTensorHessianNew(sub_input,sigma,1,sub_mask,grad0,psf)
        }
      } else {
        sth = Func_StructureTensorHessianNew(sub_input,sigma,1,sub_mask)
      }
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "Structure Tensor"
      printn "%|40t|time:%1%" % time_elapsed
      ::total_structtensor_time      += diff
    
      SetProgress(::current_progress+::current_step*0.25)
    
      ## EigenDecomp, parameters:  the structure tensor,
      ## the eigenvalues flag: 0
      ## the eigenvectors flag 3
      #inittime = wx.wxDateTime.UNow()
      #eig = filters.EigenDecomp(&sth,0,3,&::mask)
      ## using eig[3] and eig[4]
      #diff=wx.wxDateTime.UNow()-inittime
      #time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      #printn "EigenDecomp time: "+time_elapsed
      
      #
      p = algorithms.ami_ImageToImageFilterParam.ImageToImageFilterParam()
      p.SetNumberOfThreads(wx.wxThread.GetCPUCount())
      p.SetInput(&sth)

      inittime = wx.wxDateTime.UNow()
      del ed
      ed = algorithms.ami_EigenDecomp.EigenDecomp()
      ed.SetParameters(&p)
      ed.Setdiag_algorithm(algorithms.ami_EigenDecomp.KOPP_HYBRID)
      ed.Setenable_eigenvalue1(::keep_eigenratio)
      ed.Setenable_eigenvalue2(::keep_eigenratio)
      ed.Setenable_eigenvalue3(false)
      ed.Setenable_eigenvector1(true)
      ed.Setenable_eigenvector2(true)
      ed.Setenable_eigenvector3(false)
      ed.Setmask(sub_mask)
      ed.Run()
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "EigenDecomp2 time: %|40t|%1%" % time_elapsed
      ::total_eigen_time        += diff
      

      if (::keep_eigenratio) {
        #::current_eigen_ratio 
        sub_current_eigenratio <<= sqrt(ed.Geteigenvalue1())/\
                                   (sqrt(ed.Geteigenvalue2())+0.01)
      }

      # check that the 2 ways are identical
      #::eig_3 <<= eig[3]
      #::eig_3_new <<= ed.Geteigenvector1()
      #m = min(norm(eig[3]-ed.Geteigenvector1()),norm(eig[3]+ed.Geteigenvector1()))
      #printn  max(m)
      #m = min(norm(eig[4]-ed.Geteigenvector2()),norm(eig[4]+ed.Geteigenvector2()))
      #printn  max(m)

      SetProgress(::current_progress+::current_step*0.5)
      del sth
    
      # do we get the gradient separately to avoid the mask here??
      # normalized gradient
      #grad = gradient(::input,sigma)
      #if (::normalize_gradient) {
      #  grad = grad*sigma
      #}
      inittime = wx.wxDateTime.UNow()
      if (::use_StructTensorGrad) {
        grad = & grad0
      } else {
        grad_algo = algorithms.Gradient(sub_input,sigma,::normalize_gradient)
        grad_algo.SetPSF(::PSF_stddev,::PSF_stddev,::PSF_stddev)
        grad = grad_algo.Execute()
      }
      
      
      if (exists(::grad_mask)) {
        grad = grad*(::grad_mask[extent]>0)
      }
      #del ::grad
      #::grad = &grad
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "Gradient time: %|40t|%1%" % time_elapsed
      ::total_gradient_time       += diff

      SetProgress(::current_progress+::current_step*0.75)
    
      # create a region of interest
      #_mask1 = (UCHAR) ((_mask>0)*(vap1<0)*(vap2<0)*255)
    
    
      #response = CircleMinIntSdExc(grad,\
                          #eig[3],\
                          #eig[4],\
                          #::theta*sigma, \
                          #::mask,\
                          #::SD_th*::use_SD,\
                          #::EXC_th*::use_EXC, \
                          #::pairs_mode, \
                          #::keephighest)
    
      # second response new way to do it
      inittime = wx.wxDateTime.UNow()
      repcircle = algorithms.CalculRepCercle( grad,\
                                              algorithms.CalculRepCercle.circle_mean)
      repcircle.SetGradient(grad)
      repcircle.SetNoLinearInterp(!::use_linearinterp)
      repcircle.useSD(::SD_th*::use_SD)
      repcircle.useEXC(::EXC_th*::use_EXC)
      repcircle.ReducePairs(true,::pairs_mode)
      repcircle.KeepHighest(::keephighest)
      repcircle.FixeRayon(::theta*sigma,1)

      cb3d = algorithms.CircleBoundaries3D()
      cb3d.SetBoundaryComputationClass(&repcircle)
      cb3d.SetMask(sub_mask)

      #e3 = eig[3]
      #e4 = eig[4]
      e3 = ed.Geteigenvector1()
      e4 = ed.Geteigenvector2()

      cb3d.SetOrientations(e3,e4)
      #::grad0 = grad
      #response
      #sub_response2 = sub_response

      inittime2 = wx.wxDateTime.UNow()
      cb3d.GetParameters().SetNumberOfThreads(wx.wxThread.GetCPUCount())
      cb3d.Execute(sub_response)
      diff=wx.wxDateTime.UNow()-inittime2
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "Circle boundaries execute time: %|40t|%1%" % time_elapsed

      #inittime2 = wx.wxDateTime.UNow()
      #cb3d.Execute_old(sub_response2)
      #diff=wx.wxDateTime.UNow()-inittime2
      #time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      #printn "Circle boundaries execute old time: "+time_elapsed
      
      #d = sub_response-sub_response2
      #printn "max diff = %1% " % max(abs(d))
      
      
      ## save the 2 images for debugging purpose
      #if (!exists(::sub_response)) {
        #::sub_response  <<= sub_response
        #::sub_response2 <<= sub_response2
      #}
      
      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "Circle boundaries time: %|40t|%1%" % time_elapsed
      ::total_circle_time       += diff

      #diff = max(norm(response-::response2))
      #printn "Maximal difference = %1%" % diff

      # run the circle integration on a region of interest
      # Integrate the border information on a circle of radius theta*sigma
    
      # Error: I did not comment this line for the challenge !!!!
      #response = CircleInt( grad, eig[3], eig[4],
      #                        ::theta*sigma, ::mask)
    
    
      # put back result in full size images in initial extent
      extent3 = extent
      #::PrintExtent(extent3,"extent3")
      extent3.SetRelative(extent2)
      
      #::PrintExtent(extent3,"extent3")
      
      #printn "sub_response max %1%" % max(sub_response)
      # Need to check why sub_response[extent3] 
      # does not give the right translation
      del tmp
      xm = extent3.Xmin()
      xM = extent3.Xmax()
      ym = extent3.Ymin()
      yM = extent3.Ymax()
      zm = extent3.Zmin()
      zM = extent3.Zmax()
      tmp = sub_response[ xm:xM,ym:yM,zm:zM]
      #tmp.info
      response.putimage(tmp)
      #printn "response max %1%" % max(response)
      if (::local_maxima) {
        inittime = wx.wxDateTime.UNow()
        sub_current_maxima = LocalExtrema(sub_response,e3,e4,sub_mask)
        diff=wx.wxDateTime.UNow()-inittime
        del tmp
        tmp = sub_current_maxima[xm:xM,ym:yM,zm:zM]
        ::current_maxima.putimage(tmp)
        printn "::ComputeResponse_new_extent() LocalExtrema time: "+\
                wx.FromWxString(diff.Format("%M min %S s %l ms"))
      }
      if (::keep_eigenratio) {
        del tmp
        tmp = sub_current_eigenratio[extent3]
        ::current_eigen_ratio.putimage(tmp)
      }
    
      diff=wx.wxDateTime.UNow()-main_inittime
      printn "::ComputeResponse_new_extent() time: "+\
              wx.FromWxString(diff.Format("%M min %S s %l ms"))
    } 
    # ::ComputeResponse_new_extent

    #---------------------------------------------------------------------------
    # run within an extent only
    #
    proc ::ComputeResponse_new_split(  NUM sigma, \
                                       IMAGE response) \
    {
      
      main_inittime = wx.wxDateTime.UNow()
    
      # Split image to reduce memory usage
      image_size = (response.tx*response.ty*response.tz)*4/1000000

      # full images in memory: 
      #    - input and mask ?
      #    - response
      #    - if local_maxima, ::current_maxima and ::previous_maxima
      remaining_memory = (FLOAT)::max_memory_usage - 2*(image_size)
      maximages = 15 # 6 Hessian + 3 gradient + 6 store struct tensor
      
      if ::local_maxima {
        remaining_memory -= 2*image_size
        maximages++
      }
      if remaining_memory<0 {
        InfoDialog "Not enough memory to run on the input image !!!"
      }
      

      if(image_size<remaining_memory/maximages) {

        ::ComputeResponse_new(sigma,response)
        
      } else {
        # choose splitting strategy
        size = vector_int(3)
        size[0] = response.tx
        size[1] = response.ty
        size[2] = response.tz
        reduction = vector_int(3)
        reduction[0] = 1
        reduction[1] = 1
        reduction[2] = 1
        
        big = image_size>(remaining_memory/maximages)
        printn ("image size = %1%" % image_size) + (" big %1%" % big) 

        
        while big  {
          # increase reduction on bigger axis
          if (size[0]/reduction[0] > size[1]/reduction[1]) {
            if (size[0]/reduction[0] > size[2]/reduction[2]) {
              reduction[0]++
            } else {
              reduction[2]++
            }
          } else {
            if (size[1]/reduction[1] > size[2]/reduction[2]) {
              reduction[1]++
            } else {
              reduction[2]++
            }
          }
        
          image_size = size[0]*size[1]*size[2]/\
                        (reduction[0]*reduction[1]*reduction[2])
          image_size *= 4/1000000
          
          #printn ("image size = %1%" % image_size) + (" big %1%" % big) + \
                  #("max = %1% " % (1/12*::max_memory_usage))
          big = image_size>(remaining_memory/maximages)
        }
        printn  ("Reduction factors %1% " % reduction[0]) + \
                (" x %1%" % reduction[1]) + \
                (" x %1%" % reduction[2])
        smallsize_x = (FLOAT)size[0]/reduction[0]
        smallsize_y = (FLOAT)size[1]/reduction[1]
        smallsize_z = (FLOAT)size[2]/reduction[2]
        current_step = ::current_step
        ::current_step = ::current_step/(reduction[0]*reduction[1]*reduction[2])
        response = 0
        # now should run with extents
        for i=0 to reduction[0]-1 {
          for j=0 to reduction[1]-1 {
            for k=0 to reduction[2]-1 {
              #if(i==0)&&(j==0)&&(k==0) {
                del e
                # extent is relative to the response image
                e = ami_ImageExtent_float()
                e.SetXmin(round(smallsize_x*i))
                e.SetXmax(min(response.tx-1,round(smallsize_x*(i+1)-1)))
                e.SetYmin(round(smallsize_y*j))
                e.SetYmax(min(response.ty-1,round(smallsize_y*(j+1)-1)))
                e.SetZmin(round(smallsize_z*k))
                e.SetZmax(min(response.tz-1,round(smallsize_z*(k+1)-1)))
                # extent is relative to the image
                e.SetMode(ami_ImageExtent_float.Relative)
                e._print()
                ::ComputeResponse_new_extent( sigma, response, e)
                ::current_progress += ::current_step
              #}
            }
          }
        }
        
      } 
      
      diff=wx.wxDateTime.UNow()-main_inittime
      printn "::ComputeResponse_new_split() time: "+\
              wx.FromWxString(diff.Format("%M min %S s %l ms"))
    }

    #--------------------------------------------------
    #
    # mode is 0: use Hessian matrix
    # mode is 1: use Structure tensor
    #
    proc ::MultiLines( ) \
    {
      current_proc = "::MultiLines()"
      InitTime

      #  Load input images
      if (!exists(::input)) {
        ::load_input()
      }
      if (!exists(::mask)) {
        ::update_mask()
      }

      # Precompute coefficient of proportionality
      ::h(::gamma,::theta,&::rad2sigma_coeff)
    
      ::current_rad=::radmin
    
      ::current_sigma=0
      if (::numrad>1) {
        _step=exp((ln(::radmax)-ln(::radmin))/(::numrad-1))
      } else {
        _step = 1
      }
    
      #
      # main loop 
      #
    
      response=Image(FLOAT,1,::input)
      InitZero(response)
    
      if (::keep_all_scales) {
        ::all_responses <<= Image(FLOAT,::input.tx,::input.ty,::input.tz,::numrad)
      }

      v1=Image(FLOAT,3,::input)
      InitZero(v1)
      v2=Image(FLOAT,3,::input)
      InitZero(v2)
      v3=Image(FLOAT,3,::input)
      InitZero(v3)
    
#      ::all_responses     = VarVector()
#      ::all_maxresponses  = VarVector()
#      ::all_radii         = VarVector()
#      ::all_current_radii = VarVector()

      for i=0 to ::numrad-1 {
        iteration_mess = " Iteration %1%" % i
        SetStatusText( current_proc+iteration_mess )
        ::current_progress = (FLOAT)i/::numrad*100
        ::current_step     = 1/::numrad*100
        SetProgress(::current_progress)
    
        ::rad2sigma(::current_rad,&::current_sigma)
#        ::all_current_radii.push_back(::current_rad)
      
        ::ComputeResponse( ::current_sigma, \
                            &response, \
                            &v1, &v2,&v3)
#        ::all_responses.push_back(response)

        if (::keep_all_scales) {
          ::all_responses.SetComponent(i,response)
        }
    
        # save response to file
        #response_filename=result.GetName-".gz"-".inr"-".ami"-".vtk"
        #response_filename = "multilines"
        #response_filename = sprint("rep%02.0f.ami.gz",_i)
        #response.save response_filename
        #response.save sprint("rep%02.0f.ami.gz",_i)
    
    
        # Compute and Update Local Maxima
        print "Compute and Update Local Maxima\n"
    
        # keep maximal response
        if (i==0) {
          max_response=response
 #        ::all_maxresponses.push_back(max_response)
          
          prev_response=response
          current_maxima <<= response*0
          ::maxima <<= response*0
          v1_max=v1
          v2_max=v2
          v3_max=v3
          radius = (response>0)*::current_rad;
        } else {
          printn "get here"
          # Update the maxima
          # only keep the first maxima found
          ::maxima = (::maxima!=0)*::maxima+(::maxima==0)*(current_maxima>response)*current_maxima
    
          v1_max = v1_max*(max_response>=response)+v1*(max_response<response)
          v2_max = v2_max*(max_response>=response)+v2*(max_response<response)
          v3_max = v3_max*(max_response>=response)+v3*(max_response<response)
          radius = (response<max_response)*radius+(response>=max_response)*::current_rad
          max_response=max(response,max_response)
 #        ::all_maxresponses.push_back(max_response)
         # Compute local maxima
          current_maxima = LocalExtrema(response,v1,v2,::mask)
          current_maxima = current_maxima*(response>prev_response)
        }
    
 #       ::all_radii.push_back(radius)
        ::current_rad = ::current_rad*_step
        SetProgress(i/::numrad*100)
        # process several graphic events
        ProcessEvents(100)
      }
    
      
    #  v3_max.save sprint("v3_max_%01.0f.ami.gz",::mode)
    #  v2_max.save sprint("v2_max_%01.0f.ami.gz",mode)
    
      # computing local maxima on the maximum response accross scales
      ::maxima2 = LocalExtrema(max_response,v1_max,v2_max,::mask)
    
      # save maximal response to file
      ::result    = max_response
      ::radii     <<= radius
    
      SetProgress(0)
      SetStatusText( "Finished MultiLines" )
      EndTime
    } 
    # end MultiLines()
    #--------------------------------------------------
    #
    # mode is 0: use Hessian matrix
    # mode is 1: use Structure tensor
    #
    proc ::MultiLines_new( ) \
    {
      printn "###############################################"
      printn " ::MultiLines_new( )"
      printn "###############################################"
      current_proc = "::MultiLines_new()"
      if (!exists(::SD_th)) {
        InfoDialog "MultiLines_new Multilines not initialized"
      }

      # TODO: adapt for ROI
      inittime = wx.wxDateTime.UNow()
      
      # initialize total time counters
      del ::total_circle_time
      ::total_circle_time       = wx.wxTimeSpan()
      del ::total_structtensor_time
      ::total_structtensor_time = wx.wxTimeSpan()
      del ::total_gradient_time
      ::total_gradient_time        = wx.wxTimeSpan()
      del ::total_eigen_time
      ::total_eigen_time        = wx.wxTimeSpan()

      #  Load input images
      if (!exists(::input)) {
        ::load_input()
      }
      
      if (!exists(::mask)) {
        ::update_mask()
      }

      # Precompute coefficient of proportionality
      ::h(::gamma,::theta,&::rad2sigma_coeff)
    
      ::current_rad   = ::radmin
      ::current_sigma = 0

      if (::numrad>1) {
        _step=exp((ln(::radmax)-ln(::radmin))/(::numrad-1))
      } else {
        _step = 1
      }
    
      #
      # main loop 
      #
      response<<=Image(FLOAT,1,::input)
      InitZero(response)

      if (::keep_all_scales) {
        ::all_responses <<= Image(FLOAT,::input.tx,::input.ty,::input.tz,::numrad)
      }
    

      time_before_loop = wx.wxDateTime.UNow()

      for i=0 to ::numrad-1 {
        iteration_mess = "----- Iteration %1% -----" % i
        SetStatusText( current_proc+iteration_mess )
        printn iteration_mess
        ::current_progress = (FLOAT)i/::numrad*100
        ::current_step     = 1/::numrad*100
        SetProgress(::current_progress)
    
    
        ::rad2sigma(::current_rad,&::current_sigma)
    
        printn sprint(" radius = %0.2f",::current_rad)
        printn sprint(" sigma = %0.2f", ::current_sigma)
    
        if (::split_image) {
          if (::local_maxima) {
            ::current_maxima <<= response*0
          }
          ::ComputeResponse_new_split(::current_sigma, response)
          printn "response max %1%" % max(response)
        } else {
          ::ComputeResponse_new      (::current_sigma, response)
        }
        if (::enable_track) {
          printn "Iteration %1%" %i
          printn "Response obtained = %1%" % \
                    response(::trackvoxel_x,::trackvoxel_y,::trackvoxel_z)
        }
    
        if (::keep_all_scales) {
          ::all_responses.SetComponent(i,response)
        }

        # Compute and Update Local Maxima
        SetStatusText( iteration_mess + \
                        "Compute and Update Local Maxima")
    
        # keep maximal response
        if (i==0) {
          max_response=response
          if (::local_maxima) {
            # 3 more images in memory
            ::previous_maxima <<= response*0
            ::num_lmax <<= ((UCHAR) response)*0
            ::maxima       <<= response*0
            if (::keep_orientations) {
              # check how to get the vectors here, or keep the symmetric matric??
              #v1_max=v1
              #v2_max=v2
              #v3_max=v3
            }
            if (::keep_radii) {
              radius = (response>0)*::current_rad;
            }
            if (::keep_eigenratio) {
              ::eigen_ratio = ::current_eigen_ratio
            }
          }
        } else {

          if (::local_maxima) {
            # Update the maxima
            # only keep the first maxima found
            ::maxima =  (::maxima!=0)*::maxima+\
                        (::maxima==0)*(::previous_maxima>response)*::previous_maxima
            # we are only interested in positive responses ...
            ::num_lmax = ::num_lmax+(::previous_maxima>response)*(response>0)
            if (::keep_orientations) {
              # to do
              #v1_max = v1_max*(max_response>=response)+v1*(max_response<response)
              #v2_max = v2_max*(max_response>=response)+v2*(max_response<response)
              #v3_max = v3_max*(max_response>=response)+v3*(max_response<response)
            }
            if (::keep_radii) {
              radius = (max_response>=response)*radius+(max_response<response)*::current_rad
            }
            if (::keep_eigenratio) {
              ::eigen_ratio = ::current_eigen_ratio*(max_response>=response)+\
                              ::eigen_ratio*(max_response<response)
              del ::current_eigen_ratio
            }
            # in case of splitting, current maxima is already computed
            if (!::split_image) {
              # Compute local maxima
              ::current_maxima = LocalExtrema(response,::current_v1,::current_v2,::mask)
            }
            if (::enable_track) {
              printn "Local Extrema value =  %1%" % \
                   ::current_maxima(::trackvoxel_x,::trackvoxel_y,::trackvoxel_z)
            }
            ::previous_maxima = ::current_maxima*(response>prev_response)
            del ::current_maxima
          } 
          # end if (::local_maxima)
          max_response=max(response,max_response)
        } 
    
        if (::local_maxima) {
          # keep current response as previous response for next iteration
          prev_response=response
        }
        ::current_rad = ::current_rad*_step
        SetProgress(i/::numrad*100)
      }

      time_after_loop = wx.wxDateTime.UNow()

      # free memory from global images used for the computation
      if (::local_maxima) {
        del ::current_v1
        del ::current_v2
        del ::previous_maxima
      }

      # set the result image
      ::result <<= max_response
      if ((::local_maxima)&&(::keep_radii)) {
        ::radii  <<= radius
      }

      # check for NaN
      nan_count_rep = ami_count(::result!=::result)
      if (nan_count_rep) {
        InfoDialog "Nan values found in response : %1% !" % nan_count_rep
      }
      if (::local_maxima) {
        nan_count_lmax = ami_count(::maxima!=::maxima)
        if (nan_count_lmax) {
          InfoDialog "Nan values found in local maxima : %1% !" % nan_count_lmax
        }
      }

      SetProgress(0)

      diff=wx.wxDateTime.UNow()-inittime
      time_elapsed = wx.FromWxString(diff.Format("%M min %S s %l ms"))
      printn "Total Boundary circle time: "+\
              wx.FromWxString(::total_circle_time.Format("%M min %S s %l ms"))
      printn "Total Struct Tensor   time: "+\
              wx.FromWxString(::total_structtensor_time.Format("%M min %S s %l ms"))
      printn "Total Gradient        time: "+\
              wx.FromWxString(::total_gradient_time.Format("%M min %S s %l ms"))
      printn "Total Eigen decomp    time: "+\
              wx.FromWxString(::total_eigen_time.Format("%M min %S s %l ms"))
      printn "Total time: "+time_elapsed

      printn "Before loop: "+\
              wx.FromWxString((time_before_loop-inittime).Format("%M min %S s %l ms"))
      printn "Durring loop: "+\
              wx.FromWxString((time_after_loop-time_before_loop).Format("%M min %S s %l ms"))
      printn "After loop: "+\
              wx.FromWxString((wx.wxDateTime.UNow()-time_after_loop).Format("%M min %S s %l ms"))
      
      SetStatusText( "Finished MultiLines_new (%1%)" % time_elapsed )

      printn "###############################################"
    } # MultiLines_new

    #-----------------------------------------------
    proc ::CB_ROI() {
      if (exists(::input_draw)) {
        ::roi <<= ::input[::input_draw]
        ::roi_contour = (UCHAR) ::input*0
        ::roi = 1
        ::roi_contour.putimage(::roi)
        ::Display()
      }
    }

    #-----------------------------------------------
    proc ::DisplayResult() {
      show ::input
      if (exists(::result)) {
        show ::result
        ::input_draw.compare(&::result_draw)
      }
      if (exists(::roi_contour)) {
        ::input_draw.SetIsoContour(0,::roi_contour,0.5)
        ::input_draw.DrawIsoContour(0,1)
      }
    }
    
    #-----------------------------------------------
    proc ::DisplayLMax() {
      show ::input
      if (exists(::maxima)) {
        show ::maxima
        ::input_draw.compare(&::maxima_draw)
      }
    }

    #-----------------------------------------------
    proc ::DisplayRadii() {
      show ::input
      if (exists(::radii)) {
        show ::radii
        ::input_draw.compare(&::radii_draw)
      }
    }

    #-----------------------------------------------
    proc ::Save() {
      ::result.save ::output_name
    }
    
    #-----------------------------------------------
    proc ::OnLocalMaxima() \
    {
      printn "::OnLocalMaxima()"
      printn " val = %1%" % ::local_maxima>0
      ::win.Enable(::keep_or_id, ::local_maxima>0)
      ::win.Enable(::keep_rad_id,::local_maxima>0)
      ::win.Update(-1)
    }

    #-----------------------------------------------
    proc ::CreateSkeleton() \
    {
      ::skeleton_obj.Execute()
    }

    #-----------------------------------------------
    proc ::PruneSkeleton() \
    {
      ::skeleton_obj.SelectPrune()
      ::skeleton_obj.RemovePrune()
    }

    #-----------------------------------------------
    proc ::SmoothSkeleton() \
    {
      ::skeleton_obj.Smooth_Lines()
    }

    #-----------------------------------------------
    proc ::DisplaySkeleton() \
    {
      ::skeleton_obj.Display()
    }

    #-----------------------------------------------
    proc ::SmoothedReconstruction() \
    {
      if (!exists(::radii)) { 
        InfoDialog "Radii image has not been created, enable saving the radii !" 
      } else {
        if (!exists(::skeleton_obj->lines)) {
          InfoDialog "No centerlines"
        } else {
          # smooth radii
          ::radii_smoothed <<= ::radii
          nl = ::skeleton_obj.lines.GetNumberOfLines()
          for l=0 to nl-1 {
            printn "Processing line %1%" % (l+1) + " of %1%" % nl
            line <<= ::skeleton_obj.lines.GetLine(l)
            line_radii <<= ::radii(line)
            line_radii_smoothed <<= filter(line_radii,::smoothradii_std,0,0,0)
            # put back the smooth values in the image
            for k=0 to line.tx-1 {
              ::radii_smoothed.setpos(line(k,0,0,0),line(k,0,0,1),line(k,0,0,2))
              ::radii_smoothed.set(line_radii_smoothed(k,0,0,0))
            }
          }
          # reconstruction
          rad_info = ::skeleton_obj.lines.GetIntensities(&::radii_smoothed)
          if exists(::skeleton_obj->slines) { l = &::skeleton_obj.slines; } else { l = &::skeleton_obj.lines; }
          func "ShortCuts/ShortCuts.amil"
          if (::upsample_recons) {
            in2 = Resize(::input,::input.tx*2,::input.ty*2,::input.tz*2,0)
            ::s_recons <<= LineRecons(l, in2, rad_info)            
          } else {
            ::s_recons <<= LineRecons(l, ::input, rad_info)
          }
        }
      }
    }

    #-----------------------------------------------
    proc ::CreateReconstruction() \
    {
      # check existence of radius image or use constant radius
      if (!exists(::radii)) { 
        InfoDialog "Radii image has not been created, enable saving the radii !" 
      } else {
        # check existence of centerlines
        if (!exists(::skeleton_obj->lines)) {
          InfoDialog "No centerlines"
        } else {
          rad_info = ::skeleton_obj.lines.GetIntensities(&::radii)
          if exists(::skeleton_obj->slines) { l = &::skeleton_obj.slines; } else { l = &::skeleton_obj.lines; }
          func "ShortCuts/ShortCuts.amil"
          if (::upsample_recons) {
            in2 = Resize(::input,::input.tx*2,::input.ty*2,::input.tz*2,0)
            ::recons <<= LineRecons(l, in2, rad_info)            
          } else {
            ::recons <<= LineRecons(l, ::input, rad_info)
          }
        }
      }
      
    }

    #-----------------------------------------------
    proc ::DisplayReconstruction() \
    {
      if (exists(::recons)) {
        show ::recons
        ::recons_surf = isosurf(::recons,255*exp(-0.5))
        if (exists(::s_recons)) {
          ::s_recons_surf = isosurf(::s_recons,255*exp(-0.5))
        }
        ::viewer = Viewer3D("Reconstruction")
        if exists(::used_lines)  { del ::used_lines; }
        if exists(::skeleton_obj->slines) { ::used_lines = &::skeleton_obj.slines; } else {  ::used_lines = &::skeleton_obj.lines; }
        ::viewer += ::used_lines
        ::viewer += ::recons_surf
        if (exists(::s_recons_surf)) {
          ::viewer += ::s_recons_surf
        }
      }
    }

    #-----------------------------------------------
    proc ::Gui() \
    {
      if (exists(::parent_panel)) {
        ::win = ParamPanel("MultiLines",&::parent_panel)
      } else {
        ::win = ParamPanel("MultiLines")
      }
      ::win.BeginBook()
        ::win.AddPage("IO")
          # set the input image
          ::win.BeginHorizontal()
            ::win.AddImageChoice( &::input_name, "Input")
            ::AddBitmapButton(&::win, &::icons._Copy,   16, "load_input")
            ::win.SetPositionProp(-1,0)
          ::win.EndHorizontal()

          ::win.BeginBoxPanel("Mask")
            maskmode_id = ::win.AddEnum(&::mask_mode, "Mode")
              ::win.AddEnumChoice(maskmode_id,"Threshold from input")
              ::win.AddEnumChoice(maskmode_id,"Mask image")

            # set the mask threshold
            ::mask_lowthreshold_id  = ::win.AddFloat(&::mask_lowthreshold,\
                                                    "Low Threshold",0,100)
            ::mask_highthreshold_id = ::win.AddFloat(&::mask_highthreshold,\
                                                    "High Threshold",0,100)

            # set the mask image
            ::win.AddImageChoice( &::mask_name, "Mask")
            ::win.AddButton("Update",&::update_mask)
          ::win.EndBoxPanel()
        
        ::win.AddPage("Circle")

          ::win.AddBoolean( &::use_SD,"Use StdDev")
          ::win.AddFloat( &::SD_th,"StdDev_thres", 0,10)
          ::win.AddBoolean( &::use_EXC,"Use Exc")
          ::win.AddFloat( &::EXC_th,"Exc_thres",0,10)
          pairmodeid = ::win.AddEnum( &::pairs_mode)
            ::win.AddEnumChoice(pairmodeid,"Min")
            ::win.AddEnumChoice(pairmodeid,"Max")
            ::win.AddEnumChoice(pairmodeid,"Mean")
          ::win.AddFloat( &::keephighest,  "Keephighest", 0,100)
          
          ::win.AddFloat(::theta,"radius proportion",0.5,10)

        ::win.AddPage("Scales")
          ::win.BeginBoxPanel("Radii (or scales)")
            ::win.AddFloat( &::radmin,"min.",0.5,10)
            ::win.AddFloat( &::radmax,"max.",0.5,10)
            ::win.AddInt( &::numrad,"number",1,20)
          ::win.EndBoxPanel()
        
          ::localmax_id = ::win.AddBoolean( &::local_maxima,"Local maxima")
          ::win.SetCallback(&::OnLocalMaxima)
          ::keep_or_id  = ::win.AddBoolean( &::keep_orientations,"Orientations")
          ::keep_rad_id = ::win.AddBoolean( &::keep_radii,"Radii")
          ::keep_ratio_id = ::win.AddBoolean( &::keep_eigenratio,"Eigenvalue ratio")

        ::run_page = ::win.AddPage("Run")
          modeid = ::win.AddEnum( &::mode)
            ::win.AddEnumChoice(modeid,"Hessian Matrix")
            ::win.AddEnumChoice(modeid,"Structure Tensor")

          ::win.AddBoolean( ::keep_all_scales, "Keep all scales")
          ::win.AddBoolean( ::normalize_gradient, "Normalize gradient")
          ::win.AddBoolean( ::use_StructTensorGrad, "Use gradient from Structure Tensor")
          ::win.AddFloat(   ::PSF_stddev, "PSF")
          ::win.AddBoolean( ::use_linearinterp, "Linear Interpolation")
          ::win.AddBoolean( ::speedup_convolutions, "Speed-up convolutions")

          ::win.BeginBoxPanel("Controls")
            ::win.BeginHorizontal()
              ::win.AddButton("Select ROI", ::CB_ROI)
              ::win.AddButton("Run",        ::MultiLines)
            ::win.EndHorizontal()
            ::win.BeginBoxPanel("New version")
              ::win.AddButton("Run new",    ::MultiLines_new)
              ::win.AddBoolean(::split_image,"Split image for memory usage")
              ::win.AddInt(::max_memory_usage, "max memory Mb",100,10000) 
            ::win.EndBoxPanel()
            ::outputname_id = ::win.AddString( &::output_name, "Output")
            ::win.BeginBoxPanel("Display")
              ::win.BeginHorizontal()
                display_id = ::win.AddButton("Result",    &::DisplayResult)
                display_id = ::win.AddButton("Local max", &::DisplayLMax)
                display_id = ::win.AddButton("Radii",     &::DisplayRadii)
              ::win.EndHorizontal()
            ::win.EndBoxPanel()
            display_id = ::win.AddButton("Save",       ::Save)
          ::win.EndBoxPanel()

        ::recons_page = ::win.AddPage("Recons")

          ::win.BeginBoxPanel("Skeleton")
            ::win.BeginHorizontal()
              ::win.AddButton("Create", &::CreateSkeleton)
              ::win.AddButton("Display",&::DisplaySkeleton)
              ::win.AddButton("Prune",  &::PruneSkeleton)
              ::win.AddButton("Smooth", &::SmoothSkeleton)
            ::win.EndHorizontal()
          ::win.EndBoxPanel()

          ::win.BeginBoxPanel("Reconstruction")
            ::win.AddBoolean(&::upsample_recons,"Upsample x2")
            ::win.BeginHorizontal()
              ::win.AddButton("Create",   &::CreateReconstruction)
              ::win.AddButton("Create Smoothed", &::SmoothedReconstruction)
              ::win.AddButton("Display",  &::DisplayReconstruction)
            ::win.EndHorizontal()
          ::win.EndBoxPanel()

          ::win.BeginBook()
            ::skeleton_obj.SetParentPanel(&::win)
            ::skeleton_obj.Gui()
            ::win.AddPage("Skeleton",&::skeleton_obj.win)
          ::win.EndBook()

        ::recons_page = ::win.AddPage("Track")
          ::win.BeginBoxPanel("Voxel to track")
            ::win.AddInt(::trackvoxel_x,"X=",0,1024)
            ::win.AddInt(::trackvoxel_y,"Y=",0,1024)
            ::win.AddInt(::trackvoxel_z,"Z=",0,1024)
          ::win.EndBoxPanel()
          ::win.AddBoolean(::enable_track,"Enable tracking")

        # add page for saving/loading parameters
        ::AddParamPage(::win)
        # only save variables containing 'Param:' in their comments
        ::SetParamCommentsFilter(".*Param:.*")

       ::win.EndBook()
    
      ::AddStandardButtons(&::win)

    
      if (exists(::parent_panel)) {
        ::win.ShowPanel()
      } else {
        ::win.Display()
      }
      ::OnLocalMaxima()
      ::win.Update(-1)
      
    }
    
    ::Init()
    
  
  } #End of class
  
} # End of if

      