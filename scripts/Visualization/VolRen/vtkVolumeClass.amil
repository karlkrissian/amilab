
func "Common/ScriptGui"

import_vtk

if (!exists(vtkVolumeClass)) {

  #-----------------------------------------------------
  #  vtkVolumeClass
  #-----------------------------------------------------
  Class vtkVolumeClass : public ScriptGui {

    # load the ImageHistogram script
    func "Visualization/ImageHistogram/ImageHistogramClass.amil"
    ImageHistogramClass             ::imhisto1

    #----------------------------
    proc ::Init( ) {
      ::blend_type = INT(1), "Blend type: 0->MIP, 1->CompositeRamp, 2->CompositeShadeRamp, 3->CT_Skin, 4->CT_Bone, 5->CT_Muscles, 6->RGB_Composite, 7->Linear Curve 1"
      ::opacitywindow = 1000, "Opacity Window"
      ::opacitylevel  = 1000, "Opacity Level"

      ::skin1 = -1000, "Skin first control point"
      ::skin2 =  -500, "Skin second control point"

      ::bones1 = -16,  "Bones first control point"
      ::bones2 =  641, "Bones second control point"

      ::muscles1 = -155, "Muscles first control point"
      ::muscles2 =  217, "Muscles second control point"
      ::muscles3 =  420, "Muscles third control point"

      ::clip = UCHAR(0), "Enable/Disable clipping box"
      ::initialized=0

      ::cm_active_blend_curves = 0, "Number of curves created for the current blend type in the Colormap  drawing area."
      ::dw_active_blend_curves = 0, "Number of curves created for the current blend type in the Histogram drawing area."

      ::opacity_attenuation = 1, "Attenuation factor for the opacity"
    }

    #----------------------------
    proc ::SetInteractor( OBJECT inter ) {
      ::renwininter = &inter
    }

    #----------------------------
    proc ::SetRenderer( OBJECT ren ) {
      ::renderer = &ren
    }

    # Inputs:
    #   input_image : input InrImage volume
    #
    # Outputs:
    #   vol        : vtkVolume
    #   volmapper  : vtkGPUVolumeRayCastMapper
    #   colorFun   : vtkColorTransferFunction
    #   opacityFun : vtkPiecewiseFunction
    #   property   : vtkVolumeProperty
    #
    proc ::CreateVTK( IMAGE input_image) {

      ::input = &input_image

      # 10/(1+clip) in c++ code
      #::renwin_interact.SetDesiredUpdateRate(10)

      # check that we have a volume
      if (input_image.tx<2)||(input_image.ty<2)||(input_image.tz<2) {
        InfoDialog "Input image is not a volume!"
        return = 0
      } else {
        ::vol       = global::vtkVolume_New()
        ::volmapper = global::vtkGPUVolumeRayCastMapper_New()
        # don't put the boxwidget for the moment
        # convert input to vtkimage
        ::vtkinput  = global::ToVtkImageData(&input_image)
        ::volmapper.SetInput(&::vtkinput)

        #::volmapper.SetSampleDistance()

        # Create our transfer function
        ::colorFun=global::vtkColorTransferFunction_New()
        ::opacityFun=global::vtkPiecewiseFunction_New()
        
        # Create the property and attach the transfer functions
        ::property = global::vtkVolumeProperty_New()
        ::property.SetIndependentComponents(1)
        ::property.SetColor( &::colorFun )
        ::property.SetScalarOpacity( &::opacityFun )
        ::property.SetInterpolationTypeToLinear()
 
        # connect up the volume to the property and the mapper
        ::vol.SetProperty( &::property )
        ::vol.SetMapper( &::volmapper )
        ::initialized = 1

        return = 1
      }
    }

    #----------------------------
    proc ::InitBoxWidget() \
    {
      ::box = global::vtkBoxWidget_New()
      if (::clip) \
      {
        ::box.SetInteractor(&::renwininter)
        ::box.SetPlaceFactor(1.01)
        ::box.SetInput(&::vtkinput)
        
        ::box.SetDefaultRenderer(&::renderer)
        ::box.InsideOutOn()
        ::box.PlaceWidget()
        #vtkBoxWidgetCallback *callback = vtkBoxWidgetCallback::New();
        #callback->SetMapper(mapper);
        #::box.AddObserver(vtkCommand::InteractionEvent, callback);
        #callback->Delete();
        ::box.EnabledOn()
        #::box.GetSelectedFaceProperty().SetOpacity(0.0)
      }
    }

    #----------------------------
    proc ::ResetVTK() \
    {
      ::initialized = 0
      del ::renwininter # it is a reference, no call to Delete()
      del ::input

      ::vol.Delete() # here should do it with variable smart pointers
      del ::vol
      ::volmapper.Delete()
      del ::volmapper
      ::colorFun.Delete()
      del ::colorFun
      ::opacityFun.Delete()
      del ::opacityFun
      ::property.Delete()
      del ::property
    }

    #----------------------------
    proc ::BlendMIP() \
    {
      ::colorFun.AddRGBSegment(0.0, 1.0, 1.0, 1.0, 255.0, 1.0, 1.0, 1.0 );
      ::opacityFun.AddSegment( ::opacitylevel - 0.5*::opacitywindow, 0.0, \
                             ::opacitylevel + 0.5*::opacitywindow, ::opacity_attenuation );
      ::volmapper.SetBlendModeToMaximumIntensity();
    }

    #----------------------------
    proc ::BlendCompositeRamp() \
    {
      ::colorFun.AddRGBSegment( ::opacitylevel - 0.5*::opacitywindow, 0.0, 0.0, 0.0, \
                              ::opacitylevel + 0.5*::opacitywindow, 1.0, 1.0, 1.0 )

      ::opacityFun.AddSegment( ::opacitylevel - 0.5*::opacitywindow, 0.0, \
                             ::opacitylevel + 0.5*::opacitywindow, ::opacity_attenuation )

      ::volmapper.SetBlendModeToComposite()
      ::property.ShadeOff()
    }

    #----------------------------
    proc ::BlendCompositeShadeRamp() \
    {
      ::colorFun.AddRGBSegment(0.0, 1.0, 1.0, 1.0, 255.0, 1.0, 1.0, 1.0 );
      ::opacityFun.AddSegment( ::opacitylevel - 0.5*::opacitywindow, 0.0, \
                               ::opacitylevel + 0.5*::opacitywindow, ::opacity_attenuation );
      ::volmapper.SetBlendModeToComposite();
      ::property.ShadeOn();
    }


    #----------------------------
    proc ::SkinReset() \
    {
      ::skin1 = -1000
      ::skin2 =  -500
      ::win.Update(-1)
      ::OnRender()
    }

    #----------------------------
    proc ::BlendCTSkin() \
    {
      ::colorFun.AddRGBPoint( -3024, 0, 0, 0, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( ::skin1, 0.62, 0.36, 0.18, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( ::skin2, 0.88, 0.60, 0.29, 0.33, 0.45 );
      ::colorFun.AddRGBPoint( 3071, 0.83, 0.66, 1, 0.5, 0.0 );
      
      ::opacityFun.AddPoint(-3024, 0, 0.5, 0.0 );
      ::opacityFun.AddPoint(::skin1, 0, 0.5, 0.0 );
      ::opacityFun.AddPoint(::skin2, 1.0*::opacity_attenuation, 0.33, 0.45 );
      ::opacityFun.AddPoint(3071, 1.0, 0.5, 0.0);

      ::volmapper.SetBlendModeToComposite();
      ::property.ShadeOn();
      ::property.SetAmbient(0.1);
      ::property.SetDiffuse(0.9);
      ::property.SetSpecular(0.2);
      ::property.SetSpecularPower(10.0);
      ::property.SetScalarOpacityUnitDistance(0.8919);
    }


    #----------------------------
    proc ::BonesReset() \
    {
      ::bones1 = -16
      ::bones2 =  641
      ::win.Update(-1)
      ::OnRender()
    }

    #----------------------------
    proc ::BlendCTBones() \
    {
      ::colorFun.AddRGBPoint( -3024, 0, 0, 0, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( ::bones1, 0.73, 0.25, 0.30, 0.49, 0.61 );
      ::colorFun.AddRGBPoint( ::bones2, 0.90, 0.82, 0.56, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( 3071, 1, 1, 1, 0.5, 0.0 );
      
      ::opacityFun.AddPoint(-3024, 0, 0.5, 0.0 );
      ::opacityFun.AddPoint(::bones1, 0   *::opacity_attenuation, 0.49, 0.61 );
      ::opacityFun.AddPoint(::bones2, 0.72*::opacity_attenuation, 0.5, 0.0 );
      ::opacityFun.AddPoint(3071, 0.71, 0.5, 0.0);

      ::volmapper.SetBlendModeToComposite();
      ::property.ShadeOn();
      ::property.SetAmbient(0.1);
      ::property.SetDiffuse(0.9);
      ::property.SetSpecular(0.2);
      ::property.SetSpecularPower(10.0);
      ::property.SetScalarOpacityUnitDistance(0.8919);
    }


    #----------------------------
    proc ::MusclesReset() \
    {
      ::muscles1 = -155
      ::muscles2 =  217
      ::muscles3 =  420
      ::OnRender()
    }

    #----------------------------
    proc ::BlendCTMuscles() \
    {
      ::colorFun.AddRGBPoint( -3024, 0, 0, 0, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( ::muscles1, 0.55, 0.25, 0.15, 0.5, 0.92 );
      ::colorFun.AddRGBPoint( ::muscles2, 0.88, 0.60, 0.29, 0.33, 0.45 );
      ::colorFun.AddRGBPoint( ::muscles3, 1, 0.94, 0.95, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( 3071, 0.83, 0.66, 1, 0.5, 0.0 );
      
      ::opacityFun.AddPoint(-3024, 0, 0.5, 0.0 );
      ::opacityFun.AddPoint(::muscles1, 0   *::opacity_attenuation, 0.5, 0.92 );
      ::opacityFun.AddPoint(::muscles2, 0.68*::opacity_attenuation, 0.33, 0.45 );
      ::opacityFun.AddPoint(::muscles3, 0.83*::opacity_attenuation, 0.5, 0.0);
      ::opacityFun.AddPoint(3071, 0.80, 0.5, 0.0);

      ::volmapper.SetBlendModeToComposite();
      ::property.ShadeOn();
      ::property.SetAmbient(0.1);
      ::property.SetDiffuse(0.9);
      ::property.SetSpecular(0.2);
      ::property.SetSpecularPower(10.0);
      ::property.SetScalarOpacityUnitDistance(0.8919);
    }

    #---------------------------
    proc ::OnCtrlPoint() \
    {
      #::dw._Paint()
      ::imhisto1.ColormapMinMax()
      ::imhisto1.UpdateCM()
      ::OnRender()
    }

    #----------------------------
    proc ::SaveCurve( OBJECT c ) \
    {
      ctrlpts = curve.GetControlPoints()
      pt = ctrlpts[n] 
    }

    #----------------------------
    proc ::ResetLinearCurve1() \
    {
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      if (exists(::imhisto1->h)) {
        hmax = max(::imhisto1.h[0])

        # Create the curve
        curve = ami.dwControlledCurve()

        # black point
        cp0 = ami.dwControlPoint(-950,0)
        cp0.SetColour(wx.wxColour(0,0,0))
        curve.GetControlPoints().push_back(&cp0)

        # red point
        cp1 = ami.dwControlPoint(-920,0.005*hmax)
        cp1.SetColour(wx.wxColour(255,0,0))
        curve.GetControlPoints().push_back(&cp1)

        # yellow point
        cp2 = ami.dwControlPoint(-908,0.08*hmax)
        cp2.SetColour(wx.wxColour(255,255,0))
        curve.GetControlPoints().push_back(&cp2)

        # white point
        cp3 = ami.dwControlPoint(-500,0.5*hmax)
        cp3.SetColour(wx.wxColour(255,255,255))
        curve.GetControlPoints().push_back(&cp3)

        curve.SetType(1) # solid

        if (!exists(::linearcurve1)) {
          ::linearcurve1 = curve
          ::imhisto1.dw.GetControlledCurves().push_back(&::linearcurve1)
        } else {
          ::linearcurve1 = curve
        }
        ::imhisto1.dw.SetCtrlPointCallback(&::OnCtrlPoint)
      } else {
        InfoDialog "No histogram available."
      }
        
    }

    #----------------------------
    proc ::BlendLinearCurve1() \
    {
      printn "BlendLinearCurve1"
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      if (exists(::imhisto1->h)) {
        curves = ::imhisto1.dw.GetControlledCurves()
        numcurves = curves.size()
        if (!exists(::linearcurve1_id)) {
printn "--"
          ::linearcurve1_id   = numcurves
          ::ResetLinearCurve1()
        }

        # Create colors based on the curve
        hmax = max(::imhisto1.h[0])
        ctrlpoints = curves[::linearcurve1_id].GetControlPoints()
        for n=0 to ctrlpoints.size()-1 {
printn "point number %1%" %n
          cp = ctrlpoints[n]
          col = cp.GetColour()
          ::colorFun.AddRGBPoint( cp.GetX(), 1.0/255*col.Red(), 1.0/255*col.Green(),1.0/255*col.Blue() );
          ::opacityFun.AddPoint(  cp.GetX(), ::opacity_attenuation/hmax*cp.GetY() );
        }
        
        ::volmapper.SetBlendModeToComposite();
        ::property.ShadeOn();
        ::property.SetAmbient(0.15);
        ::property.SetDiffuse(0.9);
        ::property.SetSpecular(0.3);
        ::property.SetSpecularPower(15.0);
        ::property.SetScalarOpacityUnitDistance(0.8919);
      } else {
        InfoDialog "No histogram available."
      }
    }

    #----------------------------
    proc ::ReCompute() \
    {
        if exists(::colorFun)   { ::colorFun.Delete(); del ::colorFun; }
        if exists(::opacityFun) { ::opacityFun.Delete(); del ::opacityFun; }
        if exists(::property)   { ::property.Delete(); del ::property; }

        ::colorFun=global::vtkColorTransferFunction_New()
        ::opacityFun=global::vtkPiecewiseFunction_New()

        # Create the property and attach the transfer functions
        ::property = global::vtkVolumeProperty_New()
        ::property.SetIndependentComponents(1)
        ::property.SetColor( &::colorFun )
        ::property.SetScalarOpacity( &::opacityFun )
        ::property.SetInterpolationTypeToLinear()
 
        # connect up the volume to the property and the mapper
        ::vol.SetProperty( &::property )

        if (::blend_type==0) { ::BlendMIP();                }
        if (::blend_type==1) { ::BlendCompositeRamp();      }
        if (::blend_type==2) { ::BlendCompositeShadeRamp(); }
        if (::blend_type==3) { ::BlendCTSkin();             }
        if (::blend_type==4) { ::BlendCTBones();            }
        if (::blend_type==5) { ::BlendCTMuscles();          }

        if (::blend_type==7) { ::BlendLinearCurve1();       }

        #::property.SetColor( &::colorFun )
        #::property.SetScalarOpacity( &::opacityFun )
      
    }

    #----------------------------
    proc ::Draw_colorFun() \
    {
      ctf = &::colorFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        h1 = Resize(h,256,1,1,1)
        ::ctf_color <<= (RGB) h1
        spos = SpacePos(::ctf_color)
        pos = spos[0]
        #print "\n"
        for x=0 to ::ctf_color.tx-1 {
          ::ctf_color.setpos(x,0,0)
          xpos = pos(x)
          ::ctf_color.set(ctf.GetRedValue(  xpos)*250, \
                          ctf.GetGreenValue(xpos)*250, \
                          ctf.GetBlueValue( xpos)*250 )
        }
        # position curves in ColorMap window of ::imhisto1
        curves = ::imhisto1.cm.GetCurves()
        numcurves = curves.size()
        
        if (!exists(::red_id)) {
          ::red_id   = numcurves
          ::green_id = numcurves+1
          ::blue_id  = numcurves+2
        }

        ::imhisto1.cm.SetCurve(::ctf_color[0],::red_id)
        ::imhisto1.cm.SetCurve(::ctf_color[1],::green_id)
        ::imhisto1.cm.SetCurve(::ctf_color[2],::blue_id)

        ::imhisto1.cm.SetCurveProperties(::red_id,  "#FF0000")
        ::imhisto1.cm.SetCurveProperties(::green_id,"#00FF00")
        ::imhisto1.cm.SetCurveProperties(::blue_id, "#0000FF")
        
      }
    }

    #----------------------------
    proc ::Draw_greycolorFun() \
    {
      ctf = &::colorFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        ::ctf_color <<= Resize(h,256,1,1,1)
        spos = SpacePos(::ctf_color)
        pos = spos[0]
        #print "\n"
        for x=0 to ::ctf_color.tx-1 {
          ::ctf_color.setpos(x,0,0)
          ::ctf_color.set(ctf.GetRedValue(pos(x)))
        }
        ::ctf_color = ::ctf_color*250
        # position curves in ColorMap window of ::imhisto1
        numcurves = ::imhisto1.cm.GetCurves().size()
        printn numcurves
        if (!exists(::red_id)) {
          ::red_id   = numcurves
          ::green_id = numcurves+1
          ::blue_id  = numcurves+2
        }
        ::imhisto1.cm.SetCurve(&::ctf_color,::red_id)
        ::imhisto1.cm.SetCurve(&::ctf_color,::green_id)
        ::imhisto1.cm.SetCurve(&::ctf_color,::blue_id)

        ::imhisto1.cm.SetCurveProperties(::red_id,  "#606060")
        ::imhisto1.cm.SetCurveProperties(::green_id,"#606060")
        ::imhisto1.cm.SetCurveProperties(::blue_id, "#606060")
        
      }
    }

    #----------------------------
    proc ::Draw_opacityFun() \
    {
      otf = &::opacityFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        ::otf_im <<= Resize(h,256,1,1,1)
        spos = SpacePos(::otf_im)
        pos = spos[0]
        #print "\n"
        for x=0 to ::otf_im.tx-1 {
          ::otf_im.setpos(x,0,0)
          ::otf_im.set(otf.GetValue(pos(x)))
        }
        # position curves in ColorMap window of ::imhisto1
        numcurves = ::imhisto1.cm.GetCurves().size()
        printn numcurves
        if (!exists(::otf_id)) {
          ::otf_id   = numcurves
        }
        ::otf_im = ::otf_im*250
        ::imhisto1.cm.SetCurve(::otf_im,::otf_id)
        ::imhisto1.cm.SetCurveProperties(::otf_id,  "#202020")
      }
    }

    #----------------------------
    proc ::Draw_Functions() {
      if (::blend_type<=2) {
        ::Draw_greycolorFun()
      } else {
        ::Draw_colorFun()
      }
      ::Draw_opacityFun()
      ::imhisto1.cm._Paint()
    }

    #----------------------------
    proc ::OnRender() \
    {
      if (exists(::renwininter)&&(::initialized>0.5)) {
        ::ReCompute()
        if (exists(::renwininter)) {
          ::renwininter.Render()
        }
      }
    }

    #----------------------------
    proc ::OnBlendType() \
    {
      ::win.EnablePanel(::ramp_page ,    (::blend_type<=2))
      ::win.EnablePanel(::skin_page ,    ::blend_type==3)
      ::win.EnablePanel(::bones_page ,   ::blend_type==4)
      ::win.EnablePanel(::muscles_page , ::blend_type==5)

      if (::blend_type<=2) {
        ::win.SelectPage(::blend_book,0)
      } else {
        ::win.SelectPage(::blend_book,::blend_type-2)
      }

      ::OnRender()
      ::Draw_Functions()
    }

    #----------------------------
    proc ::OnWindow() \
    {
      ::OnRender()
      ::Draw_Functions()
    }

    #----------------------------
    proc ::OnLevel() \
    {
      ::OnRender()
      ::Draw_Functions()
    }

    #----------------------------
    proc ::UpdateHistogram() \
    {
      if (exists(::imhisto1))&&(exists(::input)) {
        #printn "*"
        if (exists(::min_val)) {
          ::imhisto1.SetInput2(&::input,::min_val,::max_val)
        } else {
          ::imhisto1.SetInput(&::input)
        }
      }
    }
    Comments(::UpdateHistogram,"Updates the histogram with the current input image.")

    #----------------------------
    proc ::OnClip() \
    {
      if (exists(::box)) {
        ::box.SetEnabled(::clip)
      } else {
        ::InitBoxWidget()
      }
    }

    #----------------------------
    proc ::ApplyClip() \
    {
      if (::clip) {
        # to do: vtkPlanes
        planes = global::vtkPlanes_New()
        ::box.GetPlanes(&planes)
        ::volmapper.SetClippingPlanes(&planes)
        planes.Delete()
        ::renwininter.Render()
      }
    }

    #----------------------------
    proc ::AddGui( OBJECT win ) \
    {
      printn "vtkVolumeClass::AddGui begin"
      ::win = &win

      ::win.BeginHorizontal()
        ::win.AddBoolean(&::clip, "Clip")
        ::win.SetCallback( &::OnClip)
        ::icons.LoadIconPNG2("Chart xy","Chart_xy")
        ::AddBitmapButton16(&::win, &::icons._Chart_xy, "UpdateHistogram")
        ::win.AddButton("DrawTr",&::Draw_Functions)
      ::win.EndHorizontal()
      ::win.AddButton( "Apply Clip",&::ApplyClip)
      ::win.AddFloat(&::opacity_attenuation,"Opacity factor",0,1)
      ::win.SetCallback( &::OnWindow)


      ::blend_type_id = ::win.AddEnum(&::blend_type,"Blend")
        ::win.AddEnumChoice(::blend_type_id,"MIP")
        ::win.AddEnumChoice(::blend_type_id,"Comp. Ramp")
        ::win.AddEnumChoice(::blend_type_id,"Comp. Shade Ramp")
        ::win.AddEnumChoice(::blend_type_id,"CT Skin")
        ::win.AddEnumChoice(::blend_type_id,"CT Bone")
        ::win.AddEnumChoice(::blend_type_id,"CT Muscles")
        ::win.AddEnumChoice(::blend_type_id,"RGB Composite")
        ::win.AddEnumChoice(::blend_type_id,"Linear Curve 1")
      ::win.SetCallback( &::OnBlendType)

      ##::win.BeginBook()
          ## Adding histogram page
        #::imhisto1.SetParentPanel(&::win)
        #::imhisto1.Gui()
        #::win.AddWidget(&::imhisto1->win,0)
        ##::win.AddPage("Hist", &::imhisto1->win)
      ##::win.EndBook()

      #::win.SetPositionProp(0)

      ::win.BeginBook()
          # Adding histogram page
        ::imhisto1.SetParentPanel(&::win)
        ::imhisto1.Gui()
        ::win.AddPage("Hist", &::imhisto1->win)
      ::win.EndBook()

      ::blend_book = ::win.BeginBook()
        ::ramp_page = ::win.AddPage("Ramp")
          ::opacitywindow_id = ::win.AddFloat(&::opacitywindow,"Window",0,5000)
          ::win.SetCallback( &::OnWindow)
          ::opacitylevel_id = ::win.AddFloat(&::opacitylevel,"Level",0,5000)
          ::win.SetCallback( &::OnLevel)
        ::skin_page = ::win.AddPage("Skin")
          ::win.AddFloat(&::skin1,"Ctrl_1",-3000,1000)
          ::win.SetCallback( &::OnBlendType)
          ::win.AddFloat(&::skin2,"Ctrl_2",-3000,1000)
          ::win.SetCallback( &::OnBlendType)
          ::AddBitmapButton16(&::win, &::icons._Refresh, "SkinReset")
        ::bones_page = ::win.AddPage("Bones")
          ::win.AddFloat(&::bones1,"Ctrl_1",-1000,2000)
          ::win.SetCallback( &::OnBlendType)
          ::win.AddFloat(&::bones2,"Ctrl_2",-1000,2000)
          ::win.SetCallback( &::OnBlendType)
          ::AddBitmapButton16(&::win, &::icons._Refresh, "BonesReset")
        ::muscles_page = ::win.AddPage("Muscles")
          ::win.AddFloat(&::muscles1,"Ctrl_1",-1000,1000)
          ::win.SetCallback( &::OnBlendType)
          ::win.AddFloat(&::muscles2,"Ctrl_2",-1000,1000)
          ::win.SetCallback( &::OnBlendType)
          ::win.AddFloat(&::muscles3,"Ctrl_3",-1000,1000)
          ::win.SetCallback( &::OnBlendType)
          ::AddBitmapButton16(&::win, &::icons._Refresh, "MusclesReset")
      ::win.EndBook()

      printn "vtkVolumeClass::AddGui end"
    }
  } # end Class

}
# end if
