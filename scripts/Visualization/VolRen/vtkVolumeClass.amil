
func "Common/ScriptGui"
func "Visualization/VolRen/SimplevtkVolumeClass"

del vtkVolumeClass

if (!exists(vtkVolumeClass)) {

  #-----------------------------------------------------
  #  vtkVolumeClass
  #-----------------------------------------------------
  Class vtkVolumeClass : public ScriptGui, SimplevtkVolumeClass {

    # load the ImageHistogram script
    func "Visualization/ImageHistogram/ImageHistogramClass.amil"
    func "dwCurveIOClass.amil"

    func "vtkCurveClass.amil"
    ::vtkcurveclass = &vtkCurveClass

    ImageHistogramClass             ::imhisto1
    ImageHistogramClass             ::imhisto2
    # Input/Output operations to work with the curve on the histogram
    dwCurveIOClass                  ::CurveIO

    proc ::GetIndent(NUM n) {
      res = ""
      for k=1 to n {
        res += "  "
      }
      return=res
    }
    ::trace=false, "gives tracing information"
    member = "\"vtkVolumeClass::\"+" 
    #"language.Vars.GetObjectContext().GetName()::"
    member += "language.Vars.GetCurrentContext().GetName()"
    objname = "GetObjectName(::trace)"
    ::trace_begin="printn \"**\"+"+ \
                  "::GetIndent(language.Vars.GetCurrentContextNumber())+"+\
                  "\" Begin \"+%1%" % member+"+ \"; \" + %1%;" % objname
    ::trace_end  ="printn \"**\"+"+\
                  "::GetIndent(language.Vars.GetCurrentContextNumber())+"+\
                  "\" End   \"+%1%;" % member

    #----------------------------
    proc ::Init( ) \
    {
      if ::trace { eval ::trace_begin; }

      ::InitInherit()
      ::curve_folder    =  "", "Histogram curve Path Folder"
      ::curve_filename  =  "Curve.amil", "name of the input/output histogram curve"

      ::opacitywindow = 1000, "Opacity Window"
      ::opacitylevel  = 1000, "Opacity Level"
      ::cm_active_blend_curves = 0, "Number of curves created for the current blend type in the Colormap  drawing area."
      ::dw_active_blend_curves = 0, "Number of curves created for the current blend type in the Histogram drawing area."

      ::opacity_attenuation  = 1, "Attenuation factor for the opacity"
      ::opacity_attenuation2 = 1, "Attenuation factor for the second volume"
      ::opacity_weight_one   = false, "force total weight to 1"

      # plane widget
      ::planeX = false, "Use ImagePlaneWidget X"
      ::planeY = false, "Use ImagePlaneWidget Y"
      ::planeZ = false, "Use ImagePlaneWidget Z"

      ::clip = false, "Enable/Disable clipping box"
      ::clip_enable_rotation = false, "Enable clip rotation"
      ::clip_interactive = true, "Interactive clipping"

      ::enable_transf_box = false, "Enable/Disable 2nd volume "+\
                                      "transformation box widget"
      ::transfbox_interactive        = true, "Interactive transformation box"
      ::transfbox_enable_rotation    = true,  "Enable rotation "+\
                                                  "(from selected plane)"
      ::transfbox_enable_scaling     = true,  "Enable scaling "+\
                                                  "(right mouse button)"
      ::transfbox_enable_translation = true,  "Enable translation "+ \
                                                  "(middle mouse button)"

      if ::trace { eval ::trace_end; }
    }

    #----------------------------
    proc ::SetInput1Name(STRING input1_name) {
      ::input1_name = input1_name
    }
    #----------------------------
    proc ::SetInput2Name(STRING input2_name) {
      ::input2_name = input2_name
    }

    #----------------------------
    proc ::SaveVTKCurve(STRING filename)\
    {
      if ::trace { eval ::trace_begin; }
      del aux_curve
      ::vtkcurveclass aux_curve

      aux_curve.category    = "UNKNOWN"
      aux_curve.type        = "UNKNOWN_curve"
      aux_curve.descripcion = "general descripcion"

      color=vector_double(3,0)
      ::renderer.GetBackground (&color[0], &color[1], &color[2])
      color2=vector_double(3,0)
      ::renderer.GetBackground2(&color2[0], &color2[1], &color2[2])

      aux_curve.SetColorFun(&::colorFun)
      aux_curve.SetOpacityFun(&::opacityFun)
      aux_curve.SetPropertyFun(&::property)
      aux_curve.r1   = 255*color[0]
      aux_curve.g1   = 255*color[1]
      aux_curve.b1   = 255*color[2]
      aux_curve.r2   = 255*color2[0]
      aux_curve.g2   = 255*color2[1]
      aux_curve.b2   = 255*color2[2]
      aux_curve.Gradient    = 1
      if (color[0]==color2[0] && color[1]==color2[1] && color[2]==color2[2]){
        aux_curve.Gradient = 0
      }
      aux_curve.min_x = 0
      aux_curve.max_x = 1
      aux_curve.norma = 0
      printn "GetInput = %1%" % ::volmapper.GetInput()
      if (exists(::selected_curv)){
        aux_curve.norma = ::selected_curv.norma
        aux_curve.category    = ::selected_curv.category
        aux_curve.type        = ::selected_curv.type
        aux_curve.descripcion = ::selected_curv.descripcion
        aux_curve.norma = ::selected_curv.norma
      }
      aux_curve.blend_mode  = ::blend_mode
      aux_curve.Save(filename)
      if ::trace { eval ::trace_end; }
    }
 
    #----------------------------
    proc ::CB_Clip(OBJECT caller, NUM id) \
    {
      if ::trace { eval ::trace_begin; }
      if (::clip_interactive)&&(exists(::box)) {
        planes = vtk.vtkPlanes.New()
        ::box.GetPlanes(&planes)
        ::volmapper.SetClippingPlanes(&planes);
      }
      if (!exists(::box)) {
        InfoDialog "::box does not exists ???"
      }
      if ::trace { eval ::trace_end; }
    }

    #----------------------------
    proc ::InitBoxWidget() \
    {
      if ::trace { eval ::trace_begin; }
      ::box = vtk.vtkBoxWidget.New()
      if (::clip) \
      {
        ::box.SetInteractor(&::renwininter)
        ::box.SetPlaceFactor(1.01)
        ::box.SetInput(&::vtkinput)
        
        ::box.SetDefaultRenderer(&::renderer)
        ::box.InsideOutOn()
        ::box.PlaceWidget()
        ::box_cmd = vtk.vtkAmiCommand.New()
        ::box_cmd.SetAmiFunction(&::CB_Clip)
        ::box.AddObserver(vtk.vtkCommand.InteractionEvent, &::box_cmd);
        ::box.SetRotationEnabled(::clip_enable_rotation)
        ::box.EnabledOn()
        #::box.GetSelectedFaceProperty().SetOpacity(0.0)
      }
      if ::trace { eval ::trace_end; }
    }

    #----------------------------
    proc ::OnClip() \
    {
      if (exists(::box)) {
        ::box.SetEnabled(::clip)
        ::box.SetRotationEnabled(::clip_enable_rotation)
      } else {
        ::InitBoxWidget()
      }
    }

    #----------------------------
    proc ::ApplyClip() \
    {
      if (::clip) {
        # to do: vtkPlanes
        planes = vtk.vtkPlanes.New()
        ::box.GetPlanes(&planes)
        ::volmapper.SetClippingPlanes(&planes)
        ::renwininter.Render()
      }
    }

    #----------------------------
    proc ::CB_TransfBox(OBJECT caller, NUM id) \
    {
      if (::transfbox_interactive) {
        ::ApplyTransfBox()
      }
    }

    #----------------------------
    proc ::InitTransfBoxWidget() \
    {
      del ::transf_box
      ::transf_box = vtk.vtkBoxWidget.New()
      if (::enable_transf_box)&&(exists(::vtkinput2)) \
      {
        ::transf_box.SetInteractor(&::renwininter)
        ::transf_box.SetPlaceFactor(1.01)
        ::transf_box.SetInput(&::vtkinput2) 
        ::transf_box.SetDefaultRenderer(&::renderer)
        ::transf_box.InsideOutOn()
        ::transf_box.PlaceWidget()
        ::transf_box_cmd = vtk.vtkAmiCommand.New()
        ::transf_box_cmd.SetAmiFunction(&::CB_TransfBox)
        ::transf_box.AddObserver(vtk.vtkCommand.InteractionEvent, &::transf_box_cmd);
        ::transf_box.SetRotationEnabled   (::transfbox_enable_rotation   )
        ::transf_box.SetTranslationEnabled(::transfbox_enable_translation)
        ::transf_box.SetScalingEnabled    (::transfbox_enable_scaling    )
        ::transf_box.EnabledOn()
      }
    }

    #----------------------------
    proc ::OnTransfBox() \
    {
      if (exists(::transf_box)) {
        ::transf_box.SetEnabled(::enable_transf_box)
        ::transf_box.SetRotationEnabled   (::transfbox_enable_rotation   )
        ::transf_box.SetTranslationEnabled(::transfbox_enable_translation)
        ::transf_box.SetScalingEnabled    (::transfbox_enable_scaling    )
      } else {
        ::InitTransfBoxWidget()
      }
    }

    #---------------------------------------------------------------------------
    proc ::ApplyTransfBox() \
    {
      #printn "ApplyTransfBox"
      #printn ::volmapper.GetClassName()
      #printn ::enable_transf_box
      if (::volmapper.GetClassName()=="vtkOpenGLGPUMultiVolumeRayCastMapper") && \
         (::enable_transf_box) \
      {
        #printn "*"
        t = vtk.vtkTransform.New()
        ::transf_box.GetTransform(&t)
        if (!exists(::current_vol2_transf)) {
          ::current_vol2_transf = vtk.vtkTransform.New()
        }
        ::current_vol2_transf.DeepCopy(t)
        ::volmapper.SetSecondInputUserTransform(t)
        ::renwininter.Render()
      }
    }

    #---------------------------------------------------------------------------
    proc ::SaveTransf() \
    {
      printn "SaveTransf ..."
      t = vtk.vtkTransform.New()
      ::transf_box.GetTransform(&t)
      del ::secondvol_transf_bak
      ::secondvol_transf_bak = t.NewInstance()
      ::secondvol_transf_bak.DeepCopy(t)
    }

    #---------------------------------------------------------------------------
    proc ::RestoreTransf() \
    {
    printn "RestoreTransf()"
      if (exists(::secondvol_transf_bak)) {
        # Get the current transform to put it in backup ...
        t = vtk.vtkTransform.New()
        ::transf_box.GetTransform(&t)
        # apply backup transform
        ::transf_box.SetTransform(::secondvol_transf_bak)
        ::ApplyTransfBox()
        # set the previous transform in backup
        ::secondvol_transf_bak.DeepCopy(t)
      }
    }

    #---------------------------------------------------------------------------
    proc ::ResetTransf() \
    {
      ::SaveTransf()
      t = vtk.vtkTransform.New()
      t.Identity()
      ::transf_box.SetTransform(t)
      ::ApplyTransfBox()
    }

    #---------------------------------------------------------------------------
    proc ::SaveTransfDisk() \
    {
      if exists(::current_vol2_transf) {
        # Get the scrip directory
        ::InitUserScriptData()
        # using ::scriptdata_path
        default_name = "SecondVolumeTransform.ami.gz"
        if exists(::input1_name) && exists(::input2_name) {
          default_name = "%1%" % ::input1_name + "__%1%.ami.gz" % ::input2_name
        }
        # Ask the filename
        filename = wx.wxFileSelector( "Save Matrix: select the filename",\
                                      ::scriptdata_path, \
                                      default_name, \
                                      ".ami.gz", \
                                      "*.*", \
                                      wx.wxFD_SAVE | wx.wxFD_OVERWRITE_PROMPT)
        # Go save the filename
        immat = Image(DOUBLE,4,4,1)
        m = ::current_vol2_transf.GetMatrix()
        for i=0 to 3 {
          for j=0 to 3 {
            immat.setpos(i,j,0)
            immat.set( m.GetElement(i,j))
          }
        }
        immat.save(filename.ToStdString())
      }
      

    }

    #---------------------------------------------------------------------------
    proc ::ReadTransfDisk() \
    {
      # Get the scrip directory
      ::InitUserScriptData()
      # using ::scriptdata_path
      # Ask the filename
      default_name = "SecondVolumeTransform.ami.gz"
      if exists(::input1_name) && exists(::input2_name) {
        default_name = "%1%" % ::input1_name + "__%1%.ami.gz" % ::input2_name
      }
      filename = wx.wxFileSelector( "Read Matrix: select the filename",\
                                    ::scriptdata_path, \
                                    default_name, \
                                    ".ami.gz", \
                                    "*.*", \
                                    wx.wxFD_OPEN)
      immat = Image(filename.ToStdString())
      m = vtk.vtkMatrix4x4.New()
      for i=0 to 3 {
        for j=0 to 3 {
          m.SetElement(i,j,immat(i,j))
        }
      }
      t = vtk.vtkTransform.New()
      t.SetMatrix(m)
      ::enable_transf_box = true
      ::OnTransfBox()

      # Backup current transform
      del ::secondvol_transf_bak
      ::secondvol_transf_bak = t.NewInstance()
      ::transf_box.GetTransform(::secondvol_transf_bak)
      # set and apply new transform
      ::transf_box.SetTransform(t)
      ::ApplyTransfBox()
    }

    #----------------------------
    proc ::SetLinearCurve( OBJECT curve) \
    {
      if ::trace { eval ::trace_begin; }
        ccurv = &::imhisto1.dw.GetControlledCurves()
        #printn "linearcurve1_id %1%" %::linearcurve1_id
        if (::linearcurve1_id<ccurv.size()) {
          ccurv[::linearcurve1_id] = curve
        } else {
          ccurv.push_back(&curve)
          ::linearcurve1_id = ccurv.size()-1
        }
        ::imhisto1.dw.UpdateLinearCM()
        ::imhisto1.dw.DrawLinearCM()
      if ::trace { eval ::trace_end; }
    }

    #----------------------------
    proc ::SetLinearCurve2( OBJECT curve) \
    {
      if ::trace { eval ::trace_begin; }
        ccurv = &::imhisto2.dw.GetControlledCurves()
        #printn "linearcurve1_id %1%" %::linearcurve1_id
        if (::linearcurve2_id<ccurv.size()) {
          ccurv[::linearcurve2_id] = curve
        } else {
          ccurv.push_back(&curve)
          ::linearcurve2_id = ccurv.size()-1
        }
        ::imhisto2.dw.UpdateLinearCM()
        ::imhisto2.dw.DrawLinearCM()
      if ::trace { eval ::trace_end; }
    }

    #---------------------------------------------------------------------------
    proc ::SetLinearColormap_callback( VAR cb) \
    {
      del ::linearcolormap_callback
      ::linearcolormap_callback = &cb
    }
    
    
    #---------------------------
    proc ::OnLinearColormap() \
    {
      if ::trace { eval ::trace_begin; }
      #printn "::OnLinearColormap()"
      ::imhisto1.dw._Paint()
      ::imhisto1.ColormapMinMax()
      ::imhisto1.UpdateCM()
      ::OnRender()
      if exists(::linearcolormap_callback) {
        ::linearcolormap_callback()
      }
      if ::trace { eval ::trace_end; }
    }
    
    #---------------------------
    proc ::OnLinearColormap2() \
    {
      if ::trace { eval ::trace_begin; }
      #printn "::OnLinearColormap()"

      ::imhisto2.dw._Paint()
      ::imhisto2.ColormapMinMax()
      ::imhisto2.UpdateCM()

      ::OnRender()
      if ::trace { eval ::trace_end; }
    }

    # deprecated ...
    ##----------------------------
    #proc ::SaveCurve(  ) \
    #{
      #if ::trace { eval ::trace_begin; }
      #thefilename = wx.wxFileName(&::curve_folder, &::curve_filename)
      #if(thefilename.FileExists()) {
        #msg = "The %1% file exists." % \
                  #wx.FromWxString(thefilename.GetFullName())
      #} else {
        #if (!exists(::linearcurve1)) {
          #msg = "It is not possible to save the curve because it has not been defined."
        #} else {
          #::CurveIO.SaveCurve( wx.FromWxString(thefilename.GetFullName())\
                                #, &::linearcurve1 )
          #msg = "The curve has been saved correctly in the file: %1%" % \
            #wx.FromWxString(thefilename.GetFullName())
        #}
      #}
      #InfoDialog msg
      #if ::trace { eval ::trace_end; }
    #}

    ##----------------------------
    #proc ::LoadCurve(  ) \
    #{
      #thefilename = wx.wxFileName(&::curve_folder, &::curve_filename)
      #if(thefilename.FileExists()) {
        #::linearcurve1 = ::CurveIO.LoadCurve( \
                        #wx.FromWxString(thefilename.GetFullName()) )
        #msg = "The curve has been loaded correctly from the file: %1%" %\
                  #wx.FromWxString(thefilename.GetFullName())
      #} else {
        #msg = "The %1% file does not exist." %\
                #wx.FromWxString(thefilename.GetFullName())
      #}
      #InfoDialog msg
    #}

    #----------------------------
    proc ::ResetLinearCurve1() \
    {
      if ::trace { eval ::trace_begin; }
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      if (exists(::imhisto1->h)) {
        hmax = max(::imhisto1.h[0])

        # http://www.wikiradiography.com/page/Hounsfield++unit
        #It is the definition for CT scanners that are calibrated with reference to water.
        #Tissue CT number (HU)
        #Bone  1000
        #Liver   40 - 60
        #White matter  ~20-30 HU
        #Grey matter   ~37-45 HU
        #Blood   40
        #Muscle  10 - 40
        #Kidney  30
        #Cerebrospinal fluid   15
        #Water   0
        #Fat   -50 - -100
        #Air   -1000

        # default intensity values
        px1 = 1080
        px3 = 1130
        px4 = 1390
        px2 = 1100
        o1 = 0
        o2 = 0.005
        o3 = 0.08
        o4 = 0.5
        imin = ::imhisto1.minval
        imax = ::imhisto1.maxval
        if  (imin>px1)||(imax<px1)||(imin>px2)||(imax<px2) \
        { 
          # set position within intensity range
          px1 = imin+(imax-imin)*0.4
          px2 = imin+(imax-imin)*0.5
          px3 = imin+(imax-imin)*0.6
          px4 = imin+(imax-imin)*0.9
          o1 = 0
          o2 = 0.3
          o3 = 0.4
          o4 = 0.9
        }

        # Create the curve
        curve = ami.dwControlledCurve()

        # black point
        cp0 = ami.dwControlPoint(px1,o1*hmax)
        cp0.SetYLocked(1)
        cp0.SetColour(wx.wxColour(0,0,0))
        cp0.Setmidpoint( 0.5)
        cp0.Setsharpness(0)     
        curve.GetControlPoints().push_back(&cp0)

        # red point
        cp1 = ami.dwControlPoint(px2,o2*hmax)
        cp1.SetColour(wx.wxColour(255,0,0))
        cp1.Setmidpoint( 0.5)
        cp1.Setsharpness(0)
        curve.GetControlPoints().push_back(&cp1)

        # yellow point
        cp2 = ami.dwControlPoint(px3,o3*hmax)
        cp2.SetColour(wx.wxColour(255,255,0))
        cp2.Setmidpoint( 0.5)
        cp2.Setsharpness(0)
        curve.GetControlPoints().push_back(&cp2)

        # white point
        cp3 = ami.dwControlPoint(px4,o4*hmax)
        cp3.SetColour(wx.wxColour(255,255,255))
        cp3.Setmidpoint( 0.5)
        cp3.Setsharpness(0)
        curve.GetControlPoints().push_back(&cp3)

        #::SetBlendMode(0)
        curve.SetType(1) # solid
  
        #::imhisto1.dw.SetCtrlPointCallback(&::OnCtrlPoint)
        ::imhisto1.dw.SetLinearColormapCallback(&::OnLinearColormap)

        ::use_shade=1
        ::SetLinearCurve(&curve)
      } else {
         //if (::volrenmapper_type!=3){
          InfoDialog "No histogram available."
         //}
      }
        
      if ::trace { eval ::trace_end; }
    }
    #----------------------------
    proc ::ResetLinearCurve2() \
    {
      if (!exists(::imhisto2->h)) {
        ::UpdateHistogram2()
      }
      if (exists(::imhisto2->h)) {
        hmax = max(::imhisto2.h[0])

        # http://www.wikiradiography.com/page/Hounsfield++unit
        #It is the definition for CT scanners that are calibrated with reference to water.
        #Tissue CT number (HU)
        #Bone  1000
        #Liver   40 - 60
        #White matter  ~20-30 HU
        #Grey matter   ~37-45 HU
        #Blood   40
        #Muscle  10 - 40
        #Kidney  30
        #Cerebrospinal fluid   15
        #Water   0
        #Fat   -50 - -100
        #Air   -1000

        # default intensity values
        px1 = 1080
        px3 = 1130
        px4 = 1390
        px2 = 1100
        o1 = 0
        o2 = 0.005
        o3 = 0.08
        o4 = 0.5
        imin = ::imhisto2.minval
        imax = ::imhisto2.maxval
        if  (imin>px1)||(imax<px1)||(imin>px2)||(imax<px2) \
        { 
          # set position within intensity range
          px1 = imin+(imax-imin)*0.4
          px2 = imin+(imax-imin)*0.5
          px3 = imin+(imax-imin)*0.6
          px4 = imin+(imax-imin)*0.9
          o1 = 0
          o2 = 0.3
          o3 = 0.4
          o4 = 0.9
        }

        # Create the curve
        curve = ami.dwControlledCurve()

        # black point
        cp0 = ami.dwControlPoint(px1,o1*hmax)
        cp0.SetYLocked(1)
        cp0.SetColour(wx.wxColour(0,0,0))
        cp0.Setmidpoint( 0.5)
        cp0.Setsharpness(0)     
        curve.GetControlPoints().push_back(&cp0)

        # red point
        cp1 = ami.dwControlPoint(px2,o2*hmax)
        cp1.SetColour(wx.wxColour(255,0,0))
        cp1.Setmidpoint( 0.5)
        cp1.Setsharpness(0)
        curve.GetControlPoints().push_back(&cp1)

        # yellow point
        cp2 = ami.dwControlPoint(px3,o3*hmax)
        cp2.SetColour(wx.wxColour(255,255,0))
        cp2.Setmidpoint( 0.5)
        cp2.Setsharpness(0)
        curve.GetControlPoints().push_back(&cp2)

        # white point
        cp3 = ami.dwControlPoint(px4,o4*hmax)
        cp3.SetColour(wx.wxColour(255,255,255))
        cp3.Setmidpoint( 0.5)
        cp3.Setsharpness(0)
        curve.GetControlPoints().push_back(&cp3)

        #::SetBlendMode(0)
        curve.SetType(1) # solid
  
        #::imhisto1.dw.SetCtrlPointCallback(&::OnCtrlPoint)
        ::imhisto2.dw.SetLinearColormapCallback(&::OnLinearColormap2)
        ::use_shade=1
        ::SetLinearCurve2(&curve)
      } else {
          InfoDialog "No histogram available."
      } 
    }
    #----------------------------
    proc ::SetShadingProperties() \
    {
      if ::trace { eval ::trace_begin; }
      ::property.SetShade(::use_shade)
      ::property.SetAmbient(::ambient)
      ::property.SetDiffuse(::diffuse)
      ::property.SetSpecular(::specular)
      ::property.SetSpecularPower(::specular_power)
      ::property.SetScalarOpacityUnitDistance(::scalar_opacity_unitdistance)

      if(exists(::input2)&&::volrenmapper_type==3){
        ::property2.SetShade(::use_shade)
        ::property2.SetAmbient(::ambient)
        ::property2.SetDiffuse(::diffuse)
        ::property2.SetSpecular(::specular)
        ::property2.SetSpecularPower(::specular_power)
        ::property2.SetScalarOpacityUnitDistance(::scalar_opacity_unitdistance)
      }
      if ::trace { eval ::trace_end; }
    }

    #----------------------------
    proc ::BlendLinearCurve1() \
    {
      if ::trace { eval ::trace_begin; }
      #printn "BlendLinearCurve1"
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      
      del ::colorFun
      del ::opacityFun
      ::colorFun=vtk.vtkColorTransferFunction.New()
      ::opacityFun=vtk.vtkPiecewiseFunction.New()

 #if ::move_2 {
     #del ::colorFun2
      #del ::opacityFun2
      #::colorFun2=vtk.vtkColorTransferFunction.New()
      #::opacityFun2=vtk.vtkPiecewiseFunction.New()
#}
      
      if (exists(::imhisto1->h)) {
        curves = ::imhisto1.dw.GetControlledCurves()
        numcurves = curves.size()
        if (!exists(::linearcurve1_id)) {
          printn "--"
          ::linearcurve1_id   = numcurves
          ::ResetLinearCurve1()
        }

        # Create colors based on the curve
        hmax = max(::imhisto1.h[0])
     
        for n=0 to ::imhisto1.dw.GetSizelinearCM()-1 {
          #printn "-point number %1%" %n
          y =  ::opacity_attenuation/hmax*::imhisto1.dw.GetAlphalinearCM(n)
          pos = ::imhisto1.dw.GetPoslinearCM(n)
          col = ::imhisto1.dw.GetColourlinearCM(n)
          mp  = ::imhisto1.dw.GetMidpointlinearCM(n)
          s   = ::imhisto1.dw.GetSharpnesslinearCM(n)
          ::colorFun.AddRGBPoint( pos, \
                                  1.0/255*col.Red(), \
                                  1.0/255*col.Green(),\
                                  1.0/255*col.Blue(),\
                                  mp,\
                                  s);

#if ::move_2 {
          #::colorFun2.AddRGBPoint( pos, \
                                  #1.0/255*col.Red(), \
                                  #1.0/255*col.Green(),\
                                  #1.0/255*col.Blue(),\
                                  #mp,\
                                  #s);
#}    
          
          y = -max(-y,-1)
          ::opacityFun.AddPoint(  pos, y , mp,s)
#if ::move_2 {
          #::opacityFun2.AddPoint(  pos, y , mp,s)
#}
        }
        ::SetShadingProperties()
      ::property.SetColor( &::colorFun )
      ::property.SetScalarOpacity( &::opacityFun )

#if ::move_2 {
      #::property2.SetColor( &::colorFun2 )
      #::property2.SetScalarOpacity( &::opacityFun2 )
#}
      } else {
        InfoDialog "No histogram available."
      }
      if ::trace { eval ::trace_end; }
    }


   #----------------------------
    proc ::BlendLinearCurve2() \
    {
      if ::trace { eval ::trace_begin; }
      if (!exists(::imhisto2->h)) {
        ::UpdateHistogram2()
      }

      del ::colorFun2
      del ::opacityFun2
      ::colorFun2=vtk.vtkColorTransferFunction.New()
      ::opacityFun2=vtk.vtkPiecewiseFunction.New()
      
      if (exists(::imhisto2->h)) {
        curves = ::imhisto2.dw.GetControlledCurves()
        numcurves = curves.size()
        if (!exists(::linearcurve2_id)) {
          printn "--"
          ::linearcurve2_id   = numcurves
          ::ResetLinearCurve2()
        }

        # Create colors based on the curve
        hmax = max(::imhisto2.h[0])
     
        for n=0 to ::imhisto2.dw.GetSizelinearCM()-1 {
          #printn "-point number %1%" %n
          y =  ::opacity_attenuation2/hmax*::imhisto2.dw.GetAlphalinearCM(n)
          pos = ::imhisto2.dw.GetPoslinearCM(n)
          col = ::imhisto2.dw.GetColourlinearCM(n)
          mp  = ::imhisto2.dw.GetMidpointlinearCM(n)
          s   = ::imhisto2.dw.GetSharpnesslinearCM(n)


          ::colorFun2.AddRGBPoint( pos, \
                                  1.0/255*col.Red(), \
                                  1.0/255*col.Green(),\
                                  1.0/255*col.Blue(),\
                                  mp,\
                                  s);
    
          
          y = -max(-y,-1)
          ::opacityFun2.AddPoint(  pos, y , mp,s)

        }
        ::SetShadingProperties()


        ::property2.SetColor( &::colorFun2 )
        ::property2.SetScalarOpacity( &::opacityFun2 )

      } else {
        InfoDialog "No histogram available."
      }
      if ::trace { eval ::trace_end; }
    }



    #----------------------------
    proc ::PreviewApplied(OBJECT vtkcurve) \
    {
      if ::trace { eval ::trace_begin; }
      del ::selected_curv
      //::selected_curv = &::previewer.GetSelection()
      ::selected_curv = &vtkcurve
      
      # now create the curve based on the vtkCurveClass object
      ::SetBackground(::selected_curv.r1, ::selected_curv.g1, ::selected_curv.b1, \
                ::selected_curv.r2, ::selected_curv.g2, ::selected_curv.b2, ::selected_curv.Gradient ) 
     
      if (!exists(::imhisto1->h)) {

        ::UpdateHistogram()
      }
      hmax = max(::imhisto1.h[0])

      curve = ami.dwControlledCurve()

      n1 = ::selected_curv.colorFun.GetSize()
      n2 = ::selected_curv.opacityFun.GetSize()
      for n=0 to n1-1 {
        # add point
        vals  = vector_double(6)
        vals_op = vector_double(4)
        ::selected_curv.colorFun  .GetNodeValue(n,&vals [0])
        ::selected_curv.opacityFun.GetNodeValue(n,&vals_op[0])
        del cp
        # TODO: check compatibility between color and opacity functions ...
        cp = ami.dwControlPoint(vals[0],vals_op[1]*hmax)
        cp.SetColour(wx.wxColour(vals[1]*255,vals[2]*255,vals[3]*255))
        cp.Setmidpoint(vals[4])
        cp.Setsharpness(vals[5])
        curve.GetControlPoints().push_back(&cp)
      }
      curve.SetType(1) # solid
      ::SetLinearCurve(&curve)
      ::ambient  = ::selected_curv.property.GetAmbient()
      ::diffuse  = ::selected_curv.property.GetDiffuse()
      ::specular = ::selected_curv.property.GetSpecular()
      ::specular_power =  ::selected_curv.property.GetSpecularPower()
      ::scalar_opacity_unitdistance =  ::selected_curv.property.GetScalarOpacityUnitDistance()

      ::use_shade   = ::selected_curv.use_shade
      ::blend_mode  = ::selected_curv.blend_mode
      ::SetLinearCurve(&curve)
      ::OnRender()
      ::win.Update(-1)
      if ::trace { eval ::trace_end; }
    }

    #----------------------------
    proc ::ReCompute() \
    {
      if ::trace { eval ::trace_begin; }
      ::BlendLinearCurve1()       
      if (::volrenmapper_type==3){
        ::BlendLinearCurve2()  
      }

      if (exists(::property)){
        ::vol.SetProperty( &::property )
      }
      #      printn "::move_2 = %1%" % ::move_2
      #      if ::move_2 {
      if (exists(::property2) && ::volrenmapper_type==3){
        ::volmapper.SetProperty2( &::property2 )
        #printn "::volmapper.SetProperty2( &::property2 )"
      }
      #      }

      ::volmapper.SetBlendMode(::blend_mode)
      if ::trace { eval ::trace_end; }
    }

    #----------------------------
    proc ::Draw_colorFun() \
    {
      if ::trace { eval ::trace_begin; }
      ctf = &::colorFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        h1 = Resize(h,256,1,1,1)
        ::ctf_color <<= (RGB) h1
        spos = SpacePos(::ctf_color)
        pos = spos[0]
        #print "\n"
        for x=0 to ::ctf_color.tx-1 {
          ::ctf_color.setpos(x,0,0)
          xpos = pos(x)
          ::ctf_color.set(ctf.GetRedValue(  xpos)*250, \
                          ctf.GetGreenValue(xpos)*250, \
                          ctf.GetBlueValue( xpos)*250 )
        }
        # position curves in ColorMap window of ::imhisto1
        if(exists( ::imhisto1->cm)){
          curves = ::imhisto1.cm.GetCurves()
          numcurves = curves.size()
          
          if (!exists(::red_id)) {
            ::red_id   = numcurves
            ::green_id = numcurves+1
            ::blue_id  = numcurves+2
          }

          ::imhisto1.cm.SetCurve(::ctf_color[0],::red_id)
          ::imhisto1.cm.SetCurve(::ctf_color[1],::green_id)
          ::imhisto1.cm.SetCurve(::ctf_color[2],::blue_id)

          ::imhisto1.cm.SetCurveProperties(::red_id,  "#FF0000")
          ::imhisto1.cm.SetCurveProperties(::green_id,"#00FF00")
          ::imhisto1.cm.SetCurveProperties(::blue_id, "#0000FF")
        }
        
      }
      if ::trace { eval ::trace_end; }
    }

    #----------------------------
    proc ::Draw_greycolorFun() \
    {
      ctf = &::colorFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        ::ctf_color <<= Resize(h,256,1,1,1)
        spos = SpacePos(::ctf_color)
        pos = spos[0]
        #print "\n"
        for x=0 to ::ctf_color.tx-1 {
          ::ctf_color.setpos(x,0,0)
          ::ctf_color.set(ctf.GetRedValue(pos(x)))
        }
        ::ctf_color = ::ctf_color*250
        # position curves in ColorMap window of ::imhisto1
        if(exists( ::imhisto1->cm)){
          numcurves = ::imhisto1.cm.GetCurves().size()
          printn numcurves
          if (!exists(::red_id)) {
            ::red_id   = numcurves
            ::green_id = numcurves+1
            ::blue_id  = numcurves+2
          }
        
          ::imhisto1.cm.SetCurve(&::ctf_color,::red_id)
          ::imhisto1.cm.SetCurve(&::ctf_color,::green_id)
          ::imhisto1.cm.SetCurve(&::ctf_color,::blue_id)

          ::imhisto1.cm.SetCurveProperties(::red_id,  "#606060")
          ::imhisto1.cm.SetCurveProperties(::green_id,"#606060")
          ::imhisto1.cm.SetCurveProperties(::blue_id, "#606060")
    
        }
      }
    }

    #----------------------------
    proc ::Draw_opacityFun() \
    {
      otf = &::opacityFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        ::otf_im <<= Resize(h,256,1,1,1)
        spos = SpacePos(::otf_im)
        pos = spos[0]
        #print "\n"
        for x=0 to ::otf_im.tx-1 {
          ::otf_im.setpos(x,0,0)
          ::otf_im.set(otf.GetValue(pos(x)))
        }
        # position curves in ColorMap window of ::imhisto1
        if(exists( ::imhisto1->cm)){
          numcurves = ::imhisto1.cm.GetCurves().size()
          printn numcurves
          if (!exists(::otf_id)) {
            ::otf_id   = numcurves
          }
          ::otf_im = ::otf_im*250
          ::imhisto1.cm.SetCurve(::otf_im,::otf_id)
          ::imhisto1.cm.SetCurveProperties(::otf_id,  "#202020")
        }
      }
    }

    #----------------------------
    proc ::Draw_Functions() {
      //if (::blend_type<=2) {
      //  ::Draw_greycolorFun()
      //} else {
      ::Draw_colorFun()
      //}
      ::Draw_opacityFun()
      if(exists( ::imhisto1->cm)){
        ::imhisto1.cm._Paint()
      }
    }

    #----------------------------
    proc ::OnWindow() \
    {
      ::OnRender()
      ::Draw_Functions()
    }

    #----------------------------
    proc ::OnOpacity1() \
    {
      if (::opacity_weight_one) {
        ::opacity_attenuation2 = 1 - ::opacity_attenuation
        ::win.Update(::opacity_attenuation2_id)
      }
      ::OnWindow()
    }

    #----------------------------
    proc ::OnOpacity2() \
    {
      if (::opacity_weight_one) {
        ::opacity_attenuation = 1 - ::opacity_attenuation2
        ::win.Update(::opacity_attenuation_id)
      }
      ::OnWindow()
    }

    #----------------------------
    proc ::UpdateHistogram() \
    {
      if (exists(::imhisto1))&&(exists(::input)) {
        #printn "*"
        if (exists(::min_val)) {
          ::imhisto1.SetInput2(&::input,::min_val,::max_val)
        } else {
          ::imhisto1.SetInput(&::input)
        }
      }
    }
    Comments(::UpdateHistogram,"Updates the histogram with the current input image.")

    #----------------------------
    proc ::UpdateHistogram2() \
    {
      if (exists(::imhisto2))&&(exists(::input2)) {
        #printn "*"
        if (exists(::min_val2)) {
          ::imhisto2.SetInput2(&::input2,::min_val2,::max_val2)
        } else {
          ::imhisto2.SetInput(&::input2)
        }
      }
    }
    Comments(::UpdateHistogram,"Updates the histogram with the current input image.")

    #----------------------------
    proc ::OnSampleDistance() \
    {
      if (::volmapper.GetClassName()!="vtkSmartVolumeMapper") {
        ::volmapper.SetAutoAdjustSampleDistances(::AutoAdjustSampleDistances)
        ::volmapper.SetSampleDistance(::SampleDistance)
        ::volmapper.SetImageSampleDistance(::ImageSampleDistance)
        ::renwininter.Render()
      }
    }

    #----------------------------
    proc ::OnPlane() \
    {
      if (!exists(::planeWidgets)) {
        ::picker = vtk.vtkCellPicker.New() 
        ::picker.SetTolerance(0.005)

        ::planeWidgets = VarVector()
        for n=0 to 2 {
          ::planeWidgets.push_back(&vtk.vtkImagePlaneWidget.New())
          ::planeWidgets[n].DisplayTextOn()
          ::planeWidgets[n].SetInput(&::vtkinput)
          ::planeWidgets[n].SetPicker(&::picker)
          ::planeWidgets[n].SetInteractor(&::renwininter)
        }
        ::planeWidgets[0].SetPlaneOrientationToXAxes()
        ::planeWidgets[0].SetKeyPressActivationValue("x")
        ::planeWidgets[0].GetPlaneProperty().SetColor(1, 0, 0)
        ::planeWidgets[0].SetSliceIndex(::input.tx/2)
        ::planeWidgets[1].SetPlaneOrientationToYAxes()
        ::planeWidgets[1].SetKeyPressActivationValue("y")
        ::planeWidgets[1].GetPlaneProperty().SetColor(1, 1, 0)
        ::planeWidgets[1].SetLookupTable(&::planeWidgets[0].GetLookupTable())
        ::planeWidgets[1].SetSliceIndex(::input.ty/2)
        ::planeWidgets[2].SetPlaneOrientationToZAxes()
        ::planeWidgets[2].SetKeyPressActivationValue("z")
        ::planeWidgets[2].GetPlaneProperty().SetColor(0, 0, 1)
        ::planeWidgets[2].SetSliceIndex(::input.tz/2)
        ::planeWidgets[2].SetLookupTable(&::planeWidgets[0].GetLookupTable())
      }
      if ::planeX { ::planeWidgets[0].On(); } else { ::planeWidgets[0].Off(); }
      if ::planeY { ::planeWidgets[1].On(); } else { ::planeWidgets[1].Off(); }
      if ::planeZ { ::planeWidgets[2].On(); } else { ::planeWidgets[2].Off(); }

    }

    #----------------------------
    proc ::Close() \
    {
      printn "Nothing to do"
      #if (exists(::previewer)){
        #::previewer.Close()
        #del ::previewer
      #}
    }


    #----------------------------
    proc ::AddGui( OBJECT win ) \
    {
      printn "vtkVolumeClass::AddGui begin"
      ::win = &win

      ::win.BeginBook()


        #-------------------- Clip page --------------------------------------
        ::win.AddPage("Clip")
          ::win.AddBoolean(&::clip, "Clip")
          ::win.SetCallback( &::OnClip)
          ::win.AddBoolean(&::clip_enable_rotation,"Rotation")
          ::win.AddBoolean(&::clip_interactive,"Interactive")
          ::win.SetCallback( &::OnClip)
          ::win.AddButton( "Apply Clip",&::ApplyClip)

        #-------------------- Plane page --------------------------------------
        ::Plane_page = ::win.AddPage("Plane")
          ::win.AddBoolean(&::planeX, "PlaneX")
          ::win.SetCallback( &::OnPlane)
          ::win.AddBoolean(&::planeY, "PlaneY")
          ::win.SetCallback( &::OnPlane)
          ::win.AddBoolean(&::planeZ, "PlaneZ")
          ::win.SetCallback( &::OnPlane)

        #-------------------- Rend page --------------------------------------
        #::win.AddPage("GPU")
        ::win.AddPage("Rend")
          ::win.BeginBoxPanel("Sample distances")
            ::win.AddBoolean(&::AutoAdjustSampleDistances,"Auto")
            ::win.SetCallback( &::OnSampleDistance)
            ::win.AddFloat(&::SampleDistance,"Dist",0.2,2)
            #::win.SetCallback( &::OnSampleDistance)
            ::win.AddFloat(&::ImageSampleDistance,"Im Dist",0.2,2)
            ::win.AddButton("Apply",&::OnSampleDistance)
          ::win.EndBoxPanel()
          ::volmapper_classname_id = ::win.AddLabel("VTK Class:","")
          ::GPU_page = ::win.BeginBoxPanel("3D texture memory")
            ::maxmemory_id = ::win.AddInt(&::maxmemory,"max",50,2000)
            ::win.SetCallback( &::OnTextureMemory)
            ::win.AddFloat(&::maxmemoryfraction,"fraction",0.05,1)
            ::win.SetCallback( &::OnTextureMemory)
          ::win.EndBoxPanel()

        #-------------------- Transf page --------------------------------------
        ::win.AddPage("Transf")
          # Control Opacity of each volume
          ::win.BeginBoxPanel("Volume Attenuation (Opacity)")
            ::opacity_attenuation_id = \
              ::win.AddFloat(&::opacity_attenuation,"First Volume",0,1)
            ::win.SetCallback( &::OnOpacity1)
            ::opacity_attenuation2_id = \
              ::win.AddFloat(&::opacity_attenuation2,"Second Volume",0,1)
            ::win.SetCallback( &::OnOpacity2)
            ::win.AddBoolean(::opacity_weight_one,"Sum = 1")
            ::win.SetCallback( &::OnOpacity1)
          ::win.EndBoxPanel()


          ::win.BeginBoxPanel("Second Volume Transform")

            # Parameters of the box
            #::win.BeginHorizontal()
            #::win.EndHorizontal()
            #del s;s = ::win.GetCurrentSizer()
            #s.GetItem(s.GetItemCount()-1).SetFlag(wx.wxALIGN_CENTER_HORIZONTAL)

            ::win.BeginHorizontal()
              ::win.AddBoolean(&::enable_transf_box, "Enable")
              ::win.SetCallback( &::OnTransfBox)
              ::win.AddBoolean(&::transfbox_enable_translation,"Trans")
              ::win.SetCallback( &::OnTransfBox)
              ::win.AddBoolean(&::transfbox_enable_rotation,   "Rot")
              ::win.SetCallback( &::OnTransfBox)
              ::win.AddBoolean(&::transfbox_enable_scaling,    "Scal")
              ::win.SetCallback( &::OnTransfBox)
            ::win.EndHorizontal()
            del s;s = ::win.GetCurrentSizer()
            s.GetItem(s.GetItemCount()-1).SetFlag(wx.wxALIGN_CENTER_HORIZONTAL)

            # Apply transformation from the BoxWidget
            ::win.BeginHorizontal()
              ::win.AddBoolean(&::transfbox_interactive,"Interactive")
              ::win.SetCallback( &::OnTransfBox)
              ::win.AddButton( "Apply",    &::ApplyTransfBox)
            ::win.EndHorizontal()
            del s;s = ::win.GetCurrentSizer()
            s.GetItem(s.GetItemCount()-1).SetFlag(wx.wxALIGN_CENTER_HORIZONTAL)

            # Deal with undo ...
            ::win.BeginHorizontal()
              ::win.AddButton( "Save",     &::SaveTransf)
              ::win.AddButton( "Restore",  &::RestoreTransf)
              ::win.AddButton( "Reset",    &::ResetTransf)
            ::win.EndHorizontal()
            del s;s = ::win.GetCurrentSizer()
            s.GetItem(s.GetItemCount()-1).SetFlag(wx.wxALIGN_CENTER_HORIZONTAL)

            # Save/Read disk
            ::win.BeginHorizontal()
              ::win.AddButton( "Save File",  &::SaveTransfDisk)
              ::win.AddButton( "Read File",  &::ReadTransfDisk)
            ::win.EndHorizontal()
            del s;s = ::win.GetCurrentSizer()
            s.GetItem(s.GetItemCount()-1).SetFlag(wx.wxALIGN_CENTER_HORIZONTAL)

          ::win.EndBoxPanel()

        #-------------------- Shade page --------------------------------------
        ::win.AddPage("Shade")
          ::win.BeginBoxPanel("Global opacity")
            ::win.AddFloat(&::opacity_attenuation,"Opacity factor",0,1)
            ::win.SetCallback( &::OnWindow)
          ::win.EndBoxPanel()

          ::win.BeginBoxPanel("Shading properties")
            ::win.AddBoolean(&::use_shade,"Use Shade")
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::ambient,"Ambient",0,1)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::diffuse,"Diffuse",0,1)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::specular,"Specular",0,1)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::specular_power,"Spec_Power",0,50)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::scalar_opacity_unitdistance,"Opa_dist",0.2,2)
            ::win.SetCallback( &::OnRender)
          ::win.EndBoxPanel()

        #-------------------- Blend page --------------------------------------
        ::imhisto1.SetParentPanel(&::win)
        ::imhisto1.log10=true
        ::imhisto1.Gui()
        #::win.AddBoolean(&::move_2,"move_2")
        ::win.AddPage("Blend", &::imhisto1->win)
          ::win.BeginHorizontal()
            ::icons.LoadIconPNG2("Chart xy","Chart_xy")
            ::AddBitmapButton16(&::win, &::icons._Chart_xy, "UpdateHistogram")
            ::win.AddButton("DrawTr",&::Draw_Functions)
            ::blend_mode_id = ::win.AddEnum(&::blend_mode,"Mode")
              ::win.AddEnumChoice(::blend_mode_id,"Composite")
              ::win.AddEnumChoice(::blend_mode_id,"Max. Int.")
              ::win.AddEnumChoice(::blend_mode_id,"Min. Int.")
              ::win.AddEnumChoice(::blend_mode_id,"Additive.")
         ::win.EndHorizontal()

        #-------------------- Blend2 page --------------------------------------
        ::imhisto2.SetParentPanel(&::win)
        ::imhisto2.log10=true
        ::imhisto2.Gui()
        ::win.AddPage("Blend2", &::imhisto2->win)
          ::win.BeginHorizontal()
            ::win.AddLabel("Second Dataset in the vtkVolume","")
            #::icons.LoadIconPNG2("Chart xy","Chart_xy")
            #::AddBitmapButton16(&::win, &::icons._Chart_xy, "UpdateHistogram")
            #::win.AddButton("DrawTr",&::Draw_Functions)
            #::blend_mode_id = ::win.AddEnum(&::blend_mode,"Mode")
              #::win.AddEnumChoice(::blend_mode_id,"Composite")
              #::win.AddEnumChoice(::blend_mode_id,"Max. Int.")
              #::win.AddEnumChoice(::blend_mode_id,"Min. Int.")
              #::win.AddEnumChoice(::blend_mode_id,"Additive.")
          ::win.EndHorizontal()

      ::win.EndBook()

      printn "vtkVolumeClass::AddGui end"
    }
  } # end Class

}
# end if
