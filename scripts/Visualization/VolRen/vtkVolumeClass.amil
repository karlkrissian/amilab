
func "Common/ScriptGui"
func "Visualization/VolRen/SimplevtkVolumeClass"

if (!exists(vtkVolumeClass)) {

  #-----------------------------------------------------
  #  vtkVolumeClass
  #-----------------------------------------------------
  Class vtkVolumeClass : public ScriptGui, SimplevtkVolumeClass {

    # load the ImageHistogram script
    func "Visualization/ImageHistogram/ImageHistogramClass.amil"
    func "dwCurveIOClass.amil"

    func "vtkCurveClass.amil"
    ::vtkcurveclass = &vtkCurveClass

    ImageHistogramClass             ::imhisto1
    # Input/Output operations to work with the curve on the histogram
    dwCurveIOClass                  ::CurveIO

    #----------------------------
    proc ::Init( ) {
      #comentado
      ::InitInherit()
      #::clip = UCHAR(0), "Enable/Disable clipping box"
      #::clip_enable_rotation = UCHAR(0), "Enable clip rotation"
      #::clip_interactive = UCHAR(1), "Interactive clipping"
      #::initialized=0
      #::maxmemory = INT(512), "Max. 3D texture GPU memory in Mb (2^8 bytes)"
      #::maxmemoryfraction = 1, "Maximal fraction of 3D max. 3D texture memory to use."
      #::SampleDistance = 1, "distance between samples used for rendering"
      #::ImageSampleDistance = 1, "Sampling distance in the XY image dimensions. Default value of 1 meaning 1 ray cast per pixel. If set to 0.5, 4 rays will be cast per pixel. If set to 2.0, 1 ray will be cast for every 4 (2 by 2) pixels. This value will be adjusted to meet a desired frame rate when AutoAdjustSampleDistances is on. "
      #::AutoAdjustSampleDistances = UCHAR(1), "Auto-adjust sample distances"
      #::use_shade = UCHAR(1), "use shading"
      #::ambient   = 0.15, "ambient coefficient"
      #::diffuse   = 0.9, "diffuse coefficient"
      #::specular  = 0.3, "specular coefficient"
      #::specular_power = 15.0, "specular power"
      #::scalar_opacity_unitdistance = 0.8919, "scalar opacity unit distance"
      ##::volrenmapper_type = INT(0), "Volume Rendering Mapper type 0: GPU, 1: Fixed Point 2: Standard"
      #::blend_mode = INT(0), "0: Composite, 1: Maximum Intensity, 2:Minimum Intensity, 3:Additive_blend"


      ::curve_folder    =  "", "Histogram curve Path Folder"
      ::curve_filename  =  "Curve.amil", "name of the input/output histogram curve"

      ::opacitywindow = 1000, "Opacity Window"
      ::opacitylevel  = 1000, "Opacity Level"
      ::cm_active_blend_curves = 0, "Number of curves created for the current blend type in the Colormap  drawing area."
      ::dw_active_blend_curves = 0, "Number of curves created for the current blend type in the Histogram drawing area."

      ::opacity_attenuation = 1, "Attenuation factor for the opacity"
      #comentado
    }

   #----------------------------
    proc ::SaveVTKCurve(STRING path){
      del aux_curve
      ::vtkcurveclass aux_curve

      aux_curve.category    = "UNKNOWN"
      aux_curve.type        = "UNKNOWN_curve"
      aux_curve.descripcion = "general descripcion"

        del color
        color=vector_double(3,0)
        ::renderer.GetBackground (&color[0], &color[1], &color[2])
        del color2
        color2=vector_double(3,0)
        ::renderer.GetBackground (&color2[0], &color2[1], &color2[2])

      aux_curve.SetColorFun(&::colorFun)
      aux_curve.SetOpacityFun(&::opacityFun)
      aux_curve.SetPropertyFun(&::property)
      aux_curve.r1   = 255*color[0]
      aux_curve.g1   = 255*color[1]
      aux_curve.b1   = 255*color[2]
      aux_curve.r2   = 255*color2[0]
      aux_curve.g2   = 255*color2[1]
      aux_curve.b2   = 255*color2[2]
      aux_curve.Gradient    = 1
      if (color[0]==color2[0] && color[1]==color2[1] && color[2]==color2[2]){
        aux_curve.Gradient = 0
      }
      aux_curve.min_x = 0
      aux_curve.max_x = 1
      aux_curve.norma = 0
      printn "GetInput = %1%" % ::volmapper.GetInput()
      if (exists(::selected_curv)){
        aux_curve.norma = ::selected_curv.norma
        aux_curve.category    = ::selected_curv.category
        aux_curve.type        = ::selected_curv.type
        aux_curve.descripcion = ::selected_curv.descripcion
        aux_curve.norma = ::selected_curv.norma
      }
      aux_curve.blend_mode  = ::blend_mode
      aux_curve.Save(path)
    }
 
    #----------------------------
    proc ::CB_Clip(OBJECT caller, NUM id) \
    {
      if (::clip_interactive) {
        planes = vtk.vtkPlanes.New()
        ::box.GetPlanes(&planes)
        ::volmapper->SetClippingPlanes(&planes);
      }
    }

    #----------------------------
    proc ::InitBoxWidget() \
    {
      ::box = vtk.vtkBoxWidget.New()
      if (::clip) \
      {
        ::box.SetInteractor(&::renwininter)
        ::box.SetPlaceFactor(1.01)
        ::box.SetInput(&::vtkinput)
        
        ::box.SetDefaultRenderer(&::renderer)
        ::box.InsideOutOn()
        ::box.PlaceWidget()
        #vtkBoxWidgetCallback *callback = vtkBoxWidgetCallback::New();
        #callback->SetMapper(mapper);
        ::box_cmd = vtk.vtkAmiCommand.New()
        ::box_cmd.SetAmiFunction(&::CB_Clip)
        ::box.AddObserver(vtk.vtkCommand.InteractionEvent, &::box_cmd);
        #callback->Delete();
        ::box.SetRotationEnabled(::clip_enable_rotation)
        ::box.EnabledOn()
        #::box.GetSelectedFaceProperty().SetOpacity(0.0)
      }
    }


    #----------------------------
    proc ::SetLinearCurve( OBJECT curve) \
    {
        #if (!exists(::SetLinearCurve_first)) {
          #ccurv = &::imhisto1.dw.GetControlledCurves()
          #size=ccurv.size()
          #if size==1 {
            #ccurv.pop_back()
            #size=0
          #}
          #ccurv.push_back(&curve)
          #::linearcurve1_id = ccurv.size()-1
          #::linearcurve1 = &ccurv[size]
          #c = size
        #} else {
          #::linearcurve1 = curve
          ::imhisto1.dw.DrawLinearCM()
          ccurv = &::imhisto1.dw.GetControlledCurves()
          printn "NUM CURV %1%" %ccurv.size()
          printn "linearcurve1_id %1%" %::linearcurve1_id
          if (::linearcurve1_id<ccurv.size()) {
            ccurv[::linearcurve1_id] = curve
          } else {
            ccurv.push_back(&curve)
            ::linearcurve1_id = ccurv.size()-1
          }
        #}
        ::SetLinearCurve_first=false
    }

    #---------------------------
    proc ::OnCtrlPoint() \
    {
      ::imhisto1.dw._Paint()
      ::imhisto1.ColormapMinMax()
      ::imhisto1.UpdateCM()
      ::OnRender()
      #::Draw_opacityFun()
    }

    #----------------------------
    proc ::SaveCurve(  ) \
    {
      thefilename = wx.wxFileName(&::curve_folder, &::curve_filename)
      if(thefilename.FileExists()) {
        msg = "The %1% file exists." %thefilename.GetFullName().c_str()
      } else {
        if (!exists(::linearcurve1)) {
          msg = "It is not possible to save the curve because it has not been defined."
        } else {
          ::CurveIO.SaveCurve( thefilename.GetFullName().c_str(), &::linearcurve1 )
          msg = "The curve has been saved correctly in the file: %1%" % thefilename.GetFullName().c_str()
        }
      }
      InfoDialog msg
    }

    #----------------------------
    proc ::LoadCurve(  ) \
    {
      thefilename = wx.wxFileName(&::curve_folder, &::curve_filename)
      if(thefilename.FileExists()) {
        ::linearcurve1 = ::CurveIO.LoadCurve( thefilename.GetFullName().c_str() )
        msg = "The curve has been loaded correctly from the file: %1%" %thefilename.GetFullName().c_str()
      } else {
        msg = "The %1% file does not exist." %thefilename.GetFullName().c_str()       
      }
      InfoDialog msg
    }

    #----------------------------
    proc ::ResetLinearCurve1() \
    {
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      if (exists(::imhisto1->h)) {
        hmax = max(::imhisto1.h[0])

        # http://www.wikiradiography.com/page/Hounsfield++unit
        #It is the definition for CT scanners that are calibrated with reference to water.
        #Tissue CT number (HU)
        #Bone  1000
        #Liver   40 - 60
        #White matter  ~20-30 HU
        #Grey matter   ~37-45 HU
        #Blood   40
        #Muscle  10 - 40
        #Kidney  30
        #Cerebrospinal fluid   15
        #Water   0
        #Fat   -50 - -100
        #Air   -1000

        # default intensity values
        px1 = 1080
        px3 = 1130
        px4 = 1390
        px2 = 1100
        o1 = 0
        o2 = 0.005
        o3 = 0.08
        o4 = 0.5
        imin = ::imhisto1.minval
        imax = ::imhisto1.maxval
        if  (imin>px1)||(imax<px1)||(imin>px2)||(imax<px2) \
        { 
          # set position within intensity range
          px1 = imin+(imax-imin)*0.4
          px2 = imin+(imax-imin)*0.5
          px3 = imin+(imax-imin)*0.6
          px4 = imin+(imax-imin)*0.9
          o1 = 0
          o2 = 0.3
          o3 = 0.4
          o4 = 0.9
        }

        # Create the curve
        curve = ami.dwControlledCurve()

        # black point
        cp0 = ami.dwControlPoint(px1,o1*hmax)
        cp0.SetYLocked(1)
        cp0.SetColour(wx.wxColour(0,0,0))
        curve.GetControlPoints().push_back(&cp0)

        # red point
        cp1 = ami.dwControlPoint(px2,o2*hmax)
        cp1.SetColour(wx.wxColour(255,0,0))
        curve.GetControlPoints().push_back(&cp1)

        # yellow point
        cp2 = ami.dwControlPoint(px3,o3*hmax)
        cp2.SetColour(wx.wxColour(255,255,0))
        curve.GetControlPoints().push_back(&cp2)

        # white point
        cp3 = ami.dwControlPoint(px4,o4*hmax)
        cp3.SetColour(wx.wxColour(255,255,255))
        curve.GetControlPoints().push_back(&cp3)

        curve.SetType(1) # solid
        ::SetLinearCurve(&curve)
        #::imhisto1.dw.SetCtrlPointCallback(&::OnCtrlPoint)
        ::imhisto1.dw.SetPaintCallback(&::OnCtrlPoint)
        ::use_shade=1
      } else {
        InfoDialog "No histogram available."
      }
        
    }

    #----------------------------
    proc ::SetShadingProperties() \
    {
      ::property.SetShade(::use_shade)
      ::property.SetAmbient(::ambient)
      ::property.SetDiffuse(::diffuse)
      ::property.SetSpecular(::specular)
      ::property.SetSpecularPower(::specular_power)
      ::property.SetScalarOpacityUnitDistance(::scalar_opacity_unitdistance)
    }

    #----------------------------
    proc ::BlendLinearCurve1() \
    {
      #printn "BlendLinearCurve1"
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      if (exists(::imhisto1->h)) {
        curves = ::imhisto1.dw.GetControlledCurves()
        numcurves = curves.size()
        if (!exists(::linearcurve1_id)) {
          printn "--"
          ::linearcurve1_id   = numcurves
          ::ResetLinearCurve1()
        }

        # Create colors based on the curve
        hmax = max(::imhisto1.h[0])
        for n=0 to ::imhisto1.dw.GetSizelinearCM()-1 {
          printn "point number %1%" %n
          y =  ::opacity_attenuation/hmax*::imhisto1.dw.GetAlphalinearCM(n)
          pos = ::imhisto1.dw.GetPoslinearCM(n)
          col = ::imhisto1.dw.GetColourlinearCM(n)
          ::colorFun.AddRGBPoint( pos, \
                                  1.0/255*col.Red(), \
                                  1.0/255*col.Green(),\
                                  1.0/255*col.Blue(),\
                                  0.5,\
                                  0);
          
          y = -max(-y,-1)
          ::opacityFun.AddPoint(  pos, y , 0.5,0)
        }
        ::SetShadingProperties()
      } else {
        InfoDialog "No histogram available."
      }
    }

    #----------------------------
    proc ::PreviewApplied(OBJECT vtkcurve) \
    {
      del ::selected_curv
      //::selected_curv = &::previewer.GetSelection()
      ::selected_curv = &vtkcurve
      
      # now create the curve based on the vtkCurveClass object
      ::SetBackground(::selected_curv.r1, ::selected_curv.g1, ::selected_curv.b1, \
                ::selected_curv.r2, ::selected_curv.g2, ::selected_curv.b2, ::selected_curv.Gradient ) 
     
      if (!exists(::imhisto1->h)) {

        ::UpdateHistogram()
      }
      hmax = max(::imhisto1.h[0])

      curve = ami.dwControlledCurve()

      n1 = ::selected_curv.colorFun.GetSize()
      n2 = ::selected_curv.opacityFun.GetSize()
      for n=0 to n1-1 {
        # add point
        vals  = vector_double(6)
        vals_op = vector_double(4)
        ::selected_curv.colorFun  .GetNodeValue(n,&vals [0])
        ::selected_curv.opacityFun.GetNodeValue(n,&vals_op[0])
        del cp
        # TODO: check compatibility between color and opacity functions ...
        cp = ami.dwControlPoint(vals[0],vals_op[1]*hmax)
        cp.SetColour(wx.wxColour(vals[1]*255,vals[2]*255,vals[3]*255))
        cp.Setmidpoint(vals[4])
        cp.Setsharpness(vals[5])
        curve.GetControlPoints().push_back(&cp)
      }
      curve.SetType(1) # solid
      ::SetLinearCurve(&curve)
      ::ambient  = ::selected_curv.property.GetAmbient()
      ::diffuse  = ::selected_curv.property.GetDiffuse()
      ::specular = ::selected_curv.property.GetSpecular()
      ::specular_power =  ::selected_curv.property.GetSpecularPower()
      ::scalar_opacity_unitdistance =  ::selected_curv.property.GetScalarOpacityUnitDistance()

      ::use_shade   = ::selected_curv.use_shade
      ::blend_mode  = ::selected_curv.blend_mode
      ::SetLinearCurve(&curve)
      ::OnRender()
      ::win.Update(-1)
    }

    #----------------------------
    proc ::ReCompute() \
    {
        del ::colorFun
        del ::opacityFun
        del ::property
        ::colorFun=vtk.vtkColorTransferFunction.New()
        ::opacityFun=vtk.vtkPiecewiseFunction.New()
        # Create the property and attach the transfer functions
        ::property = vtk.vtkVolumeProperty.New()
        ::property.SetIndependentComponents(1)
        ::property.SetColor( &::colorFun )
        ::property.SetScalarOpacity( &::opacityFun )
        ::property.SetInterpolationTypeToLinear()

        # connect up the volume to the property and the mapper
        ::vol.SetProperty( &::property )
        ::BlendLinearCurve1()       
        ::volmapper.SetBlendMode(::blend_mode)
    }

    #----------------------------
    proc ::Draw_colorFun() \
    {
      ctf = &::colorFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        h1 = Resize(h,256,1,1,1)
        ::ctf_color <<= (RGB) h1
        spos = SpacePos(::ctf_color)
        pos = spos[0]
        #print "\n"
        for x=0 to ::ctf_color.tx-1 {
          ::ctf_color.setpos(x,0,0)
          xpos = pos(x)
          ::ctf_color.set(ctf.GetRedValue(  xpos)*250, \
                          ctf.GetGreenValue(xpos)*250, \
                          ctf.GetBlueValue( xpos)*250 )
        }
        # position curves in ColorMap window of ::imhisto1
        if(exists( ::imhisto1->cm)){
          curves = ::imhisto1.cm.GetCurves()
          numcurves = curves.size()
          
          if (!exists(::red_id)) {
            ::red_id   = numcurves
            ::green_id = numcurves+1
            ::blue_id  = numcurves+2
          }

          ::imhisto1.cm.SetCurve(::ctf_color[0],::red_id)
          ::imhisto1.cm.SetCurve(::ctf_color[1],::green_id)
          ::imhisto1.cm.SetCurve(::ctf_color[2],::blue_id)

          ::imhisto1.cm.SetCurveProperties(::red_id,  "#FF0000")
          ::imhisto1.cm.SetCurveProperties(::green_id,"#00FF00")
          ::imhisto1.cm.SetCurveProperties(::blue_id, "#0000FF")
        }
        
      }
    }

    #----------------------------
    proc ::Draw_greycolorFun() \
    {
      ctf = &::colorFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        ::ctf_color <<= Resize(h,256,1,1,1)
        spos = SpacePos(::ctf_color)
        pos = spos[0]
        #print "\n"
        for x=0 to ::ctf_color.tx-1 {
          ::ctf_color.setpos(x,0,0)
          ::ctf_color.set(ctf.GetRedValue(pos(x)))
        }
        ::ctf_color = ::ctf_color*250
        # position curves in ColorMap window of ::imhisto1
        if(exists( ::imhisto1->cm)){
          numcurves = ::imhisto1.cm.GetCurves().size()
          printn numcurves
          if (!exists(::red_id)) {
            ::red_id   = numcurves
            ::green_id = numcurves+1
            ::blue_id  = numcurves+2
          }
        
          ::imhisto1.cm.SetCurve(&::ctf_color,::red_id)
          ::imhisto1.cm.SetCurve(&::ctf_color,::green_id)
          ::imhisto1.cm.SetCurve(&::ctf_color,::blue_id)

          ::imhisto1.cm.SetCurveProperties(::red_id,  "#606060")
          ::imhisto1.cm.SetCurveProperties(::green_id,"#606060")
          ::imhisto1.cm.SetCurveProperties(::blue_id, "#606060")
    
        }
      }
    }

    #----------------------------
    proc ::Draw_opacityFun() \
    {
      otf = &::opacityFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        ::otf_im <<= Resize(h,256,1,1,1)
        spos = SpacePos(::otf_im)
        pos = spos[0]
        #print "\n"
        for x=0 to ::otf_im.tx-1 {
          ::otf_im.setpos(x,0,0)
          ::otf_im.set(otf.GetValue(pos(x)))
        }
        # position curves in ColorMap window of ::imhisto1
        if(exists( ::imhisto1->cm)){
          numcurves = ::imhisto1.cm.GetCurves().size()
          printn numcurves
          if (!exists(::otf_id)) {
            ::otf_id   = numcurves
          }
          ::otf_im = ::otf_im*250
          ::imhisto1.cm.SetCurve(::otf_im,::otf_id)
          ::imhisto1.cm.SetCurveProperties(::otf_id,  "#202020")
        }
      }
    }

    #----------------------------
    proc ::Draw_Functions() {
      //if (::blend_type<=2) {
      //  ::Draw_greycolorFun()
      //} else {
      ::Draw_colorFun()
      //}
      ::Draw_opacityFun()
      if(exists( ::imhisto1->cm)){
        ::imhisto1.cm._Paint()
      }
    }

    #----------------------------
    proc ::OnWindow() \
    {
      ::OnRender()
      ::Draw_Functions()
    }
    #----------------------------
    proc ::UpdateHistogram() \
    {
      if (exists(::imhisto1))&&(exists(::input)) {
        #printn "*"
        if (exists(::min_val)) {
          ::imhisto1.SetInput2(&::input,::min_val,::max_val)
        } else {
          ::imhisto1.SetInput(&::input)
        }
      }
    }
    Comments(::UpdateHistogram,"Updates the histogram with the current input image.")


     #----------------------------
    proc ::OnSampleDistance() \
    {
      ::volmapper.SetAutoAdjustSampleDistances(::AutoAdjustSampleDistances)
      ::volmapper.SetSampleDistance(::SampleDistance)
      ::volmapper.SetImageSampleDistance(::ImageSampleDistance)
      ::renwininter.Render()
    }
    #----------------------------
    proc ::Close() \
    {
      printn "Nothing to do"
      #if (exists(::previewer)){
        #::previewer.Close()
        #del ::previewer
      #}
    }


    #----------------------------
    proc ::AddGui( OBJECT win ) \
    {
      printn "vtkVolumeClass::AddGui begin"
      ::win = &win

      ::win.BeginBook()

        ::imhisto1.SetParentPanel(&::win)
        ::imhisto1.Gui()
        ::win.AddPage("Blend", &::imhisto1->win)
          ::win.BeginHorizontal()
            ::icons.LoadIconPNG2("Chart xy","Chart_xy")
            ::AddBitmapButton16(&::win, &::icons._Chart_xy, "UpdateHistogram")
            ::win.AddButton("DrawTr",&::Draw_Functions)
            ::blend_mode_id = ::win.AddEnum(&::blend_mode,"Mode")
              ::win.AddEnumChoice(::blend_mode_id,"Composite")
              ::win.AddEnumChoice(::blend_mode_id,"Max. Int.")
              ::win.AddEnumChoice(::blend_mode_id,"Min. Int.")
              ::win.AddEnumChoice(::blend_mode_id,"Additive.")
         ::win.EndHorizontal()

         ::win.AddPage("Clip")
          ::win.AddBoolean(&::clip, "Clip")
          ::win.SetCallback( &::OnClip)
          ::win.AddBoolean(&::clip_enable_rotation,"Rotation")
          ::win.AddBoolean(&::clip_interactive,"Interactive")
          ::win.SetCallback( &::OnClip)
          ::win.AddButton( "Apply Clip",&::ApplyClip)

        ::win.AddPage("Shade")
          ::win.BeginBoxPanel("Global opacity")
            ::win.AddFloat(&::opacity_attenuation,"Opacity factor",0,1)
            ::win.SetCallback( &::OnWindow)
          ::win.EndBoxPanel()

          ::win.BeginBoxPanel("Shading properties")
            ::win.AddBoolean(&::use_shade,"Use Shade")
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::ambient,"Ambient",0,1)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::diffuse,"Diffuse",0,1)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::specular,"Specular",0,1)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::specular_power,"Spec_Power",0,50)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::scalar_opacity_unitdistance,"Opa_dist",0.2,2)
            ::win.SetCallback( &::OnRender)
          ::win.EndBoxPanel()

        ::GPU_page = ::win.AddPage("GPU")
          ::volmapper_classname_id = ::win.AddLabel("VTK Class:","")
          ::win.BeginBoxPanel("3D texture memory")
            ::win.AddInt(&::maxmemory,"max",50,1000)
            ::win.SetCallback( &::OnTextureMemory)
            ::win.AddFloat(&::maxmemoryfraction,"fraction",0.05,1)
            ::win.SetCallback( &::OnTextureMemory)
          ::win.EndBoxPanel()

          //::GPU_page = 
          ::win.AddPage("Rend")
          ::win.BeginBoxPanel("Sample distances")
            ::win.AddBoolean(&::AutoAdjustSampleDistances,"Auto")
            #::win.SetCallback( &::OnSampleDistance)
            ::win.AddFloat(&::SampleDistance,"Dist",0.2,2)
            #::win.SetCallback( &::OnSampleDistance)
            ::win.AddFloat(&::ImageSampleDistance,"Im Dist",0.2,2)
            ::win.AddButton("Apply",&::OnSampleDistance)
          ::win.EndBoxPanel()
          
      ::win.EndBook()

      printn "vtkVolumeClass::AddGui end"
    }
  } # end Class

}
# end if
