
func "Common/ScriptGui"


if (!exists(vtkVolumeClass)) {

  #-----------------------------------------------------
  #  vtkVolumeClass
  #-----------------------------------------------------
  Class vtkVolumeClass : public ScriptGui {

    # load the ImageHistogram script
    func "Visualization/ImageHistogram/ImageHistogramClass.amil"
    func "dwCurveIOClass.amil"

    func "PreviewerClass.amil"
    ::previewerclass=&PreviewerClass

    func "vtkCurveClass.amil"
    ::vtkcurveclass = &vtkCurveClass

    ImageHistogramClass             ::imhisto1
    # Input/Output operations to work with the curve on the histogram
    dwCurveIOClass                  ::CurveIO

    #----------------------------
    proc ::Init( ) {
      ::blend_type = INT(7), "Blend type: 0->MIP, 1->CompositeRamp, 2->CompositeShadeRamp, 3->CT_Skin, 4->CT_Bone, 5->CT_Muscles, 6->RGB_Composite, 7->Linear Curve 1"
      ::opacitywindow = 1000, "Opacity Window"
      ::opacitylevel  = 1000, "Opacity Level"

      ::skin1 = -1000, "Skin first control point"
      ::skin2 =  -500, "Skin second control point"

      ::bones1 = -16,  "Bones first control point"
      ::bones2 =  641, "Bones second control point"

      ::muscles1 = -155, "Muscles first control point"
      ::muscles2 =  217, "Muscles second control point"
      ::muscles3 =  420, "Muscles third control point"

      ::clip = UCHAR(0), "Enable/Disable clipping box"
      ::clip_enable_rotation = UCHAR(0), "Enable clip rotation"
      ::clip_interactive = UCHAR(0), "Interactive clipping"
      ::initialized=0

      ::cm_active_blend_curves = 0, "Number of curves created for the current blend type in the Colormap  drawing area."
      ::dw_active_blend_curves = 0, "Number of curves created for the current blend type in the Histogram drawing area."

      ::opacity_attenuation = 1, "Attenuation factor for the opacity"

      ::maxmemory = INT(0), "Max. 3D texture GPU memory in Mb (2^8 bytes)"
      ::maxmemoryfraction = 1, "Maximal fraction of 3D max. 3D texture memory to use."

      ::SampleDistance = 1, "distance between samples used for rendering"
      ::ImageSampleDistance = 1, "Sampling distance in the XY image dimensions. Default value of 1 meaning 1 ray cast per pixel. If set to 0.5, 4 rays will be cast per pixel. If set to 2.0, 1 ray will be cast for every 4 (2 by 2) pixels. This value will be adjusted to meet a desired frame rate when AutoAdjustSampleDistances is on. "
      ::AutoAdjustSampleDistances = UCHAR(1), "Auto-adjust sample distances"

      ::use_shade = UCHAR(1), "use shading"
      ::ambient   = 0.15, "ambient coefficient"
      ::diffuse   = 0.9, "diffuse coefficient"
      ::specular  = 0.3, "specular coefficient"
      ::specular_power = 15.0, "specular power"
      ::scalar_opacity_unitdistance = 0.8919, "scalar opacity unit distance"

      ::curve_folder    =  "", "Histogram curve Path Folder"
      ::curve_filename  =  "Curve.amil", "name of the input/output histogram curve"

      ::volrenmapper_type = INT(0), "Volume Rendering Mapper type 0: GPU, 1: Fixed Point 2: Standard"

      ::blend_mode = INT(0), "0: Composite, 1: Maximum Intensity, 2:Minimum Intensity"

    }

    #----------------------------
    proc ::SetVolRenMapper( NUM type ) {
      ::volrenmapper_type = type
    }

    #----------------------------
    proc ::SetInteractor( OBJECT inter ) {
      ::renwininter = &inter
    }

    #----------------------------
    proc ::SetRenderer( OBJECT ren ) {
      ::renderer = &ren
    }

    #----------------------------
    proc ::SetRenderWindow( OBJECT renwin ) {
      ::renwin = &renwin
    }

    # Inputs:
    #   input_image : input InrImage volume
    #
    # Outputs:
    #   vol        : vtkVolume
    #   volmapper  : vtkGPUVolumeRayCastMapper
    #   colorFun   : vtkColorTransferFunction
    #   opacityFun : vtkPiecewiseFunction
    #   property   : vtkVolumeProperty
    #
    proc ::CreateVTK( IMAGE input_image) {
      #printn "CreateVTK 1"
      ::input = &input_image

      # 10/(1+clip) in c++ code
      #::renwin_interact.SetDesiredUpdateRate(10)

      # check that we have a volume
      if (input_image.tx<2)||(input_image.ty<2)||(input_image.tz<2) {
        InfoDialog "Input image is not a volume!"
        return = false
      } else {

        # Create our transfer function
        ::colorFun=vtk.vtkColorTransferFunction.New()
        ::opacityFun=vtk.vtkPiecewiseFunction.New()
        
        # Create the property and attach the transfer functions
        ::property = vtk.vtkVolumeProperty.New()
        ::property.SetIndependentComponents(1)
        ::property.SetColor( &::colorFun )
        ::property.SetScalarOpacity( &::opacityFun )
        ::property.SetInterpolationTypeToLinear()
 
        #printn "CreateVTK 2"

        ::vol       = vtk.vtkVolume.New()
        # don't put the boxwidget for the moment
        # convert input to vtkimage
        ::vtkinput  = vtktools.ToVtkImageData(&input_image)

        if ::volrenmapper_type==0 {
          ::volmapper = vtk.vtkGPUVolumeRayCastMapper.New()
        } else {
          if ::volrenmapper_type==1 {
            ::volmapper = vtk.vtkFixedPointVolumeRayCastMapper.New()
          } else {
            ::volmapper = vtk.vtkVolumeRayCastMapper.New()
          } 
        }

        #::volmapper.SetSampleDistance()

        # Temporary code: BEGIN
        # It solves temporarily the problem of OpenGL's initialization.
        #InfoDialog "Force get OpenGL current context"
        ::renwin.MakeCurrent()
        
        cap = ::renwin.ReportCapabilities()
        if (wx.wxString(cap).Find("version")==-1) {
          InfoDialog "Capabilities %1%" % ::renwin.ReportCapabilities()
        }
        # Temporary code: END

        if (::volrenmapper_type==0) {
          # Check if the rendering is supported
          supported = ::volmapper.IsRenderSupported( &::renwin, &::property)
          #supported = 0
          if (!supported) {
            mappername=::volmapper.GetClassName()
            InfoDialog mappername+" rendering is not supported, trying vtkFixedPointVolumeRayCastMapper ..."
            if (exists(::volmapper)) {
              #::volmapper->Delete()
              del ::volmapper
            }
            #::volmapper = vtk.vtkVolumeRayCastMapper.New()
            ::volmapper = vtk.vtkFixedPointVolumeRayCastMapper.New()
            ::volrenmapper_type=1
            ::win.Update(-1)

            #printn "CreateVTK 3"

            compositeFunction=vtk.vtkVolumeRayCastCompositeFunction.New()
            ::volmapper.SetVolumeRayCastFunction(&compositeFunction)

            # don't put the boxwidget for the moment
            # convert input to vtkimage
            ::vtkinput  = vtktools.ToVtkImageData(&input_image)

            #supported = ::volmapper.IsRenderSupported( &::renwin, &::property)
            #if (!supported) {
            #  InfoDialog "This rendering is not supported neither ..."
            #}
          }
        }

        if (::volrenmapper_type==0) {
          # update GPU information
          ::maxmemory = 512
//::volmapper.GetMaxMemoryInBytes()/(1024*1024)
          ::maxmemoryfraction = ::volmapper.GetMaxMemoryFraction()
          ::OnTextureMemory()
          #::win.Update(-1)
        }
        ::win.SetLabelValue(::volmapper_classname_id,::volmapper.GetClassName())
        ::volmapper.SetInput(&::vtkinput)

        # connect up the volume to the property and the mapper
        ::vol.SetProperty( &::property )
        ::vol.SetMapper( &::volmapper )
        ::initialized = 1

        return = true
      }
    }

    #----------------------------
    proc ::CB_Clip(OBJECT caller, NUM id) \
    {
      if (::clip_interactive) {
        planes = vtk.vtkPlanes.New()
        ::box.GetPlanes(&planes)
        ::volmapper->SetClippingPlanes(&planes);
      }
    }

    #----------------------------
    proc ::InitBoxWidget() \
    {
      ::box = vtk.vtkBoxWidget.New()
      if (::clip) \
      {
        ::box.SetInteractor(&::renwininter)
        ::box.SetPlaceFactor(1.01)
        ::box.SetInput(&::vtkinput)
        
        ::box.SetDefaultRenderer(&::renderer)
        ::box.InsideOutOn()
        ::box.PlaceWidget()
        #vtkBoxWidgetCallback *callback = vtkBoxWidgetCallback::New();
        #callback->SetMapper(mapper);
        ::box_cmd = vtk.vtkAmiCommand.New()
        ::box_cmd.SetAmiFunction(&::CB_Clip)
        ::box.AddObserver(vtk.vtkCommand.InteractionEvent, &::box_cmd);
        #callback->Delete();
        ::box.SetRotationEnabled(::clip_enable_rotation)
        ::box.EnabledOn()
        #::box.GetSelectedFaceProperty().SetOpacity(0.0)
      }
    }

    #----------------------------
    proc ::ResetVTK() \
    {
      ::initialized = 0
      del ::renwininter # it is a reference, no call to Delete()
      del ::input

      #::vol.Delete() # here should do it with variable smart pointers
      del ::vol
      #::volmapper.Delete()
      del ::volmapper
      #::colorFun.Delete()
      del ::colorFun
      #::opacityFun.Delete()
      del ::opacityFun
      #::property.Delete()
      del ::property
    }

    #----------------------------
    #proc ::BlendMIP() \
    #{
      #::colorFun.AddRGBPoint(0.0, 1.0, 1.0, 1.0)
      #::colorFun.AddRGBPoint(255.0, 1.0, 1.0, 1.0 )
      #::opacityFun.AddRGBPoint( ::opacitylevel - 0.5*::opacitywindow, 0.0)
      #::opacityFun.AddRGBPoint(::opacitylevel + 0.5*::opacitywindow, ::opacity_attenuation )
    #}

    #----------------------------
    proc ::SetLinearCurve( OBJECT curve) \
    {
        if (!exists(::linearcurve1)) {
          ccurv = &::imhisto1.dw.GetControlledCurves()
          size=ccurv.size()
          if size==1 {
            ccurv.pop_back()
            size=0
          }
          ccurv.push_back(&curve)
          ::linearcurve1 = &ccurv[size]
          ::linearcurve1_id = size
        } else {
          ::linearcurve1 = curve
        }
    }

    #----------------------------
    proc ::ResetMIPCurve() \
    {
      printn "::ResetMIPCurve()"
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      if (exists(::imhisto1->h)) {
        hmax = max(::imhisto1.h[0])
        # Create the curve
        curve = ami.dwControlledCurve()

        # black point
        cp0 = ami.dwControlPoint(0.0,0.0)
        cp0.SetYLocked(1)
        cp0.SetColour(wx.wxColour(0,0,0))
        curve.GetControlPoints().push_back(&cp0)

        # white point
        cp3 = ami.dwControlPoint(255,::opacity_attenuation*hmax)
        cp3.SetColour(wx.wxColour(255,255,255))
        curve.GetControlPoints().push_back(&cp3)

        curve.SetType(1) # solid
        # min =  ::opacitylevel - 0.5*::opacitywindow
        # max =  ::opacitylevel + 0.5*::opacitywindow
        ::SetLinearCurve(&curve)
      }
    }

    ##----------------------------
    #proc ::BlendCompositeRamp() \
    #{
      #::colorFun.AddRGBSegment( ::opacitylevel - 0.5*::opacitywindow, 0.0, 0.0, 0.0, \
                              #::opacitylevel + 0.5*::opacitywindow, 1.0, 1.0, 1.0 )

      #::opacityFun.AddSegment( ::opacitylevel - 0.5*::opacitywindow, 0.0, \
                             #::opacitylevel + 0.5*::opacitywindow, ::opacity_attenuation )
      #::property.ShadeOff()
    #}

    #----------------------------
    proc ::ResetCompositeRamp() \
    {
      printn "::ResetMIPCurve()"
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      if (exists(::imhisto1->h)) {
        hmax = max(::imhisto1.h[0])
        # Create the curve
        curve = ami.dwControlledCurve()

        # first point
        cp0 = ami.dwControlPoint( ::opacitylevel - 0.5*::opacitywindow,\
                                  0.0)
        cp0.SetColour(wx.wxColour(0,0,0))
        curve.GetControlPoints().push_back(&cp0)

        # second point
        cp1 = ami.dwControlPoint( ::opacitylevel + 0.5*::opacitywindow,\
                                  ::opacity_attenuation*hmax)
        cp1.SetColour(wx.wxColour(255,255,255))
        curve.GetControlPoints().push_back(&cp1)
        curve.SetType(1) # solid
        # min =  ::opacitylevel - 0.5*::opacitywindow
        # max =  ::opacitylevel + 0.5*::opacitywindow
        ::SetLinearCurve(&curve)
      }
      ::use_shade=0
    }

    #----------------------------
    #proc ::BlendCompositeShadeRamp() \
    #{
      #::colorFun.AddRGBSegment(0.0, 1.0, 1.0, 1.0, 255.0, 1.0, 1.0, 1.0 );
      #::opacityFun.AddSegment( ::opacitylevel - 0.5*::opacitywindow, 0.0, \
                               #::opacitylevel + 0.5*::opacitywindow, ::opacity_attenuation );
      #::property.ShadeOn();
    #}

    #----------------------------
    proc ::ResetCompositeShadeRamp() \
    {
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      if (exists(::imhisto1->h)) {
        hmax = max(::imhisto1.h[0])
        # Create the curve
        curve = ami.dwControlledCurve()

        # first point
        cp0 = ami.dwControlPoint( ::opacitylevel - 0.5*::opacitywindow,\
                                  0.0)
        cp0.SetColour(wx.wxColour(255,255,255))
        curve.GetControlPoints().push_back(&cp0)

        # second point
        cp1 = ami.dwControlPoint( ::opacitylevel + 0.5*::opacitywindow,\
                                  ::opacity_attenuation*hmax)
        cp1.SetColour(wx.wxColour(255,255,255))
        curve.GetControlPoints().push_back(&cp1)
        curve.SetType(1) # solid
        # min =  ::opacitylevel - 0.5*::opacitywindow
        # max =  ::opacitylevel + 0.5*::opacitywindow
        ::SetLinearCurve(&curve)
      }
      ::use_shade=1
    }

    #----------------------------
    proc ::SkinReset() \
    {
      ::skin1 = -1000
      ::skin2 =  -500
      ::win.Update(-1)
      ::OnRender()
    }

    ##----------------------------
    #proc ::BlendCTSkin() \
    #{
      #::colorFun.AddRGBPoint( -3024, 0, 0, 0, 0.5, 0.0 );
      #::colorFun.AddRGBPoint( ::skin1, 0.62, 0.36, 0.18, 0.5, 0.0 );
      #::colorFun.AddRGBPoint( ::skin2, 0.88, 0.60, 0.29, 0.33, 0.45 );
      #::colorFun.AddRGBPoint( 3071, 0.83, 0.66, 1, 0.5, 0.0 );
      
      #::opacityFun.AddPoint(-3024, 0, 0.5, 0.0 );
      #::opacityFun.AddPoint(::skin1, 0, 0.5, 0.0 );
      #::opacityFun.AddPoint(::skin2, 1.0*::opacity_attenuation, 0.33, 0.45 );
      #::opacityFun.AddPoint(3071, 1.0, 0.5, 0.0);

      #::property.ShadeOn();
      #::property.SetAmbient(0.1);
      #::property.SetDiffuse(0.9);
      #::property.SetSpecular(0.2);
      #::property.SetSpecularPower(10.0);
      #::property.SetScalarOpacityUnitDistance(0.8919);
    #}

    #----------------------------
    proc ::ResetCTSkin() \
    {
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      if (exists(::imhisto1->h)) {
        hmax = max(::imhisto1.h[0])
        # Create the curve
        curve = ami.dwControlledCurve()

        # first point
        cp = ami.dwControlPoint( -3024, 0.0)
        cp.SetColour(wx.wxColour(0,0,0))
        cp.Setmidpoint(0.5)
        cp.Setsharpness(0)
        curve.GetControlPoints().push_back(&cp)

        # 2nd point
        del cp
        cp = ami.dwControlPoint( ::skin1, 0.0)
        cp.SetColour(wx.wxColour(0.62*255,0.36*255,0.18*255))
        cp.Setmidpoint(0.5)
        cp.Setsharpness(0)
        curve.GetControlPoints().push_back(&cp)

        # 3rd point
        del cp
        cp = ami.dwControlPoint( ::skin2, ::opacity_attenuation*hmax)
        cp.SetColour(wx.wxColour(0.88*255,0.60*255,0.29*255))
        cp.Setmidpoint(0.33)
        cp.Setsharpness(0.45)
        curve.GetControlPoints().push_back(&cp)

        # 4th point
        del cp
        cp = ami.dwControlPoint( 3071, ::opacity_attenuation*hmax)
        cp.SetColour(wx.wxColour(0.83*255,0.66*255,1*255))
        cp.Setmidpoint(0.5)
        cp.Setsharpness(0)
        curve.GetControlPoints().push_back(&cp)

        curve.SetType(1) # solid
        ::SetLinearCurve(&curve)
      }
      ::use_shade=1
      ::ambient=0.1
      ::diffuse=0.9
      ::specular=0.2
      ::specular_power=10.0
      ::scalar_opacity_unitdistance=0.8919
    }



    #----------------------------
    proc ::BonesReset() \
    {
      ::bones1 = -16
      ::bones2 =  641
      ::win.Update(-1)
      ::OnRender()
    }

    #----------------------------
    proc ::BlendCTBones() \
    {
      ::colorFun.AddRGBPoint( -3024, 0, 0, 0, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( ::bones1, 0.73, 0.25, 0.30, 0.49, 0.61 );
      ::colorFun.AddRGBPoint( ::bones2, 0.90, 0.82, 0.56, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( 3071, 1, 1, 1, 0.5, 0.0 );
      
      ::opacityFun.AddPoint(-3024, 0, 0.5, 0.0 );
      ::opacityFun.AddPoint(::bones1, 0   *::opacity_attenuation, 0.49, 0.61 );
      ::opacityFun.AddPoint(::bones2, 0.72*::opacity_attenuation, 0.5, 0.0 );
      ::opacityFun.AddPoint(3071, 0.71, 0.5, 0.0);

      ::property.ShadeOn();
      ::property.SetAmbient(0.1);
      ::property.SetDiffuse(0.9);
      ::property.SetSpecular(0.2);
      ::property.SetSpecularPower(10.0);
      ::property.SetScalarOpacityUnitDistance(0.8919);
    }


    #----------------------------
    proc ::MusclesReset() \
    {
      ::muscles1 = -155
      ::muscles2 =  217
      ::muscles3 =  420
      ::OnRender()
    }

    #----------------------------
    proc ::BlendCTMuscles() \
    {
      ::colorFun.AddRGBPoint( -3024, 0, 0, 0, 0.5, 0.0 )
      ::colorFun.AddRGBPoint( ::muscles1, 0.55, 0.25, 0.15, 0.5, 0.92 )
      ::colorFun.AddRGBPoint( ::muscles2, 0.88, 0.60, 0.29, 0.33, 0.45 )
      ::colorFun.AddRGBPoint( ::muscles3, 1, 0.94, 0.95, 0.5, 0.0 )
      ::colorFun.AddRGBPoint( 3071, 0.83, 0.66, 1, 0.5, 0.0 )
      
      ::opacityFun.AddPoint(-3024, 0, 0.5, 0.0 )
      ::opacityFun.AddPoint(::muscles1, 0   *::opacity_attenuation, 0.5, 0.92 )
      ::opacityFun.AddPoint(::muscles2, 0.68*::opacity_attenuation, 0.33, 0.45 )
      ::opacityFun.AddPoint(::muscles3, 0.83*::opacity_attenuation, 0.5, 0.0)
      ::opacityFun.AddPoint(3071, 0.80, 0.5, 0.0)

      ::property.ShadeOn()
      ::property.SetAmbient(0.1)
      ::property.SetDiffuse(0.9)
      ::property.SetSpecular(0.2)
      ::property.SetSpecularPower(10.0)
      ::property.SetScalarOpacityUnitDistance(0.8919)
    }

    #---------------------------
    proc ::OnCtrlPoint() \
    {
      ::imhisto1.dw._Paint()
      ::imhisto1.ColormapMinMax()
      ::imhisto1.UpdateCM()
      ::OnRender()
      #::Draw_opacityFun()
    }

    #----------------------------
    proc ::SaveCurve(  ) \
    {
      thefilename = wx.wxFileName(&::curve_folder, &::curve_filename)
      if(thefilename.FileExists()) {
        msg = "The %1% file exists." %thefilename.GetFullName().c_str()
      } else {
        if (!exists(::linearcurve1)) {
          msg = "It is not possible to save the curve because it has not been defined."
        } else {
          ::CurveIO.SaveCurve( thefilename.GetFullName().c_str(), &::linearcurve1 )
          msg = "The curve has been saved correctly in the file: %1%" % thefilename.GetFullName().c_str()
        }
      }
      InfoDialog msg
    }

    #----------------------------
    proc ::LoadCurve(  ) \
    {
      thefilename = wx.wxFileName(&::curve_folder, &::curve_filename)
      if(thefilename.FileExists()) {
        ::linearcurve1 = ::CurveIO.LoadCurve( thefilename.GetFullName().c_str() )
        msg = "The curve has been loaded correctly from the file: %1%" %thefilename.GetFullName().c_str()
      } else {
        msg = "The %1% file does not exist." %thefilename.GetFullName().c_str()       
      }
      InfoDialog msg
    }

    #----------------------------
    proc ::ResetLinearCurve1() \
    {
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      if (exists(::imhisto1->h)) {
        hmax = max(::imhisto1.h[0])

        # http://www.wikiradiography.com/page/Hounsfield++unit
        #It is the definition for CT scanners that are calibrated with reference to water.
        #Tissue CT number (HU)
        #Bone  1000
        #Liver   40 - 60
        #White matter  ~20-30 HU
        #Grey matter   ~37-45 HU
        #Blood   40
        #Muscle  10 - 40
        #Kidney  30
        #Cerebrospinal fluid   15
        #Water   0
        #Fat   -50 - -100
        #Air   -1000

        # default intensity values
        px1 = 1080
        px3 = 1130
        px4 = 1390
        px2 = 1100
        o1 = 0
        o2 = 0.005
        o3 = 0.08
        o4 = 0.5
        imin = ::imhisto1.minval
        imax = ::imhisto1.maxval
        if  (imin>px1)||(imax<px1)||(imin>px2)||(imax<px2) \
        { 
          # set position within intensity range
          px1 = imin+(imax-imin)*0.4
          px2 = imin+(imax-imin)*0.5
          px3 = imin+(imax-imin)*0.6
          px4 = imin+(imax-imin)*0.9
          o1 = 0
          o2 = 0.3
          o3 = 0.4
          o4 = 0.9
        }

        # Create the curve
        curve = ami.dwControlledCurve()

        # black point
        cp0 = ami.dwControlPoint(px1,o1*hmax)
        cp0.SetYLocked(1)
        cp0.SetColour(wx.wxColour(0,0,0))
        curve.GetControlPoints().push_back(&cp0)

        # red point
        cp1 = ami.dwControlPoint(px2,o2*hmax)
        cp1.SetColour(wx.wxColour(255,0,0))
        curve.GetControlPoints().push_back(&cp1)

        # yellow point
        cp2 = ami.dwControlPoint(px3,o3*hmax)
        cp2.SetColour(wx.wxColour(255,255,0))
        curve.GetControlPoints().push_back(&cp2)

        # white point
        cp3 = ami.dwControlPoint(px4,o4*hmax)
        cp3.SetColour(wx.wxColour(255,255,255))
        curve.GetControlPoints().push_back(&cp3)

        curve.SetType(1) # solid
        ::SetLinearCurve(&curve)
        ::imhisto1.dw.SetCtrlPointCallback(&::OnCtrlPoint)
        ::use_shade=1
      } else {
        InfoDialog "No histogram available."
      }
        
    }

    #----------------------------
    proc ::SetShadingProperties() \
    {
      ::property.SetShade(::use_shade)
      ::property.SetAmbient(::ambient)
      ::property.SetDiffuse(::diffuse)
      ::property.SetSpecular(::specular)
      ::property.SetSpecularPower(::specular_power)
      ::property.SetScalarOpacityUnitDistance(::scalar_opacity_unitdistance)
    }

    #----------------------------
    proc ::BlendLinearCurve1() \
    {
      printn "BlendLinearCurve1"
      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      if (exists(::imhisto1->h)) {
        curves = ::imhisto1.dw.GetControlledCurves()
        numcurves = curves.size()
        if (!exists(::linearcurve1_id)) {
          printn "--"
          ::linearcurve1_id   = numcurves
          ::ResetLinearCurve1()
        }

        # Create colors based on the curve
        hmax = max(::imhisto1.h[0])
        ctrlpoints = curves[::linearcurve1_id].GetControlPoints()
        for n=0 to ctrlpoints.size()-1 {
          printn "point number %1%" %n
          cp = ctrlpoints[n].copy()
          col = cp.GetColour()
          ::colorFun.AddRGBPoint( cp.GetX(), \
                                  1.0/255*col.Red(), \
                                  1.0/255*col.Green(),\
                                  1.0/255*col.Blue(),\
                                  cp.Getmidpoint(),\
                                  cp.Getsharpness());
          y =  ::opacity_attenuation/hmax*cp.GetY()
          y = -max(-y,-1)
          ::opacityFun.AddPoint(  cp.GetX(), y , \
                                  cp.Getmidpoint(), cp.Getsharpness())
          #x = cp.GetX()
          #printn " (%1%, " % x + " %1%)" % y
        }

        ::SetShadingProperties()
      } else {
        InfoDialog "No histogram available."
      }
    }

    #----------------------------
    proc ::PreviewApplied() \
    {
      ::selected_curv = &::previewer.GetSelection()
      ::previewer.Close()
      # now create the curve based on the vtkCurveClass object

      if (!exists(::imhisto1->h)) {
        ::UpdateHistogram()
      }
      hmax = max(::imhisto1.h[0])

      curve = ami.dwControlledCurve()

      n1 = ::selected_curv.colorFun.GetSize()
      n2 = ::selected_curv.opacityFun.GetSize()
      if n1!=n2 {
        printn "pb ..."
      }
      for n=0 to n1-1 {
        # add point
        vals  = vector_double(6)
        vals_op = vector_double(4)
        ::selected_curv.colorFun  .GetNodeValue(n,&vals [0])
        ::selected_curv.opacityFun.GetNodeValue(n,&vals_op[0])
        del cp
        # TODO: check compatibility between color and opacity functions ...
        cp = ami.dwControlPoint(vals[0],vals_op[1]*hmax)
printn "vals[0] %1%" % vals[0]
printn "vals[1] %1%" % vals[1]
printn "vals[2] %1%" % vals[2]
printn "vals[3] %1%" % vals[3]
        cp.SetColour(wx.wxColour(vals[1]*255,vals[2]*255,vals[3]*255))
        cp.Setmidpoint(vals[4])
        cp.Setsharpness(vals[5])
        curve.GetControlPoints().push_back(&cp)
      }
      curve.SetType(1) # solid
      ::SetLinearCurve(&curve)
      ::ambient  = ::selected_curv.property.GetAmbient()
      ::diffuse  = ::selected_curv.property.GetDiffuse()
      ::specular = ::selected_curv.property.GetSpecular()
      ::specular_power =  ::selected_curv.property.GetSpecularPower()
      ::scalar_opacity_unitdistance =  ::selected_curv.property.GetScalarOpacityUnitDistance()

      ::blend_mode = 0 # Composite
      #::OnRender()
      #::Draw_Functions()
      ::win.Update(-1)
    }

    #----------------------------
    proc ::StartPreview() \
    {

      printn "::StartPreview()"
      if (exists(::input)) {
        del ::previewer
        ::previewerclass ::previewer
        ::previewer.SetInput(&::input)
        ::previewer.SetApplyCallback(&::PreviewApplied)
      }
    }

    #----------------------------
    proc ::ReCompute() \
    {
        del ::colorFun
        del ::opacityFun
        del ::property

        ::colorFun=vtk.vtkColorTransferFunction.New()
        ::opacityFun=vtk.vtkPiecewiseFunction.New()

        # Create the property and attach the transfer functions
        ::property = vtk.vtkVolumeProperty.New()
        ::property.SetIndependentComponents(1)
        ::property.SetColor( &::colorFun )
        ::property.SetScalarOpacity( &::opacityFun )
        ::property.SetInterpolationTypeToLinear()
 
        # connect up the volume to the property and the mapper
        ::vol.SetProperty( &::property )

        if (::blend_type==4) { ::BlendCTBones();            }
        if (::blend_type==5) { ::BlendCTMuscles();          }
        if (::blend_type==7)||((::blend_type>=0)&&(::blend_type<=3)) { 
          ::BlendLinearCurve1()
        }
        ::volmapper.SetBlendMode(::blend_mode)

        #::property.SetColor( &::colorFun )
        #::property.SetScalarOpacity( &::opacityFun )
      
    }

    #----------------------------
    proc ::Draw_colorFun() \
    {
      ctf = &::colorFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        h1 = Resize(h,256,1,1,1)
        ::ctf_color <<= (RGB) h1
        spos = SpacePos(::ctf_color)
        pos = spos[0]
        #print "\n"
        for x=0 to ::ctf_color.tx-1 {
          ::ctf_color.setpos(x,0,0)
          xpos = pos(x)
          ::ctf_color.set(ctf.GetRedValue(  xpos)*250, \
                          ctf.GetGreenValue(xpos)*250, \
                          ctf.GetBlueValue( xpos)*250 )
        }
        # position curves in ColorMap window of ::imhisto1
        if(exists( ::imhisto1->cm)){
          curves = ::imhisto1.cm.GetCurves()
          numcurves = curves.size()
          
          if (!exists(::red_id)) {
            ::red_id   = numcurves
            ::green_id = numcurves+1
            ::blue_id  = numcurves+2
          }

          ::imhisto1.cm.SetCurve(::ctf_color[0],::red_id)
          ::imhisto1.cm.SetCurve(::ctf_color[1],::green_id)
          ::imhisto1.cm.SetCurve(::ctf_color[2],::blue_id)

          ::imhisto1.cm.SetCurveProperties(::red_id,  "#FF0000")
          ::imhisto1.cm.SetCurveProperties(::green_id,"#00FF00")
          ::imhisto1.cm.SetCurveProperties(::blue_id, "#0000FF")
        }
        
      }
    }

    #----------------------------
    proc ::Draw_greycolorFun() \
    {
      ctf = &::colorFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        ::ctf_color <<= Resize(h,256,1,1,1)
        spos = SpacePos(::ctf_color)
        pos = spos[0]
        #print "\n"
        for x=0 to ::ctf_color.tx-1 {
          ::ctf_color.setpos(x,0,0)
          ::ctf_color.set(ctf.GetRedValue(pos(x)))
        }
        ::ctf_color = ::ctf_color*250
        # position curves in ColorMap window of ::imhisto1
        if(exists( ::imhisto1->cm)){
          numcurves = ::imhisto1.cm.GetCurves().size()
          printn numcurves
          if (!exists(::red_id)) {
            ::red_id   = numcurves
            ::green_id = numcurves+1
            ::blue_id  = numcurves+2
          }
        
          ::imhisto1.cm.SetCurve(&::ctf_color,::red_id)
          ::imhisto1.cm.SetCurve(&::ctf_color,::green_id)
          ::imhisto1.cm.SetCurve(&::ctf_color,::blue_id)

          ::imhisto1.cm.SetCurveProperties(::red_id,  "#606060")
          ::imhisto1.cm.SetCurveProperties(::green_id,"#606060")
          ::imhisto1.cm.SetCurveProperties(::blue_id, "#606060")
    
        }
      }
    }

    #----------------------------
    proc ::Draw_opacityFun() \
    {
      otf = &::opacityFun
      if (exists(::imhisto1->h)) {
        h = (FLOAT)::imhisto1.h[0]
        ::otf_im <<= Resize(h,256,1,1,1)
        spos = SpacePos(::otf_im)
        pos = spos[0]
        #print "\n"
        for x=0 to ::otf_im.tx-1 {
          ::otf_im.setpos(x,0,0)
          ::otf_im.set(otf.GetValue(pos(x)))
        }
        # position curves in ColorMap window of ::imhisto1
        if(exists( ::imhisto1->cm)){
          numcurves = ::imhisto1.cm.GetCurves().size()
          printn numcurves
          if (!exists(::otf_id)) {
            ::otf_id   = numcurves
          }
          ::otf_im = ::otf_im*250
          ::imhisto1.cm.SetCurve(::otf_im,::otf_id)
          ::imhisto1.cm.SetCurveProperties(::otf_id,  "#202020")
        }
      }
    }

    #----------------------------
    proc ::Draw_Functions() {
      if (::blend_type<=2) {
        ::Draw_greycolorFun()
      } else {
        ::Draw_colorFun()
      }
      ::Draw_opacityFun()
      if(exists( ::imhisto1->cm)){
        ::imhisto1.cm._Paint()
      }
    }

    #----------------------------
    proc ::OnRender() \
    {
      if (exists(::renwininter)&&(::initialized>0.5)) {
        ::ReCompute()
        if (exists(::renwininter)) {
          ::renwininter.Render()
        }
      }
    }

    #----------------------------
    proc ::OnBlendType() \
    {
      ::win.EnablePanel(::ramp_page ,    (::blend_type<=2))
      ::win.EnablePanel(::skin_page ,    ::blend_type==3)
      ::win.EnablePanel(::bones_page ,   ::blend_type==4)
      ::win.EnablePanel(::muscles_page , ::blend_type==5)

      if (::blend_type<=2) {
        ::win.SelectPage(::blend_book,0)
      } else {
        ::win.SelectPage(::blend_book,::blend_type-2)
      }

      if (::blend_type==0) { 
        ::blend_mode = 1 # Maximum Intensity
        ::ResetMIPCurve()
      } else {
        if (::blend_type==1) {
          ::ResetCompositeRamp()
        }
        if (::blend_type==2) {
          ::ResetCompositeShadeRamp()
        }
        if (::blend_type==3) {
          ::ResetCTSkin()
        }
        if (::blend_type==7) {
          ::ResetLinearCurve1()
        }
        ::blend_mode = 0 # Composite
      }

      ::OnRender()
      ::Draw_Functions()
      ::win.Update(-1)
    }

    #----------------------------
    proc ::OnWindow() \
    {
      ::OnRender()
      ::Draw_Functions()
    }

    #----------------------------
    proc ::OnLevel() \
    {
      ::OnRender()
      ::Draw_Functions()
    }

    #----------------------------
    proc ::UpdateHistogram() \
    {
      if (exists(::imhisto1))&&(exists(::input)) {
        #printn "*"
        if (exists(::min_val)) {
          ::imhisto1.SetInput2(&::input,::min_val,::max_val)
        } else {
          ::imhisto1.SetInput(&::input)
        }
      }
    }
    Comments(::UpdateHistogram,"Updates the histogram with the current input image.")

    #----------------------------
    proc ::OnClip() \
    {
      if (exists(::box)) {
        ::box.SetEnabled(::clip)
        ::box.SetRotationEnabled(::clip_enable_rotation)
      } else {
        ::InitBoxWidget()
      }
    }

    #----------------------------
    proc ::ApplyClip() \
    {
      if (::clip) {
        # to do: vtkPlanes
        planes = vtk.vtkPlanes.New()
        ::box.GetPlanes(&planes)
        ::volmapper.SetClippingPlanes(&planes)
        #planes.Delete()
        ::renwininter.Render()
      }
    }

    #----------------------------
    proc ::OnTextureMemory() \
    {
      if (exists(::volmapper)) {
        if  (::volmapper.GetClassName()=="vtkOpenGLGPUVolumeRayCastMapper") || \
            (::volmapper.GetClassName()=="vtkGLGPUVolumeRayCastMapper") \
        {
          # update volmapper GPU settings
          ::volmapper.SetMaxMemoryInBytes(::maxmemory*1024*1024)
          ::volmapper.SetMaxMemoryFraction(::maxmemoryfraction)

          # update GPU information
          ::maxmemory = ::volmapper.GetMaxMemoryInBytes()/(1024*1024)
          ::maxmemoryfraction = ::volmapper.GetMaxMemoryFraction()
          ::win.Update(-1)
        } else {
          InfoDialog "Wrong volume mapper ..."
        }
      }
    }

    #----------------------------
    proc ::OnSampleDistance() \
    {
      ::volmapper.SetAutoAdjustSampleDistances(::AutoAdjustSampleDistances)
      ::volmapper.SetSampleDistance(::SampleDistance)
      ::volmapper.SetImageSampleDistance(::ImageSampleDistance)
      ::renwininter.Render()
    }

    #----------------------------
    proc ::AddGui( OBJECT win ) \
    {
      printn "vtkVolumeClass::AddGui begin"
      ::win = &win

      ::win.BeginBook()

        ::win.AddPage("Blend")
        ::win.BeginHorizontal()
          ::icons.LoadIconPNG2("Chart xy","Chart_xy")
          ::AddBitmapButton16(&::win, &::icons._Chart_xy, "UpdateHistogram")
          ::win.AddButton("DrawTr",&::Draw_Functions)
          ::win.AddButton("Preview",&::StartPreview)
        ::win.EndHorizontal()


        ::blend_mode_id = ::win.AddEnum(&::blend_mode,"Mode")
          ::win.AddEnumChoice(::blend_mode_id,"Composite")
          ::win.AddEnumChoice(::blend_mode_id,"Max. Int.")
          ::win.AddEnumChoice(::blend_mode_id,"Min. Int.")


        ::blend_type_id = ::win.AddEnum(&::blend_type,"Type")
          ::win.AddEnumChoice(::blend_type_id,"MIP")
          ::win.AddEnumChoice(::blend_type_id,"Comp. Ramp")
          ::win.AddEnumChoice(::blend_type_id,"Comp. Shade Ramp")
          ::win.AddEnumChoice(::blend_type_id,"CT Skin")
          ::win.AddEnumChoice(::blend_type_id,"CT Bone")
          ::win.AddEnumChoice(::blend_type_id,"CT Muscles")
          ::win.AddEnumChoice(::blend_type_id,"RGB Composite")
          ::win.AddEnumChoice(::blend_type_id,"Linear Curve 1")
        ::win.SetCallback( &::OnBlendType)

        ##::win.BeginBook()
            ## Adding histogram page
          #::imhisto1.SetParentPanel(&::win)
          #::imhisto1.Gui()
          #::win.AddWidget(&::imhisto1->win,0)
          ##::win.AddPage("Hist", &::imhisto1->win)
        ##::win.EndBook()

        #::win.SetPositionProp(0)

        ::win.BeginBook()
            # Adding histogram page
          ::imhisto1.SetParentPanel(&::win)
::imhisto1.SetConf(2,0)
          ::imhisto1.Gui()
          ::win.AddPage("Hist", &::imhisto1->win)
          ::CurveLoad_page = ::win.AddPage("Load")
            ::win.BeginHorizontal()
              ::win.AddDirname(&::curve_folder, "Load Folder")
            ::win.EndHorizontal()

            ::win.BeginHorizontal()
              ::win.AddString( &::curve_filename,"Input File Name")
            ::win.EndHorizontal()

            ::win.BeginHorizontal()
              ::win.AddButton("Load",::LoadCurve)
            ::win.EndHorizontal()
          ::CurveSave_page = ::win.AddPage("Save")
            ::win.BeginHorizontal()
              ::win.AddDirname(&::curve_folder, "Save Folder")
            ::win.EndHorizontal()

            ::win.BeginHorizontal()
              ::win.AddString( &::curve_filename,"Output File Name")
            ::win.EndHorizontal()

            ::win.BeginHorizontal()
              ::win.AddButton("Save",::SaveCurve)
            ::win.EndHorizontal()
        ::win.EndBook()

        ::blend_book = ::win.BeginBook()
          ::ramp_page = ::win.AddPage("Ramp")
            ::opacitywindow_id = ::win.AddFloat(&::opacitywindow,"Window",0,5000)
            ::win.SetCallback( &::OnWindow)
            ::opacitylevel_id = ::win.AddFloat(&::opacitylevel,"Level",0,5000)
            ::win.SetCallback( &::OnLevel)
          ::skin_page = ::win.AddPage("Skin")
            ::win.AddFloat(&::skin1,"Ctrl_1",-3000,1000)
            ::win.SetCallback( &::OnBlendType)
            ::win.AddFloat(&::skin2,"Ctrl_2",-3000,1000)
            ::win.SetCallback( &::OnBlendType)
            ::AddBitmapButton16(&::win, &::icons._Refresh, "SkinReset")
          ::bones_page = ::win.AddPage("Bones")
            ::win.AddFloat(&::bones1,"Ctrl_1",-1000,2000)
            ::win.SetCallback( &::OnBlendType)
            ::win.AddFloat(&::bones2,"Ctrl_2",-1000,2000)
            ::win.SetCallback( &::OnBlendType)
            ::AddBitmapButton16(&::win, &::icons._Refresh, "BonesReset")
          ::muscles_page = ::win.AddPage("Muscles")
            ::win.AddFloat(&::muscles1,"Ctrl_1",-1000,1000)
            ::win.SetCallback( &::OnBlendType)
            ::win.AddFloat(&::muscles2,"Ctrl_2",-1000,1000)
            ::win.SetCallback( &::OnBlendType)
            ::win.AddFloat(&::muscles3,"Ctrl_3",-1000,1000)
            ::win.SetCallback( &::OnBlendType)
            ::AddBitmapButton16(&::win, &::icons._Refresh, "MusclesReset")
        ::win.EndBook()

        ::win.AddPage("Clip")
          ::win.AddBoolean(&::clip, "Clip")
          ::win.SetCallback( &::OnClip)
          ::win.AddBoolean(&::clip_enable_rotation,"Rotation")
          ::win.AddBoolean(&::clip_interactive,"Interactive")
          ::win.SetCallback( &::OnClip)
          ::win.AddButton( "Apply Clip",&::ApplyClip)

        ::win.AddPage("Shade")
          ::win.BeginBoxPanel("Global opacity")
            ::win.AddFloat(&::opacity_attenuation,"Opacity factor",0,1)
            ::win.SetCallback( &::OnWindow)
          ::win.EndBoxPanel()

          ::win.BeginBoxPanel("Shading properties")
            ::win.AddBoolean(&::use_shade,"Use Shade")
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::ambient,"Ambient",0,1)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::diffuse,"Diffuse",0,1)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::specular,"Specular",0,1)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::specular_power,"Spec_Power",0,50)
            ::win.SetCallback( &::OnRender)
            ::win.AddFloat(&::scalar_opacity_unitdistance,"Opa_dist",0.2,2)
            ::win.SetCallback( &::OnRender)
          ::win.EndBoxPanel()

        ::GPU_page = ::win.AddPage("GPU")
          ::volmapper_classname_id = ::win.AddLabel("VTK Class:","")
          ::win.BeginBoxPanel("3D texture memory")
            ::win.AddInt(&::maxmemory,"max",50,1000)
            ::win.SetCallback( &::OnTextureMemory)
            ::win.AddFloat(&::maxmemoryfraction,"fraction",0.05,1)
            ::win.SetCallback( &::OnTextureMemory)
          ::win.EndBoxPanel()

        ::GPU_page = ::win.AddPage("Rend")
          ::win.BeginBoxPanel("Sample distances")
            ::win.AddBoolean(&::AutoAdjustSampleDistances,"Auto")
            #::win.SetCallback( &::OnSampleDistance)
            ::win.AddFloat(&::SampleDistance,"Dist",0.2,2)
            #::win.SetCallback( &::OnSampleDistance)
            ::win.AddFloat(&::ImageSampleDistance,"Im Dist",0.2,2)
            ::win.AddButton("Apply",&::OnSampleDistance)
          ::win.EndBoxPanel()
          
      ::win.EndBook()

      printn "vtkVolumeClass::AddGui end"
    }
  } # end Class

}
# end if
