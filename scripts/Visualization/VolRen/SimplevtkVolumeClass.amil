
del SimplevtkVolumeClass

if (!exists(SimplevtkVolumeClass)) {
  #-----------------------------------------------------
  #  SimplevtkVolumeClass
  #-----------------------------------------------------
  Class SimplevtkVolumeClass {

    proc ::GetIndent(NUM n) {
      res = ""
      for k=1 to n {
        res += "  "
      }
      return=res
    }
    ::trace2=true, "gives tracing information"
    member = "\"SimplevtkVolumeClass::\"+" 
    #"language.Vars.GetObjectContext().GetName()::"
    member += "language.Vars.GetCurrentContext().GetName()"
    ::trace2_begin="printn \"**\"+"+ \
                  "::GetIndent(language.Vars.GetCurrentContextNumber())+"+\
                  "\" Begin \"+%1%;" % member
    ::trace2_end  ="printn \"**\"+"+\
                  "::GetIndent(language.Vars.GetCurrentContextNumber())+"+\
                  "\" End   \"+%1%;" % member

    #----------------------------
    proc ::Init( ) \
    {
      ::InitInherit( ) 
    }

    #----------------------------
    proc ::InitInherit( ) \
    {
      ::clip = UCHAR(0), "Enable/Disable clipping box"
      ::clip_enable_rotation = UCHAR(0), "Enable clip rotation"
      ::clip_interactive = UCHAR(1), "Interactive clipping"
      ::initialized=0

      #::opacity_attenuation = 1, "Attenuation factor for the opacity"

      ::maxmemory = INT(512), "Max. 3D texture GPU memory in Mb (2^8 bytes)"
      ::maxmemoryfraction = 1, "Maximal fraction of 3D max. 3D texture memory to use."

      ::SampleDistance = 1, "distance between samples used for rendering"
      ::ImageSampleDistance = 1, "Sampling distance in the XY image dimensions. Default value of 1 meaning 1 ray cast per pixel. If set to 0.5, 4 rays will be cast per pixel. If set to 2.0, 1 ray will be cast for every 4 (2 by 2) pixels. This value will be adjusted to meet a desired frame rate when AutoAdjustSampleDistances is on. "
      ::AutoAdjustSampleDistances = UCHAR(1), "Auto-adjust sample distances"

      ::use_shade = UCHAR(1), "use shading"
      ::ambient   = 0.15, "ambient coefficient"
      ::diffuse   = 0.9, "diffuse coefficient"
      ::specular  = 0.3, "specular coefficient"
      ::specular_power = 15.0, "specular power"
      ::scalar_opacity_unitdistance = 0.8919, "scalar opacity unit distance"

      ::blend_mode = INT(0), "0: Composite, 1: Maximum Intensity, 2:Minimum Intensity, 3:Additive_blend"
      ::volrenmapper_type = INT(0), "Volume Rendering Mapper type 0: GPU, 1: Fixed Point 2: Standard, 3: AMILab Multi-VolRen"

      ::move_2 = UCHAR(1)
    }

    #----------------------------
    proc ::SetText( STRING text ) {

      if (exists (::singleLineTextActorT)){
        ::renderer.RemoveVolume(&::singleLineTextActorT)
      }
      del ::singleLineTextActorT
      del singleLineTextProp
      del ::singleLineTextT

      singleLineTextProp = vtk.vtkTextProperty.New()
      singleLineTextProp.SetFontSize(14)
      singleLineTextProp.SetFontFamilyToArial()
      singleLineTextProp.BoldOff()
      singleLineTextProp.ItalicOff()
      singleLineTextProp.ShadowOff()
      ::singleLineTextT = vtk.vtkTextMapper.New()
      ::singleLineTextT.SetInput(text)
      tprop = ::singleLineTextT.GetTextProperty()
      tprop.ShallowCopy(&singleLineTextProp)
      tprop.SetVerticalJustificationToTop()
      tprop.SetColor(1, 0, 0)
      ::singleLineTextActorT = vtk.vtkActor2D.New()
      ::singleLineTextActorT.SetMapper(&::singleLineTextT)
      ::singleLineTextActorT.GetPositionCoordinate().SetCoordinateSystemToNormalizedDisplay()
      ::singleLineTextActorT.GetPositionCoordinate().SetValue(0.05, 0.65)
      ::renderer.AddActor2D(&::singleLineTextActorT)
      ::renwininter.Render()
    }
    #----------------------------
    proc ::SetBlendMode(NUM  m) {
      ::blend_mode  = m
    }
    #----------------------------
    proc ::SetInteractor( OBJECT inter ) {
      del ::renwininter
      ::renwininter = &inter
    }
    #----------------------------
    proc ::cpManager(OBJECT volume ) {
      #::renwininter = &volume.renwininter
      #::renderer = &volume.renderer
      #::camera=&volume.camera 
      #::renwininter.GetRenderWindow().AddRenderer(&::renderer)
      #::renwin   = &volume.renwin
        ::SetInteractor(&volume.renwininter)
        ::SetRenderer(&volume.renderer)
        ::SetRenderWindow(&volume.renwin)
    }
    #----------------------------
     proc ::InitCamera() {
      ::camera=::renderer.GetActiveCamera()
      ::camera.SetViewUp(0,0,1) # change orientation
      #::camera.SetParallelProjection(true)
      #::camera.SetPosition(0,-100,0)
    }
    #----------------------------
    #Initialize Iterator,Renderer, RendererWindow and variables
    proc ::InitManager( OBJECT inter ) {
      if ::trace2 { eval ::trace2_begin; }
      #reset
      ::ResetVTK()
      #Init
      ::renwininter = &inter
      ::renderer = vtk.vtkRenderer.New()
      ::renderer.ResetCamera()   # carlos
      ::InitCamera()

      ::renwininter.GetRenderWindow().AddRenderer(&::renderer)
      del interact
      interact = vtk.vtkInteractorStyleTrackballCamera.New()
      ::renwininter.SetInteractorStyle(&interact)
      #This is the actor with the planes
      ::renwin   = ::renwininter.GetRenderWindow()

      ::renwininter.SetRenderWindow(&::renwin)
      ::initialized = 1
      if ::trace2 { eval ::trace2_end; }
    }

    #----------------------------
    proc ::AddAnnotatedCube(){
      if ::trace2 { eval ::trace2_begin; }
      if (exists(::renwininter)){
        axesActor = vtk.vtkAnnotatedCubeActor.New()
        axesActor.SetXPlusFaceText( "L")
        axesActor.SetXMinusFaceText("R")
        axesActor.SetYMinusFaceText("A")
        axesActor.SetYPlusFaceText( "P")
        axesActor.SetZMinusFaceText("I")
        axesActor.SetZPlusFaceText( "S")
        axesActor.GetTextEdgesProperty().SetColor(1,1,0)
        axesActor.GetTextEdgesProperty().SetLineWidth(2)
        axesActor.GetCubeProperty().SetColor(0,0,1)
        ::axes = vtk.vtkOrientationMarkerWidget.New()
        ::axes.SetOrientationMarker(&axesActor)
        ::axes.SetInteractor(&::renwininter)
        ::axes.EnabledOn()
        //if (::interacCube ==1){
        //   ::axes.InteractiveOn()
        //}else{
          ::axes.InteractiveOff()
        //}
      }
      if ::trace2 { eval ::trace2_end; }
    }

    #----------------------------
    #Init renderer
    proc ::InitRenderer(){
      if ::trace2 { eval ::trace2_begin; }
      ::renderer.ResetCameraClippingRange()
      #default ::renderer.SetBackground(0, 0, 0)
      ::renderer.ResetCamera()
      if ::trace2 { eval ::trace2_end; }
    } 

    #----------------------------
    #Reset camera
    proc ::ResetCamera(){
      ::renderer.ResetCamera()
    } 
    #----------------------------
    proc ::SetBackground(NUM r,NUM g, NUM b,NUM r2,NUM g2, NUM b2,NUM gradiant){
      if (exists(::renderer)) {
        ::renderer.SetBackground((FLOAT)r/255, (FLOAT)g/255, (FLOAT)b/255)
        ::renderer.SetBackground2((FLOAT)r2/255, (FLOAT)g2/255, (FLOAT)b2/255)
        ::renderer.SetGradientBackground( gradiant)
        ::renwininter.Render()

      }
    } 
    #----------------------------
    proc ::SetRenderer( OBJECT ren ) {
      del ::renderer
      ::renderer = &ren
      ::renderer.ResetCamera()   // carlos
      ::camera=::renderer.GetActiveCamera()
    }

    #----------------------------
    proc ::SetRenderWindow( OBJECT renwin ) {
      del ::renwin
      ::renwin = &renwin
    }
    #----------------------------
    proc ::Rotate( ) {
      ::camera.Azimuth( 10 )
      ::OnRender()
    }
  #----------------------------
  proc ::Rotate2(NUM n){
   for i=0 to n {
      wait(33)
      ::Rotate()
    }
  }
    #----------------------------
    proc ::Azimuth( NUM x) {
      ::camera.Azimuth( x )
    }
    #----------------------------
    proc ::Elevation( NUM x) {
      ::camera.Elevation( x )
    }
    #----------------------------
    proc ::Zoom( NUM x){
      ::camera.Zoom( x )
    }
    #----------------------------
    proc ::SetColorFun(OBJECT  f) {
      if ::trace2 { eval ::trace2_begin; }
      del ::colorFun
      ::colorFun  = &f
      if ::trace2 { eval ::trace2_end; }
    }
    #----------------------------
    proc ::SetOpacityFun(OBJECT  f) {
      if ::trace2 { eval ::trace2_begin; }
      del ::opacityFun
      ::opacityFun  = &f
      if ::trace2 { eval ::trace2_end; }
    }
    #----------------------------
    proc ::SetProperty(OBJECT  f) {
      if ::trace2 { eval ::trace2_begin; }
       del ::property
       # Create the property and attach the transfer functions
      ::property=&f
      ::property.SetIndependentComponents(1)
      ::property.SetColor( &::colorFun )
      ::property.SetScalarOpacity( &::opacityFun )
      ::property.SetInterpolationTypeToLinear()
      if ::trace2 { eval ::trace2_end; }
    }
    #----------------------------
    proc ::SetColorFun2(OBJECT  f) {
      if ::trace2 { eval ::trace2_begin; }
      del ::colorFun2
      ::colorFun2  = &f
      if ::trace2 { eval ::trace2_end; }
    }
    #----------------------------
    proc ::SetOpacityFun2(OBJECT  f) {
      if ::trace2 { eval ::trace2_begin; }
      del ::opacityFun2
      ::opacityFun2  = &f
      if ::trace2 { eval ::trace2_end; }
    }
    #----------------------------
    proc ::SetProperty2(OBJECT  f) {
      if ::trace2 { eval ::trace2_begin; }
       del ::property2
       # Create the property and attach the transfer functions
      ::property2=&f
      ::property2.SetIndependentComponents(1)
      ::property2.SetColor( &::colorFun2 )
      ::property2.SetScalarOpacity( &::opacityFun2 )
      ::property2.SetInterpolationTypeToLinear()
      if ::trace2 { eval ::trace2_end; }
    }

    #----------------------------
    proc ::SetVolRenMapper( NUM type ) {
      if ::trace2 { eval ::trace2_begin; }
      ::volrenmapper_type = type
      if ::trace2 { eval ::trace2_end; }
    }
    #----------------------------
    proc ::SetVolMapperMode () {
        del ::volmapper
        #printn "VolMapper Mode = %1%" %::volrenmapper_type

        if (::volrenmapper_type==0)||(::volrenmapper_type==3) {
          if  (::volrenmapper_type==3) && \
              (exists(vtkAmiVolRen)) {
            ::volmapper = vtkAmiVolRen.vtkAMILabOpenGLGPUMultiVolumeRayCastMapper.New()
          } else {
            SetStatusText("Setting vtkGPUVolumeMapper")
            ::volrenmapper_type=0
            ::volmapper = vtk.vtkGPUVolumeRayCastMapper.New()
          }
          # Check if the rendering is supported
          supported = ::volmapper.IsRenderSupported( &::renwin, &::property)
          #supported = 0
          if (!supported) {
            mess= "vtkGPUVolumeRayCastMapper rendering is not supported, trying vtkVolumeRayCastMapper ..."
            printn mess
            #InfoDialog mess
            del ::volmapper
            ::volrenmapper_type=2
          } 
        } 
        if ::volrenmapper_type==1 {
          ::volmapper = vtk.vtkFixedPointVolumeRayCastMapper.New()
        }
        if ::volrenmapper_type==2 {
          aux=(USHORT)::input
          del ::input
          ::input<<=aux
          ::volmapper = vtk.vtkVolumeRayCastMapper.New()
          compositeFunction=vtk.vtkVolumeRayCastCompositeFunction.New()
          ::volmapper.SetVolumeRayCastFunction(&compositeFunction)
        } 
    }
    #----------------------------
    # Inputs:
    #   input_image : input InrImage volume
    #
    # Outputs:
    #   vol        : vtkVolume
    #   volmapper  : vtkGPUVolumeRayCastMapper
    #   colorFun   : vtkColorTransferFunction
    #   opacityFun : vtkPiecewiseFunction
    #   property   : vtkVolumeProperty
    #
    #proc ::CreateVTK( IMAGE input_image) {
        #printn "CreateVTK 1"
      #del ::input
      #::input = &input_image
    proc ::CreateVTK( ) \
    {
      if ::trace2 { eval ::trace2_begin; }
      if exists(::input) {
        if (::volrenmapper_type==3)&&(!exists(::input2)) {
            SetStatusText(  "Missing second input for Multiple VolRen"+\
                            ", switching to vtkGPUVolumeMapper")
            ::volrenmapper_type=0
        }
        #::DefaultProperties() #define init properties 

        # check that we have a volume
        if (::input.tx<2)||(::input.ty<2)||(::input.tz<2) {
          InfoDialog "Input image is not a volume!"
          return = false
        } else {

          ::property.SetInterpolationTypeToLinear()
          ::property2.SetInterpolationTypeToLinear()

          ::vol       = vtk.vtkVolume.New()
          # don"t put the boxwidget for the moment
          # convert input to vtkimage
          ::SetVolMapperMode ()

          # Set first input
          ::vtkinput  = vtktools.ToVtkImageData(&::input)
          if (exists(::mask)){
            ::volmapper.SetMaskInput(&::mask)
          }
          ::volmapper.SetInput(&::vtkinput)
          
          if (::volrenmapper_type==3) {
            ::vtkinput2 = vtktools.ToVtkImageData(&::input2)
            ::volmapper.SetInput2(&::vtkinput2)
          }
          
          ::volmapper.SetBlendMode(::blend_mode)
          # connect up the volume to the property and the mapper
          ::vol.SetProperty( &::property )
          ::vol.SetMapper( &::volmapper )
          if (::volrenmapper_type==3) {
            #propertier for the second volume 
            ::volmapper.SetProperty2( &::property2 )
          }
          ::initialized = 1

          #Add volume to renderer
          if (exists(::renderer)){
            ::renderer.AddVolume(&::vol)
          }
          return = true
        }
      }
      if ::trace2 { eval ::trace2_end; }
    }

    ##---------------------------------------------------------------------------
    #proc ::CreateVTK1( ) \
    #{
      #if ::trace2 { eval ::trace2_begin; }
      ## check that we have a volume
      #if (::input.tx<2)||(::input.ty<2)||(::input.tz<2) {
        #InfoDialog "Input image is not a volume!"
        #return = false
      #} else {

        #::property.SetInterpolationTypeToLinear()
 
        ##printn "CreateVTK 2"

        #::vol       = vtk.vtkVolume.New()
        ## don"t put the boxwidget for the moment
        ## convert input to vtkimage
        #::SetVolMapperMode ()
        #::vtkinput  = vtktools.ToVtkImageData(&::input)
        #if (exists(::mask)){
          #::volmapper.SetMaskInput(&::mask)
        #}
        #::volmapper.SetInput(&::vtkinput)
        
        
        #::volmapper.SetBlendMode(::blend_mode)
        ## connect up the volume to the property and the mapper
        #::vol.SetProperty( &::property )
        #::vol.SetMapper( &::volmapper )
        #::initialized = 1


        ##Add volume to renderer
        #if (exists(::renderer)){
          #::renderer.AddVolume(&::vol)
        #}
        #return = true
      #}
      #if ::trace2 { eval ::trace2_end; }
    #}



    ##---------------------------------------------------------------------------
    #proc ::CreateVTK2( ) \
    #{
      #if ::trace2 { eval ::trace2_begin; }
      ## check that we have a volume
      #if (::input.tx<2)||(::input.ty<2)||(::input.tz<2 ||\
          #::input2.tx<2)||(::input2.ty<2)||(::input2.tz<2) {
        #InfoDialog "Input image is not a volume!"
        #return = false
      #} else {

        ##funcion a tener en cuenta
        ##volumeGradientOpacity = vtk.vtkPiecewiseFunction.New()
        ##volumeGradientOpacity.AddPoint(0,   0.0)
        ##volumeGradientOpacity.AddPoint(90,  0.5)
        ##volumeGradientOpacity.AddPoint(100, 1.0)
        ##::property.SetGradientOpacity(&volumeGradientOpacity)

        ##::property.SetInterpolationTypeToLinear()
        ##::property2.SetInterpolationTypeToLinear()
        
        ##printn "CreateVTK 2"

        #::vol = vtk.vtkVolume.New()
        ## don"t put the boxwidget for the moment
        ## convert input to vtkimage
        #::SetVolMapperMode ()
        #if (::volrenmapper_type!=3){
          #printn "ERROR volrenmapper_type not accepted"
          #return = false
        #}else{
          #::vtkinput  = vtktools.ToVtkImageData(&::input)
          #::volmapper.SetInput(&::vtkinput)

          #::vtkinput2 = vtktools.ToVtkImageData(&::input2)
          #::volmapper.SetInput2(&::vtkinput2)        
          
          #::volmapper.SetBlendMode(::blend_mode)
          ## connect up the volume to the property and the mapper
          #::vol.SetProperty( &::property )
          ##propertier for the second volume 
          #::volmapper.SetProperty2( &::property2 )
          #::vol.SetMapper( &::volmapper )
          #::initialized = 1

          ##Add volume to renderer
          #if (exists(::renderer)){
            #::renderer.AddVolume(&::vol)
          #}
          #return = true
        #}
      #}
      #if ::trace2 { eval ::trace2_end; }
    #}

   #----------------------------
   proc ::DefaultProperties( ){
      if ::trace2 { eval ::trace2_begin; }
      del ::colorFun
      del ::opacityFun
      del ::property
      del ::colorFun2
      del ::opacityFun2
      del ::property2
    # Create our transfer function
      ::colorFun=vtk.vtkColorTransferFunction.New()
      ::opacityFun=vtk.vtkPiecewiseFunction.New()
      # Create the property and attach the transfer functions
      ::property = vtk.vtkVolumeProperty.New()
      ::property.SetIndependentComponents(1)
      ::property.SetColor( &::colorFun )
      ::property.SetScalarOpacity( &::opacityFun )
      # Create our transfer function
      ::colorFun2=vtk.vtkColorTransferFunction.New()
      ::opacityFun2=vtk.vtkPiecewiseFunction.New()
      # Create the property and attach the transfer functions
      ::property2 = vtk.vtkVolumeProperty.New()
      ::property2.SetIndependentComponents(1)
      ::property2.SetColor( &::colorFun2 )
      ::property2.SetScalarOpacity( &::opacityFun2 )
      if ::trace2 { eval ::trace2_end; }
   }
   #----------------------------
   proc ::DelVTK( ) {
      if ::trace2 { eval ::trace2_begin; }
      if (exists (::vol)){
        ::renderer.RemoveVolume(&::vol)
      }
      del ::input
      del ::input2
      del ::colorFun
      del ::opacityFun
      del ::property 
      del ::colorFun2
      del ::opacityFun2
      del ::property2 
      del ::vol       
      del ::volmapper
      del ::vtkinput
      del ::box
     ::renwininter.Render()

     //::InitCamera()
      if ::trace2 { eval ::trace2_end; }
    }

   #----------------------------Obsolete method
   proc ::ChangeVol(IMAGE input_image){
    #printn "CreateVTK 2"
    del ::vol
    ::vol       = vtk.vtkVolume.New()
    # don"t put the boxwidget for the moment
    # convert input to vtkimage
    del ::vtkinput
    ::vtkinput  = vtktools.ToVtkImageData(&input_image)
    # connect up the volume to the property and the mapper
    ::vol.SetProperty( &::property )
    ::vol.SetMapper( &::volmapper )

    ::volmapper.SetInput(&::vtkinput)
    #Add volume to renderer
    if (exists(::renderer)){
      ::renderer.AddVolume(&::vol)
    }
   }

    #----------------------------
    proc ::InitBoxWidget() \
    {
      del ::box
      ::box = vtk.vtkBoxWidget.New()
      if (::clip) \
      {
        ::box.SetInteractor(&::renwininter)
        ::box.SetPlaceFactor(1.01)
        ::box.SetInput(&::vtkinput) 
        ::box.SetDefaultRenderer(&::renderer)
        ::box.InsideOutOn()
        ::box.PlaceWidget()
        ::box.SetRotationEnabled(::clip_enable_rotation)
        ::box.EnabledOn()
      }
    }

    #----------------------------
    proc ::ResetVTK() \
    {
      if ::trace2 { eval ::trace2_begin; }
      ::initialized = 0
      del ::renwininter # it is a reference, no call to Delete()
      del ::input
      del ::input2
      del ::vol
      del ::volmapper
      del ::colorFun
      del ::opacityFun
      del ::property
      del ::colorFun2
      del ::opacityFun2
      del ::property2
      if ::trace2 { eval ::trace2_end; }
    }

    #----------------------------
    proc ::ReCompute() \
    {
      if ::trace2 { eval ::trace2_begin; }
        # connect up the volume to the property and the mapper
        if (exists(::property)){
          ::vol.SetProperty( &::property )
        }
printn "::move_2 = %1%" % ::move_2
        if ::move_2 {
          if (exists(::property2) && ::volrenmapper_type==3){
            ::volmapper.SetProperty2( &::property2 )
            printn "::volmapper.SetProperty2( &::property2 )"
          }
        }
        if (exists(::volmapper)){
          ::volmapper.SetBlendMode(::blend_mode)
        }
      if ::trace2 { eval ::trace2_end; }
    }

    #----------------------------
    proc ::OnRender() \
    {
      if ::trace2 { eval ::trace2_begin; }
      if (exists(::renwininter)&&(::initialized>0.5)) { 
        ::ReCompute()
        if (exists(::renwininter)) {
          ::renwininter.Render()
        }
      }
      if ::trace2 { eval ::trace2_end; }
    }
    #----------------------------
    proc ::OnWindow() \
    {
      ::OnRender()
    }
    #----------------------------
    proc ::OnLevel() \
    {
      ::OnRender()
    }
    #----------------------------
    proc ::OnClip() \
    {
      if (exists(::box)) {
        ::box.SetEnabled(::clip)
        ::box.SetRotationEnabled(::clip_enable_rotation)
      } else {
        ::InitBoxWidget()
      }
    }

    #----------------------------
    proc ::ApplyClip() \
    {
      if (::clip) {
        # to do: vtkPlanes
        planes = vtk.vtkPlanes.New()
        ::box.GetPlanes(&planes)
        ::volmapper.SetClippingPlanes(&planes)
        ::renwininter.Render()
      }
    }

    #----------------------------
    proc ::OnTextureMemory() \
    {
      if (exists(::volmapper)) {
        if  (::volmapper.GetClassName()=="vtkOpenGLGPUVolumeRayCastMapper") || \
            (::volmapper.GetClassName()=="vtkGLGPUVolumeRayCastMapper") || \
            (::volmapper.GetClassName()=="vtkAMILabOpenGLGPUMultiVolumeRayCastMapper") \
        {
          printn "Texture =  %1%" %::volmapper.GetClassName()
          # update volmapper GPU settings
          ::volmapper.SetMaxMemoryInBytes(::maxmemory*1024*1024)
          ::volmapper.SetMaxMemoryFraction(::maxmemoryfraction)

          # update GPU information
          ::maxmemory = ::volmapper.GetMaxMemoryInBytes()/(1024*1024)
          ::maxmemoryfraction = ::volmapper.GetMaxMemoryFraction()

         } else {
          InfoDialog "Wrong volume mapper ..."
        }
      }
    }

    #----------------------------
    proc ::OnSampleDistance() \
    {
      ::volmapper.SetAutoAdjustSampleDistances(::AutoAdjustSampleDistances)
      ::volmapper.SetSampleDistance(::SampleDistance)
      ::volmapper.SetImageSampleDistance(::ImageSampleDistance)
      ::renwininter.Render()
    }

    #----------------------------
    proc ::SetMask( IMAGE input_image) \
    {
      del ::mask
      del aux
      aux= (UCHAR) input_image
      ::mask  = vtktools.ToVtkImageData(&aux)
    }
 

    #----------------------------
    proc ::SetInput( IMAGE input_image) \
    {
      del ::input
      ::input  = &input_image
    }

    #----------------------------
    proc ::SetInput2( IMAGE input_image) \
    {
      del ::input2
      ::input2  = &input_image
    }



  } # end Class
}# end if
