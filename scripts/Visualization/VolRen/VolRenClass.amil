#!/usr/bin/amilab

#
# Script for drawing 2D functions
# or lines from an image
#

comments="VolRen: VTK GPU RayCasting."

func "Common/ScriptGui"

import_vtk

if (!exists(VolRenClass)) {

  Class VolRenClass : public ScriptGui {

    #----------------------------
    proc ::Init() \
    {
      ::input_name =  "", "name of the input image"

      ::blend_type = INT(1), "Blend type: 0->MIP, 1->CompositeRamp, 2->CompositeShadeRamp, 3->CT_Skin, 4->CT_Bone, 5->CT_Muscles, 6->RGB_Composite"
      ::opacitywindow = 1000, "Opacity Window"
      ::opacitylevel  = 1000, "Opacity Level"
      ::clip = UCHAR(1), "Enable/Disable clipping box"
      ::initialized=0
      #::Gui()
    }
    
    #----------------------------
    proc ::load_input() {
      if (exists(::input)) { del ::input; }
      eval "::input = &"+::input_name+";"
      if (::input_name=="Image") {
        ::input_name = "::input"
        ::win.Update(-1)
      }
    }
  
    #----------------------------
    proc ::UpdateIntensityLimits() {
      if (exists(::input)) {
        ::min_val = min(::input)
        ::max_val = max(::input)
        ::win.FloatConstraints(::opacitylevel_id,::min_val,::max_val,::opacitylevel)
        ::win.FloatConstraints(::opacitywindow_id,::min_val,::max_val,::opacitywindow)
        ::win.Update(-1)
      }
    }

    #----------------------------
    proc ::ImReload() \
    {
      ::load_input()
    }

    #----------------------------
    proc ::DeleteVariables() {
      del ::renwin_interact
      del ::renwin
      del ::renderer
      # etc ...
    }

    #----------------------------
    proc ::Start() \
    {
      if (!exists(::input)) {
        ::load_input()
      }
      ::renwin_interact = global::vtkGPURayCasting(&::input, \
        ::blend_type, ::opacitywindow, ::opacitylevel, ::clip)
      ::renwin   = ::renwin_interact.GetRenderWindow()
      ::renderer = ::renwin.GetRenderers().GetFirstRenderer()
      interact = global::vtkInteractorStyleTrackballCamera_New()
      ::renwin_interact.SetInteractorStyle(&interact)
      #::renderer.Render()
      vols = ::renderer.GetVolumes()
      vols.InitTraversal()
      ::vol      =  vols.GetNextVolume()
      ::property = ::vol.GetProperty()
      mapper   = ::vol.GetMapper()
      ::volmapper = global::vtkVolumeMapper_SafeDownCast(&mapper)
      #::renwin_interact.Render()

    }

    #----------------------------
    proc ::StartNew() \
    {
      if (!exists(::input)) {
        ::load_input()
      }
printn "1"
      ::initialized=0
      ::renwin_interact = global::wxVTKFrame()
      ::renwin   = ::renwin_interact.GetRenderWindow()
      ::renderer = global::vtkRenderer_New()
      ::renwin.AddRenderer(&::renderer)
      interact = global::vtkInteractorStyleTrackballCamera_New()
      ::renwin_interact.SetInteractorStyle(&interact)


printn "2"
      # 10/(1+clip) in c++ code
      #::renwin_interact.SetDesiredUpdateRate(10)

      # check that we have a volume
      if (::input.tx<2)||(::input.ty<2)||(::input.tz<2) {
        InfoDialog "Input image is not a volume!"
      } else {
        ::vol       = global::vtkVolume_New()
        ::volmapper = global::vtkGPUVolumeRayCastMapper_New()
        # don't put the boxwidget for the moment
        # convert input to vtkimage
        ::vtkinput  = global::ToVtkImageData(&::input)
        ::volmapper.SetInput(&::vtkinput)

        #::volmapper.SetSampleDistance()

printn "3"
        # Create our transfer function
        ::colorFun=global::vtkColorTransferFunction_New()
        ::opacityFun=global::vtkPiecewiseFunction_New()
        
        # Create the property and attach the transfer functions
        ::property = global::vtkVolumeProperty_New()
        ::property.SetIndependentComponents(1)
        ::property.SetColor( &::colorFun )
        ::property.SetScalarOpacity( &::opacityFun )
        ::property.SetInterpolationTypeToLinear()
 
        # connect up the volume to the property and the mapper
        ::vol.SetProperty( &::property )
        ::vol.SetMapper( &::volmapper )
printn "4"


        # interact with data
        #  renWin->Render()
        #  m_pVTKWindow->Start()
        ::renderer->ResetCameraClippingRange()
        ::initialized=1
        ::ReCompute()

        # Add the volume to the scene
        ::renderer.AddVolume( &::vol )
        ::renderer.ResetCamera()
printn "5"
        #::renwin_interact.Render()
printn "6"

      }

    }

    #----------------------------
    proc ::BlendMIP() \
    {
      ::colorFun.AddRGBSegment(0.0, 1.0, 1.0, 1.0, 255.0, 1.0, 1.0, 1.0 );
      ::opacityFun.AddSegment( ::opacitylevel - 0.5*::opacitywindow, 0.0, \
                             ::opacitylevel + 0.5*::opacitywindow, 1.0 );
      ::volmapper.SetBlendModeToMaximumIntensity();
    }

    #----------------------------
    proc ::BlendCompositeRamp() \
    {
      ::colorFun.AddRGBSegment( ::opacitylevel - 0.5*::opacitywindow, 0.0, 0.0, 0.0, \
                              ::opacitylevel + 0.5*::opacitywindow, 1.0, 1.0, 1.0 )

      ::opacityFun.AddSegment( ::opacitylevel - 0.5*::opacitywindow, 0.0, \
                             ::opacitylevel + 0.5*::opacitywindow, 1.0 )

      ::volmapper.SetBlendModeToComposite()
      ::property.ShadeOff()
    }

    #----------------------------
    proc ::BlendCompositeShadeRamp() \
    {
      ::colorFun.AddRGBSegment(0.0, 1.0, 1.0, 1.0, 255.0, 1.0, 1.0, 1.0 );
      ::opacityFun.AddSegment( ::opacitylevel - 0.5*::opacitywindow, 0.0, \
                               ::opacitylevel + 0.5*::opacitywindow, 1.0 );
      ::volmapper.SetBlendModeToComposite();
      ::property.ShadeOn();
    }


    #----------------------------
    proc ::BlendCTSkin() \
    {
      ::colorFun.AddRGBPoint( -3024, 0, 0, 0, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( -1000, 0.62, 0.36, 0.18, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( -500, 0.88, 0.60, 0.29, 0.33, 0.45 );
      ::colorFun.AddRGBPoint( 3071, 0.83, 0.66, 1, 0.5, 0.0 );
      
      ::opacityFun.AddPoint(-3024, 0, 0.5, 0.0 );
      ::opacityFun.AddPoint(-1000, 0, 0.5, 0.0 );
      ::opacityFun.AddPoint(-500, 1.0, 0.33, 0.45 );
      ::opacityFun.AddPoint(3071, 1.0, 0.5, 0.0);

      ::volmapper.SetBlendModeToComposite();
      ::property.ShadeOn();
      ::property.SetAmbient(0.1);
      ::property.SetDiffuse(0.9);
      ::property.SetSpecular(0.2);
      ::property.SetSpecularPower(10.0);
      ::property.SetScalarOpacityUnitDistance(0.8919);
    }


    #----------------------------
    proc ::BlendCTBones() \
    {
      ::colorFun.AddRGBPoint( -3024, 0, 0, 0, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( -16, 0.73, 0.25, 0.30, 0.49, 0.61 );
      ::colorFun.AddRGBPoint( 641, 0.90, 0.82, 0.56, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( 3071, 1, 1, 1, 0.5, 0.0 );
      
      ::opacityFun.AddPoint(-3024, 0, 0.5, 0.0 );
      ::opacityFun.AddPoint(-16, 0, 0.49, 0.61 );
      ::opacityFun.AddPoint(641, 0.72, 0.5, 0.0 );
      ::opacityFun.AddPoint(3071, 0.71, 0.5, 0.0);

      ::volmapper.SetBlendModeToComposite();
      ::property.ShadeOn();
      ::property.SetAmbient(0.1);
      ::property.SetDiffuse(0.9);
      ::property.SetSpecular(0.2);
      ::property.SetSpecularPower(10.0);
      ::property.SetScalarOpacityUnitDistance(0.8919);
    }


    #----------------------------
    proc ::BlendCTMuscles() \
    {
      ::colorFun.AddRGBPoint( -3024, 0, 0, 0, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( -155, 0.55, 0.25, 0.15, 0.5, 0.92 );
      ::colorFun.AddRGBPoint( 217, 0.88, 0.60, 0.29, 0.33, 0.45 );
      ::colorFun.AddRGBPoint( 420, 1, 0.94, 0.95, 0.5, 0.0 );
      ::colorFun.AddRGBPoint( 3071, 0.83, 0.66, 1, 0.5, 0.0 );
      
      ::opacityFun.AddPoint(-3024, 0, 0.5, 0.0 );
      ::opacityFun.AddPoint(-155, 0, 0.5, 0.92 );
      ::opacityFun.AddPoint(217, 0.68, 0.33, 0.45 );
      ::opacityFun.AddPoint(420, 0.83, 0.5, 0.0);
      ::opacityFun.AddPoint(3071, 0.80, 0.5, 0.0);

      ::volmapper.SetBlendModeToComposite();
      ::property.ShadeOn();
      ::property.SetAmbient(0.1);
      ::property.SetDiffuse(0.9);
      ::property.SetSpecular(0.2);
      ::property.SetSpecularPower(10.0);
      ::property.SetScalarOpacityUnitDistance(0.8919);
    }

    #----------------------------
    proc ::ReCompute() \
    {
printn "Recompute 1"
        if exists(::colorFun)   { ::colorFun.Delete(); del ::colorFun; }
        if exists(::opacityFun) { ::opacityFun.Delete(); del ::opacityFun; }
        if exists(::property)   { ::property.Delete(); del ::property; }

printn "Recompute 2"
        ::colorFun=global::vtkColorTransferFunction_New()
        ::opacityFun=global::vtkPiecewiseFunction_New()

printn "Recompute 3"
        # Create the property and attach the transfer functions
        ::property = global::vtkVolumeProperty_New()
        ::property.SetIndependentComponents(1)
        ::property.SetColor( &::colorFun )
        ::property.SetScalarOpacity( &::opacityFun )
        ::property.SetInterpolationTypeToLinear()
 
        # connect up the volume to the property and the mapper
        ::vol.SetProperty( &::property )

printn "Recompute 4"
        if (::blend_type==0) { ::BlendMIP();                }
        if (::blend_type==1) { ::BlendCompositeRamp();      }
        if (::blend_type==2) { ::BlendCompositeShadeRamp(); }
        if (::blend_type==3) { ::BlendCTSkin();             }
        if (::blend_type==4) { ::BlendCTBones();            }
        if (::blend_type==5) { ::BlendCTMuscles();          }
printn "Recompute 5"

        #::property.SetColor( &::colorFun )
        #::property.SetScalarOpacity( &::opacityFun )
      
    }

    #----------------------------
    proc ::OnRender() \
    {
      if (exists(::renwin_interact)&&(::initialized>0.5)) {
        ::ReCompute()
        ::renwin_interact.Render()
      }
    }

    #----------------------------
    proc ::Gui() {
    
      # parameters window
      ::win = global::ami_import.ParamPanel("VolRen")
      
      ::win.BeginBook()
    
        ::win.AddPage("Param")

          # set the input image drawing window
          ::win.BeginBoxPanel("Input")
            ::win.BeginHorizontal()
              ::win.AddImageChoice( &::input_name, "")
              ::AddBitmapButton16(&::win, &::icons._Refresh, "ImReload")
              #::win.AddButton( "ImReload",&::ImReload)
            ::win.EndHorizontal()
          ::win.EndBoxPanel()

          ::win.BeginBoxPanel("Parameters")
            ::blend_type_id = ::win.AddEnum(&::blend_type,"Blend")
              ::win.AddEnumChoice(::blend_type_id,"MIP")
              ::win.AddEnumChoice(::blend_type_id,"Comp. Ramp")
              ::win.AddEnumChoice(::blend_type_id,"Comp. Shade Ramp")
              ::win.AddEnumChoice(::blend_type_id,"CT Skin")
              ::win.AddEnumChoice(::blend_type_id,"CT Bone")
              ::win.AddEnumChoice(::blend_type_id,"CT Muscles")
              ::win.AddEnumChoice(::blend_type_id,"RGB Composite")
            ::win.SetCallback( &::OnRender)

            ::opacitywindow_id = ::win.AddFloat(&::opacitywindow,"Window",0,5000)
            ::win.SetCallback( &::OnRender)
            ::opacitylevel_id = ::win.AddFloat(&::opacitylevel,"Level",0,5000)
            ::win.SetCallback( &::OnRender)
            ::win.AddBoolean(&::clip, "Clipping box")
          ::win.EndBoxPanel()

          ::win.AddButton("Start",   ::Start)
          ::win.AddButton("StartNew",::StartNew)
  
      ::win.EndBook()

      ::AddStandardButtons(&::win)
      
      ::win.Update(-1)
      ::win.Display()
   }

    ::Init()
  } 
  # Class VolRenClass
  Comments( VolRenClass, comments)
} 
# end if (!exists(VolRenClass))
  
  

