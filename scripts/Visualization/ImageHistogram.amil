#!/usr/bin/amilab

#
# Script for drawing 2D functions
# or lines from an image
#

comments="ImageHistoClass: this class allows to draw the histogram of an image."

func "Common/ScriptGui"


if (!exists(ImageHistoClass)) {

  Class ImageHistoClass : public ScriptGui {

    ::ami_import = &global::ami_import
    #----------------------------
    proc ::Init() \
    {
      ::input_name =  "", "name of the input image, the drawing window of this image will be used"
      ::minval = 0, "minimal value of the histogram"
      ::maxval = 255, "maximal value of the histogram"
      ::step = 1, "histogram step"
      ::mode = INT(1), "0: transfer function, 1: min-max from black to white"
      ::InitColours()
      ::Gui()
    }

    #---------------------------
    proc ::DrawIsoContours() \
    {
      nc = ::dw.GetNumberOfCtrlPoints()
      nb_iso = 0
      if (exists(::input)) {
        for k=0 to nc-1 {
          cp = ::dw.GetCtrlPoint(k)
          if (exists(::input_draw)) {
            if (nb_iso<3)&&(cp.GetVerticalLine()) {
              ::input_draw.SetIsoContour(nb_iso,&::input,cp.GetX())
              col = cp.GetColour()
              ::input_draw.SetIsoContourColor(nb_iso,col.Red(),col.Green(),col.Blue())
              ::input_draw.DrawIsoContour(nb_iso,1)
              nb_iso++
            }
          }
        }
        # don't draw other isocontours
        for k=nb_iso-1 to 2 {
          if (exists(::input_draw)) {
            ::input_draw.DrawIsoContour(nb_iso,0)
          }
        }
        ::dw._Paint()
        ::dw.Refresh()
        if (exists(::input_draw)) {
          ::input_draw.Paint()
        }
      }
    }

    #---------------------------
    proc ::DrawTransferFunction() \
    {
      nc = ::dw.GetNumberOfCtrlPoints()

      if (exists(::input)) {
        curve_id = ::input.vdim;
      } else {
        curve_id = 0
      }

      nbpoints=0;
      for k=0 to nc-1 {
        cp = ::dw.GetCtrlPoint(k)
        if (cp.GetType()==0)&&(cp.GetVerticalLine()==0) {
          nbpoints++;
        }
      }
      FuncCurve = Image(FLOAT,nbpoints,1,1,2)
      n = 0
      for k=0 to nc-1 {
        cp = ::dw.GetCtrlPoint(k)
        if (cp.GetType()==0)&&(cp.GetVerticalLine()==0) {
          xpos = cp.GetX()
          ypos = cp.GetY()
          FuncCurve.setpos(n,0,0)
          FuncCurve.set(0,xpos)
          FuncCurve.set(1,ypos)
          n++
        }
      }
      ::dw->SetCurve(FuncCurve,curve_id)
      ::dw->SetCurveProperties(curve_id,"#009900")

      ::dw._Paint()
      ::dw.Refresh()
    }

    #---------------------------
    proc ::DrawMinMax() \
    {
      ::ColormapMinMax()
      nc = ::dw.GetNumberOfCtrlPoints()
      if (exists(::input))&&(nc>=2) {
        # force Y position in the middle
        hmax = max(::h[0])
        for k=0 to ::dw.GetNumberOfCtrlPoints()-1 {
          cp = ::dw.GetCtrlPoint(k)
          if (cp.GetType()==1) {
            cp.SetY(hmax/2.0)
            ::dw.SetCtrlPoint(k,&cp)
          }
        }
        FuncCurve = Image(FLOAT,2,1,1,2)
        FuncCurve.setpos(0,0,0)
        FuncCurve.set(0,::cm_min)
        FuncCurve.set(1,hmax/2.0)
        FuncCurve.setpos(1,0,0)
        FuncCurve.set(0,::cm_max)
        FuncCurve.set(1,hmax/2.0)

        ::dw->SetCurve(FuncCurve,::input.vdim)
        ::dw->SetCurveProperties(::input.vdim,"#000000")
        if (exists(::input_draw)) {
          ::input_draw.SetIntensityRange( ::cm_min, ::cm_max)
        }
  
        ::dw._Paint()
        ::dw.Refresh()
        ::UpdateCM()
        if (exists(::input_draw)) {
          ::input_draw.Paint()
        }
      }
    }

    #---------------------------
    proc ::OnCtrlPoint() \
    {
      ::DrawIsoContours();
      if (::mode==0) {
        ::DrawTransferFunction();
      }
      if (::mode==1) {
        ::DrawMinMax();
      }
    }

    #---------------------------
    proc ::InitColours() \
    {
      # set colors for the curves
      # start with 6 values, if more will need to add new colors
      ::ColoursVector = VarVector(6)
      ::ColoursVector.push_back("#FF0000")
      ::ColoursVector.push_back("#00FF00")
      ::ColoursVector.push_back("#0000FF")
      ::ColoursVector.push_back("#FFFF00")
      ::ColoursVector.push_back("#FF00FF")
      ::ColoursVector.push_back("#00FFFF")
    }
    
    #----------------------------
    proc ::LoadInput() \
    {
      SetStatusText("LoadInput")
      printn "evaluation of --> ::input <<="+::input_name+";"
      eval "::input <<="+::input_name+";"
      if (::input_name=="Image") {
        ::input_name = "::input"
        #::win.update
      }
      #::win.update
      ::UpdateImage()
      ::Update()
      SetStatusText("LoadInput Finished")
    }
    Comments(::LoadInput,"Load and initialize input image.")

    #-------------------------------------------------------------------
    proc ::UpdateImage() {
      SetStatusText("UpdateImage")
      Imin = min(::input[0])
      Imax = max(::input[0])
      for n=1 to ::input.vdim-1 {
        Imin = -max(-Imin,-min(::input[n]))
        Imax = max(Imax,max(::input[n]))          
      }
      ::minval = Imin
      ::maxval = Imax
      ::step = 1
      ::win.FloatConstraints(::minval_id,Imin,Imax,::minval)
      ::win.FloatConstraints(::maxval_id,Imin,Imax,::maxval)
      ::win.FloatConstraints(::step_id,  0,(Imax-Imin)/20,::step)
    }

    #-------------------------------------------------------------------
    proc ::Update() {
      SetStatusText("Update")
      if (exists(::input)) {
        if (::maxval<::minval+0.00001) { ::maxval = ::minval+0.00001; ::win.Update(-1); }
        if (::step<0.01) { ::step=0.01; ::win.Update(-1); }
        # vector of histograms
        if (exists(::h)) { del ::h; }
        ::h = VarVector(::input.vdim)
        for n=0 to ::input.vdim-1 {
          ::h.push_back( histo(::input[n],::minval,::maxval,(::maxval-::minval)/::step+1))
          ::dw->SetXLimits(::minval,::maxval)
          ::dw->SetYLimits(min(::h[n]),max(::h[n]))
          ::dw->SetCurve(::h[n],n)
          ::dw->SetCurveProperties(n,::ColoursVector[n%6])
        }

        # clear control points and add standard colormap
        hmax = max(::h[0])
        cp0 = ami.dwControlPoint(::minval,hmax/2)
        cp0.SetColour(wx.wxColour(0,0,0))
        cp0.SetType(1)
        cp1 = ami.dwControlPoint(::maxval,hmax/2)
        cp1.SetColour(wx.wxColour(255,255,255))
        cp1.SetType(1)
        # remove all control points
        ::dw.GetControlPoints().clear()
        ::dw.AddControlPoint(&cp0)
        ::dw.AddControlPoint(&cp1)

      }
    }

    #--------------------------------------------------
    proc ::ColormapMinMax() \
    {
      for k=0 to ::dw.GetNumberOfCtrlPoints()-1 {
        cp = ::dw.GetCtrlPoint(k)
        if (cp.GetType()==1) {
          if (!exists(xmin)) {
            xmin = cp.GetX();
          } else {
            xmin = -max(-xmin,-cp.GetX())
          }
          if (!exists(xmax)) {
            xmax = cp.GetX();
          } else {
            xmax = max(xmax,cp.GetX())
          }
        }
      }
      if (exists(xmin)) { ::cm_min = xmin; }
      if (exists(xmin)) { ::cm_max = xmax; }
    }

    #--------------------------------------------------
    proc ::UpdateCM() \
    {
      ::cm.SetXLimits(-1,256)
      ::cm.SetYLimits(-1,256)
      # remove all control points
      ::cm.GetControlPoints().clear()
      cm_range = ::cm_max-::cm_min
      hmax = max(::h[0])

      for k=0 to ::dw.GetNumberOfCtrlPoints()-1 {
        cp = ::dw.GetCtrlPoint(k)
        newpos = (cp.GetX()-::cm_min)/cm_range*255
        cp.SetX(newpos)
        if (cp.GetType()==1) {
          cp.SetY(127)
        } else {
          cp.SetY(cp.GetY()/hmax*255)
        }
        ::cm.AddControlPoint(&cp)
      }

      # add the corresponding histogram

      #  rescale histogram
      if (exists(::cm_min)&&exists(::cm_max)&&exists(::h)) {
        #printn "xmax = %1% " % xmax
        #printn "xmin = %1% " % xmin
        ::h1 <<= (FLOAT)::h[0]

        # rescale to the maximum in the current range
        minpos = (::cm_min-::h1.trx)/::h1.vx
        maxpos = (::cm_max-::h1.trx)/::h1.vx
        subhist = ::h1[minpos:maxpos,0:0]
        ::dw->SetCurve(subhist,2)
        ::dw->SetCurveProperties(2,"#0000FF")

        newpixelsize = ::h1.vx*255.0/cm_range
        ::h1.settranslation(-(::cm_min-::h1.trx)*255.0/cm_range,0,0)
        setvoxelsize(::h1,newpixelsize,1,1)
        ::h1 = ::h1/max(subhist)*255

        ::cm->SetCurve(::h1,0)
        ::cm->SetCurveProperties(0,"#0000FF")
        # update image colormap in image viewer
        if (exists(::input_draw)) {
          cm = ::dw.GetColormapImage()
          ::input_draw.SetUserColormap(cm)
          ::input_draw.UpdateColormap()
        }
      }
      ::cm._Paint()
      ::cm.Refresh()
    }

    #----------------------------
    proc ::ShowImage() {
      if (!exists(::input)) {
        InfoDialog "You must load the input image first!"
      } else {
        show ::input
      }
    }

    #----------------------------
    proc ::Gui() {
    
      # parameters window
      import = &global::ami_import;
      ::win = import->ParamPanel("ImHist")
      
      ::win.BeginBook()
    
        ::win.AddPage("Main")

          # set the input image drawing window
          ::win.BeginBoxPanel("Input")
            ::win.BeginHorizontal()
              ::win.AddImageChoice( &::input_name, "")
              ::AddBitmapButton(&::win, &::icons._Copy,   32, "LoadInput")
              ::win.SetPositionProp(-1,0)
            ::win.EndHorizontal()
          ::win.EndBoxPanel()

          ::win.BeginHorizontal()
            ::AddBitmapButton(&::win, &::icons._Refresh,   32, "Update")
            ::win.SetPositionProp(-1,0)
            ::AddBitmapButton(&::win, &::icons._Show,   32, "ShowImage")
            ::win.SetPositionProp(-1,0)
          ::win.EndHorizontal()

          ::mode_id = ::win.AddEnum( &::mode,"mode")
            ::win.AddEnumChoice(::mode_id,"Transfer Function")
            ::win.AddEnumChoice(::mode_id,"Min-Max")
          #::win.SetCallback( &::EqModeEvent)

          # add Drawing Window
          d = ::win.CurrentParent()
          ::dw = import->wxDrawingWindow(&d)
          # sets minimal size here
          ::dw.SetMinSize(&wx.wxSize(80,80));
          ::dw.SetBackgroundColour(wx.wxColour(255,255,255))
          ::sizer_item = ::win.AddWidget(&::dw,0)

          # add User Colormap Drawing Window
          d = ::win.CurrentParent()
          ::cm = import->wxDrawingWindow(&d)
          # sets minimal size here
          ::cm.SetMinSize(&wx.wxSize(80,70));
          ::cm.SetBackgroundColour(wx.wxColour(255,255,255))
          ::sizer_item = ::win.AddWidget(&::cm,0)

        ::win.AddPage("Param")
          ::win.BeginBoxPanel("Histogram calculation")
            ::minval_id = ::win.AddFloat(&::minval,"min",0,255)
            ::win.SetCallback(&::Update)
            ::maxval_id = ::win.AddFloat(&::maxval,"max",0,255)
            ::win.SetCallback(&::Update)
            ::step_id   = ::win.AddFloat(&::step,"step",0,10)
            ::win.SetCallback(&::Update)
          ::win.EndBoxPanel()

      ::win.EndBook()

      ::AddStandardButtons(&::win)
      
      ::win.Update(-1)
      ::win.Display()

      ::dw.SetCtrlPointCallback(&::OnCtrlPoint)
   }

    ::Init()
  } 
  # Class ImageHistoClass
  Comments( ImageHistoClass, comments)
} 
# end if (!exists(ImageHistoClass))
  
  
#----------------------------
# Main
#----------------------------

if (!exists(imhist)) {

  ImageHistoClass imhist
  
} else {
  InfoDialog "The script seems to be already loaded."
}

