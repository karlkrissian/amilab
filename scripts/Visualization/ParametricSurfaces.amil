#!/usr/bin/amilab
#
# (c) Karl Krissian, ULPGC 2009
#
#
# Playing with Parametric surfaces
#
# type:
#  0: superquadric
#
if (!exists(ParametricSurfaceClass)) {
  Class ParametricSurfaceClass {

  #---------------------------------------------
  proc ::Init() \
  {
    
    ::class_name = "global::ParametricSurfaceClass"
    # resolution
    ::theta_dim = INT(100)
    ::phi_dim   = INT(100)

    # coefficients
    ::cx = 1
    ::cy = 1
    ::cz = 1

    ::e_x = 1
    ::e_y = 1
    ::e_z = 1

    # 0: superquadric
    # 1: torus
    ::type = INT(0)

    # torus param
    ::R = 1
    ::r = 0.1

    # expressions as string
    ::X = "cos(U)*cos(V)"
    ::Y = "sin(U)*cos(V)"
    ::Z = "sin(V)"

    ::eq_filename = "user_equation1.amil"

    # temporal evolution of the equation
    # evolution state 0:stopped, 1:running, 2:stopping
    ::in_evolve = UCHAR(0)
    ::evolve_state = INT(0)
    ::k        = INT(0)
    ::kmax     = INT(0)
    # timestep in milliseconds
    ::timestep = INT(100) 
    
    ::updating = 0
    ::Update()
    ::Gui()
    
  }

    #----------------------------------------------------------
   
  proc ::Close() \
  {
    ::win.HidePanel
    delvars GetObjectName(::Close)
  }
  ::Close.Comments("Will close the interface and delete the corresponding object named '"+GetObjectName(::Close)+"'.")
    
    #----------------------------
    
  proc ::CloseAll() \
  {
    eval  "if (exists(%1%)) { del %1%; };"  % ::class_name 
    ::Close
  }
  ::CloseAll.Comments("Call ::Close() method and delete the class variable")
    
  #------------------------------------

  proc ::UpdateResolution() \
  {
    printn "UpdateResolution()"
    # 3D position image
    ::pos <<= Image(DOUBLE,::theta_dim,::phi_dim,1,3)

    # Parameters
    ::theta <<= (DOUBLE)Xpos(::pos)
    ::phi   <<= (DOUBLE)Ypos(::pos)

    if (::type==0)||(::type==2) {
      printn "type in {0,2}"
      # limits of the parameters
      ::theta = ::theta/(::theta.tx-1)*2*Pi
      ::phi   = (::phi/(::phi.ty-1)-0.5)*Pi
    }
    if (::type==1) {
      printn "type is 1"
      # limits of the parameters
      ::theta = ::theta/(::theta.tx-1)*2*Pi
      ::phi   = ::phi/(::phi.ty-1)*2*Pi
    }

  } // ::UpdateResolution()

#----------------------------------------------------------
  proc ::NewType() {
    ::UpdateResolution()
    ::Update()
  }

#------------------------------------------------------------

  proc ::Update() \
  {
    if (::updating==0) {
      ::updating = 1
      if (!exists(::pos)) {
        ::UpdateResolution()
      }else {
        printn "::theta_dim = %1%"%::theta_dim
        printn "::pos.tx=%1%"%::pos.tx
        printn "::phi_dim = %1%"%::phi_dim
        printn "::pos.ty=%1%"%::pos.ty
        printn "::theta_dim!=::pos.tx --> %1%" % (::theta_dim!=::pos.tx)
        printn "::phi_dim!=::pos.ty --> %1%" % (::phi_dim!=::pos.ty)
        if ((::theta_dim!=::pos.tx)||(::phi_dim!=::pos.ty)) {
          ::UpdateResolution()
        }
      }
      # 0: superquadric
      if (::type==0) {
      
        ::pos.SetComponent(0, cos(::theta)*cos(::phi))
        ::pos.SetComponent(1, sin(::theta)*cos(::phi))
        ::pos.SetComponent(2, sin(::phi))

        # compute the signs
        spos0 = (::pos[0]>0) - (::pos[0]<0)
        spos1 = (::pos[1]>0) - (::pos[1]<0)
        spos2 = (::pos[2]>0) - (::pos[2]<0)

        ::pos.SetComponent(0,exp(ln(abs(::pos[0]))/::e_x)*spos0*::cx)
        ::pos.SetComponent(1,exp(ln(abs(::pos[1]))/::e_y)*spos1*::cy)
        ::pos.SetComponent(2,exp(ln(abs(::pos[2]))/::e_z)*spos2*::cz)
      }
printn "4"

      # 1: torus
      if (::type==1) {
        ::pos.SetComponent(0, (cos(::phi)*::r+::R)*cos(::theta))
        ::pos.SetComponent(1, (cos(::phi)*::r+::R)*sin(::theta)
        ::pos.SetComponent(2, sin(::phi)*::r)
      }

      # 2: UserÂ´s equation
      if (::type==2) {
        U = ::theta
        V = ::phi
        k = ::k
        eval "::pos.SetComponent(0, "+::X+");"
        X = ::pos[0]
        eval "::pos.SetComponent(1, "+::Y+");"
        Y = ::pos[1]
        eval "::pos.SetComponent(2, "+::Z+");"
      }

      if (exists(::s_draw)) {
        ::s_draw.Remove(::s)
        del ::s
      }

printn "5"
      # parameter 0 invert normals
      ::s = CreateFlatMesh(::theta>-1,0)
      ::s.ElevateMesh(::pos)
      # need to show the surface before computing any opengl operation!!!

      if (exists(::s_draw)) {
        ::s_draw += ::s
      } else {
        show ::s
      }
printn "6"
      ::s.Normals
      ::s.Recompute
      ::s_draw.Paint
      ::updating = 0
printn "7"
    }
printn "8"
  }

  #--------------------------------------------------------------
  proc ::Evolve() \
  {
    if (::in_evolve==0) {
      ::in_evolve = 1
      if (::evolve_state==0) {
        if (::kmax>0) {
          ::k = 0
          # starts
          ::evolve_state=1
        }
      }
      if (::evolve_state==1) {
        # first update the equation
        ::Update()
        # second: increment ::k and schedule new update
        ::k = ::k + 1
        if (::k==::kmax) { 
          ::k = 0; 
        }
        schedule(::timestep,::Evolve)
      }
    }
    ::in_evolve = 0
  }

  #--------------------------------------------------------------
  proc ::Start() \
  {
    ::evolve_state = 0
    ::Evolve
  }

  #--------------------------------------------------------------
  proc ::Stop() \
  {
    ::evolve_state = 2
  }


  #--------------------------------------------------------------
  proc ::ResetScale() \
  {
    ::cx = 1
    ::cy = 1
    ::cz = 1
    ::win.Update(-1)
    ::Update()
  } # ::ResetScale()

  #--------------------------------------------------------------
  proc ::SetEllipsoid() \
  {
    ::type=0
    ::e_x = 1
    ::e_y = 1
    ::e_z = 1
    ::win.Update(-1)
    ::Update()
  } 
  # ::SetEllipsoid()

  #--------------------------------------------------------------
  proc ::SaveEquation() {
    eq_file = open(::eq_filename,"w")

    eq_file.print "//-- Saving equation \n"

    eq_file.print "//---- Main Parameters\n"

    eq_file.print "::theta_dim = %1%\n" % ::theta_dim
    eq_file.print "::phi_dim = %1%\n" % ::phi_dim

    eq_file.print "//---- Parametric equation expression \n"

    eq_file.print "::X = \"" +::X +"\"\n"
    eq_file.print "::Y = \"" +::Y +"\"\n"
    eq_file.print "::Z = \"" +::Z +"\"\n"

    eq_file.print boost_format("::kmax = %1%\n") \
                                % ::kmax
    eq_file.print boost_format("::timestep = %1%\n") \
                                % ::timestep

    eq_file.print "// Update interface\n"
    eq_file.print "::win.Update(-1)\n"

  }


  #--------------------------------------------------------------
  proc ::ReadEquation() {
    # call func to read a script ...
    func
  }

  #--------------------------------------------------------------
  proc ::Gui(){
  
    import = &global::ami_import;
    ::win = import->ParamPanel("Param. Surf.")

    ::type_id  = ::win.AddEnum( &::type)
      ::win.AddEnumChoice(::type_id,"SuperQuadric")
      ::win.AddEnumChoice(::type_id,"Torus")
      ::win.AddEnumChoice(::type_id,"Expression")
    ::win.SetCallback( &::NewType)

    ::win.BeginBook
      # Main Page
      ::win.AddPage("Main")
        ::win.BeginBoxPanel("Resolution")
            ::thetadim_id = ::win.AddInt( &::theta_dim,  "::theta_dim", 4,500)
            ::win.SetCallback( &::Update)
            ::phidim_id   = ::win.AddInt( &::phi_dim,  "::phi_dim",   4,500)
            ::win.SetCallback( &::Update)
        ::win.EndBoxPanel
        ::win.BeginBoxPanel("Scaling Coeff.")
            ::cx_id = ::win.AddFloat( &::cx,  "::cx", 0.1,5)
            ::win.SetCallback( &::Update)
            ::cy_id = ::win.AddFloat( &::cy,  "::cy", 0.1,5)
            ::win.SetCallback( &::Update)
            ::cz_id = ::win.AddFloat( &::cz,  "::cz", 0.1,5)
            ::win.SetCallback( &::Update)
            ::win.AddButton("Reset",   ::ResetScale)
        ::win.EndBoxPanel


      # SuperQuadric Page
      ::win.AddPage("SuperQu.")
        ::win.BeginBoxPanel("Exponential Coeff.")
            ::ex_id = ::win.AddFloat( &::e_x,  "::e_x", 0.1,5)
            ::win.SetCallback( &::Update)
            ::ey_id = ::win.AddFloat( &::e_y,  "::e_y", 0.1,5)
            ::win.SetCallback( &::Update)
            ::ez_id = ::win.AddFloat( &::e_z,  "::e_z", 0.1,5)
            ::win.SetCallback( &::Update)
            ::win.AddButton("Set Ellipsoid",   ::SetEllipsoid)
        ::win.EndBoxPanel

      # SuperQuadric Torus
      ::win.AddPage("Torus")
        ::win.BeginBoxPanel("Radii")
            ::R_id = ::win.AddFloat( &::R,  "::R", 0.1,5)
            ::win.SetCallback( &::Update)
            ::r_id = ::win.AddFloat( &::r,  "::r", 0.1,5)
            ::win.SetCallback( &::Update)
        ::win.EndBoxPanel

      # User Equation Page
      ::win.AddPage("Expr")
        ::win.BeginBoxPanel("Equation (U,V):")
          ::X_id = ::win.AddString( &::X,"X=")
          ::win.SetCallback( &::Update)
          ::Y_id = ::win.AddString( &::Y,"Y=")
          ::win.SetCallback( &::Update)
          ::Z_id = ::win.AddString( &::Z,"Z=")
          ::win.SetCallback( &::Update)
        ::win.EndBoxPanel
        ::win.BeginBoxPanel("Time evolution:")
          ::win.AddInt( &::kmax,  "::kmax", 0,100)
          ::win.AddInt( &::timestep,  "::timestep", 0,1000)
          ::win.BeginHorizontal
            ::win.AddButton("Start", ::Start)
            ::win.AddButton("Stop",  ::Stop)
          ::win.EndHorizontal
        ::win.EndBoxPanel
        
        ::win.AddString( &::eq_filename,"Eq. filename")
        ::win.BeginHorizontal
          ::win.AddButton("Save", ::SaveEquation)
          ::win.AddButton("Read", ::ReadEquation)
        ::win.EndHorizontal

    ::win.EndBook
        ::win.BeginHorizontal
          ::win.AddButton("Update",         ::Update)
          ::win.AddButton("Close",          ::Close)
          ::win.AddButton("Close All",          ::CloseAll)
        ::win.EndHorizontal
    ::win.Update(-1)
    ::win.Display
  }
  
  ::Init
  }

}
  # end if (!exists(ParametricSurfaceClass))


  #----------------------------
  # Main
  #----------------------------

  if (!exists(ps)) {
    ParametricSurfaceClass ps  
    #if (argc>=1) {
      #printn "reading image"
      #input = Image($1)
      #ps->image_name = "input"
      #ps->win.update
    #}

  } else {
    InfoDialog "The script seems to be already loaded."
  }
