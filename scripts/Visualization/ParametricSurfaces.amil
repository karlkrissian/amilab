#!/usr/bin/amilab

#
# (c) Karl Krissian, ULPGC 2009
#


#
# Playing with Parametric surfaces
#
# type:
#  0: superquadric
#


proc PS_init() {
  global_new

  # resolution
  PS_theta_dim = INT(100)
  PS_phi_dim   = INT(100)

  # coefficients
  PS_cx = 1
  PS_cy = 1
  PS_cz = 1

  PS_e_x = 1
  PS_e_y = 1
  PS_e_z = 1

  # 0: superquadric
  # 1: torus
  PS_type = INT(0)

  # torus param
  PS_R = 1
  PS_r = 0.1

  # expressions as string
  PS_X = "cos(U)*cos(V)"
  PS_Y = "sin(U)*cos(V)"
  PS_Z = "sin(V)"

  PS_eq_filename = "user_equation1.amil"

  # temporal evolution of the equation
  # evolution state 0:stopped, 1:running, 2:stopping
  PS_in_evolve = UCHAR(0)
  PS_evolve_state = INT(0)
  PS_k        = INT(0)
  PS_kmax     = INT(0)
  # timestep in milliseconds
  PS_timestep = INT(100) 

  PS_updating = 0
  PS_Update()
}

#----------------------------------------------------------
proc PS_Close() {
  PS_win.Hide
  delvars "PS_*_draw"
  delvars "PS_*"
}

#----------------------------------------------------------
proc PS_UpdateResolution() \
{
  # 3D position image
  global::PS_pos <<= Image(DOUBLE,PS_theta_dim,PS_phi_dim,1,3)

  # Parameters
  global::PS_theta <<= (DOUBLE)Xpos(PS_pos)
  global::PS_phi   <<= (DOUBLE)Ypos(PS_pos)


  if (PS_type==0)||(PS_type==2) {
    # limits of the parameters
    PS_theta = PS_theta/(PS_theta.tx-1)*2*Pi
    PS_phi   = (PS_phi/(PS_phi.ty-1)-0.5)*Pi
  }
  if (PS_type==1) {
    # limits of the parameters
    PS_theta = PS_theta/(PS_theta.tx-1)*2*Pi
    PS_phi   = PS_phi/(PS_phi.ty-1)*2*Pi
  }

} // PS_UpdateResolution()


#----------------------------------------------------------
proc PS_NewType() {
  PS_UpdateResolution()
  PS_Update()
}


#------------------------------------------------------------
proc PS_Update() \
{
  if (PS_updating==0) {
    PS_updating = 1

    if (!exists(PS_pos)) {
      PS_UpdateResolution()
    } else {
      if ((PS_theta_dim!=PS_pos.tx)||(PS_phi_dim!=PS_pos.ty)) {
        PS_UpdateResolution()
      }
    }

    # 0: superquadric
    if (PS_type==0) {

      PS_pos[0] = cos(PS_theta)*cos(PS_phi)
      PS_pos[1] = sin(PS_theta)*cos(PS_phi)
      PS_pos[2] = sin(PS_phi)

      # compute the signs
      spos0 = (PS_pos[0]>0) - (PS_pos[0]<0)
      spos1 = (PS_pos[1]>0) - (PS_pos[1]<0)
      spos2 = (PS_pos[2]>0) - (PS_pos[2]<0)

      PS_pos[0] = (exp(ln(abs(PS_pos[0]))/PS_e_x))*spos0*PS_cx
      PS_pos[1] = (exp(ln(abs(PS_pos[1]))/PS_e_y))*spos1*PS_cy
      PS_pos[2] = (exp(ln(abs(PS_pos[2]))/PS_e_z))*spos2*PS_cz
    }

    # 1: torus
    if (PS_type==1) {

      PS_pos[0] = (cos(PS_phi)*PS_r+PS_R)*cos(PS_theta)
      PS_pos[1] = (cos(PS_phi)*PS_r+PS_R)*sin(PS_theta)
      PS_pos[2] = sin(PS_phi)*PS_r

    }

    # 2: UserÂ´s equation
    if (PS_type==2) {
      U = PS_theta
      V = PS_phi
      k = PS_k
      eval "PS_pos[0] = "+PS_X+";"
      X = PS_pos[0]
      eval "PS_pos[1] = "+PS_Y+";"
      Y = PS_pos[1]
      eval "PS_pos[2] = "+PS_Z+";"
    }

    if (exists(PS_s_draw)) {
      PS_s_draw.Remove(PS_s)
    }

    if (exists(PS_s)) {
      del global::PS_s
    }

    # parameter 0 invert normals
    global::PS_s = CreateFlatMesh(PS_theta>-1,0)
    PS_s.ElevateMesh(PS_pos)
    # need to show the surface before computing any opengl operation!!!

    if (exists(PS_s_draw)) {
      PS_s_draw += PS_s
    } else {
      show PS_s
    }
    PS_s.Normals
    PS_s.Recompute
    PS_s_draw.Paint
    PS_updating = 0
  }
}

#--------------------------------------------------------------
proc PS_Evolve() \
{
  if (PS_in_evolve==0){
    PS_in_evolve = 1
    if (PS_evolve_state==0) {
      if (PS_kmax>0) {
        PS_k = 0
        # starts
        PS_evolve_state=1
      }
    }
    if (PS_evolve_state==1) {
      # first update the equation
      PS_Update()
      # second: increment PS_k and schedule new update
      PS_k = PS_k + 1
      if (PS_k==PS_kmax) { PS_k = 0; }
      schedule(PS_timestep,PS_Evolve)
    }
  }
  PS_in_evolve = 0
}


#--------------------------------------------------------------
proc PS_Start() \
{
  PS_evolve_state = 0
  PS_Evolve
}

#--------------------------------------------------------------
proc PS_Stop() \
{
  PS_evolve_state = 2
}


#--------------------------------------------------------------
proc PS_ResetScale() \
{
  PS_cx = 1
  PS_cy = 1
  PS_cz = 1
  PS_win.update
  PS_Update()
} # PS_ResetScale()

#--------------------------------------------------------------
proc PS_SetEllipsoid() \
{
  PS_type=0
  PS_e_x = 1
  PS_e_y = 1
  PS_e_z = 1
  PS_win.update
  PS_Update()
} # PS_SetEllipsoid()


#--------------------------------------------------------------
proc PS_SaveEquation() {

  eq_file = open(PS_eq_filename,"w")

  eq_file.print "//-- Saving equation \n"

  eq_file.print "//---- Main Parameters\n"

  eq_file.print boost_format("PS_theta_dim = %1%\n") % PS_theta_dim
  eq_file.print boost_format("PS_phi_dim = %1%\n") % PS_phi_dim

  eq_file.print "//---- Parametric equation expression \n"

  eq_file.print "PS_X = \"" +PS_X +"\"\n"
  eq_file.print "PS_Y = \"" +PS_Y +"\"\n"
  eq_file.print "PS_Z = \"" +PS_Z +"\"\n"

  eq_file.print boost_format("PS_kmax = %1%\n") \
                              % PS_kmax
  eq_file.print boost_format("PS_timestep = %1%\n") \
                              % PS_timestep

  eq_file.print "// Update interface\n"
  eq_file.print "PS_win.update\n"

}


#--------------------------------------------------------------
proc PS_ReadEquation() {
  # call func to read a script ...
  func
}


#--------------------------------------------------------------
proc PS_gui() {

  global::PS_win = ParamWin("Param. Surf.")

  PS_type_id  = PS_win.AddEnum(PS_type)
    PS_win.AddEnumChoice(PS_type_id,"SuperQuadric")
    PS_win.AddEnumChoice(PS_type_id,"Torus")
    PS_win.AddEnumChoice(PS_type_id,"Expression")
  PS_win.SetCallback(PS_NewType)

  PS_win.BeginBook
    # Main Page
    PS_win.AddPage("Main")
      PS_win.BeginBox("Resolution")
          PS_thetadim_id = PS_win.AddInt(PS_theta_dim,4,500)
          PS_win.SetCallback(PS_Update)
          PS_phidim_id   = PS_win.AddInt(PS_phi_dim,  4,500)
          PS_win.SetCallback(PS_Update)
      PS_win.EndBox
      PS_win.BeginBox("Scaling Coeff.")
          PS_cx_id = PS_win.AddFloat    (PS_cx,0.1,5)
          PS_win.SetCallback(PS_Update)
          PS_cy_id = PS_win.AddFloat    (PS_cy,0.1,5)
          PS_win.SetCallback(PS_Update)
          PS_cz_id = PS_win.AddFloat    (PS_cz,0.1,5)
          PS_win.SetCallback(PS_Update)
          PS_win.AddButton("Reset",   PS_ResetScale)
      PS_win.EndBox


    # SuperQuadric Page
    PS_win.AddPage("SuperQu.")
      PS_win.BeginBox("Exponential Coeff.")
          PS_cx_id = PS_win.AddFloat    (PS_e_x,0.1,5)
          PS_win.SetCallback(PS_Update)
          PS_cy_id = PS_win.AddFloat    (PS_e_y,0.1,5)
          PS_win.SetCallback(PS_Update)
          PS_cz_id = PS_win.AddFloat    (PS_e_z,0.1,5)
          PS_win.SetCallback(PS_Update)
          PS_win.AddButton("Set Ellipsoid",   PS_SetEllipsoid)
      PS_win.EndBox

    # SuperQuadric Torus
    PS_win.AddPage("Torus")
      PS_win.BeginBox("Radii")
          PS_R_id = PS_win.AddFloat    (PS_R,0.1,5)
          PS_win.SetCallback(PS_Update)
          PS_r_id = PS_win.AddFloat    (PS_r,0.1,5)
          PS_win.SetCallback(PS_Update)
      PS_win.EndBox

    # User Equation Page
    PS_win.AddPage("Expr")
      PS_win.BeginBox("Equation (U,V):")
        PS_X_id = PS_win.AddString(PS_X,"X=")
        PS_win.SetCallback(PS_Update)
        PS_Y_id = PS_win.AddString(PS_Y,"Y=")
        PS_win.SetCallback(PS_Update)
        PS_Z_id = PS_win.AddString(PS_Z,"Z=")
        PS_win.SetCallback(PS_Update)
      PS_win.EndBox
      PS_win.BeginBox("Time evolution:")
        PS_win.AddInt(PS_kmax,0,100)
        PS_win.AddInt(PS_timestep,0,1000)
        PS_win.BeginHorizontal
          PS_win.AddButton("Start", PS_Start)
          PS_win.AddButton("Stop",  PS_Stop)
        PS_win.EndHorizontal
      PS_win.EndBox
      
      PS_win.AddString(PS_eq_filename,"Eq. filename")
      PS_win.BeginHorizontal
        PS_win.AddButton("Save", PS_SaveEquation)
        PS_win.AddButton("Read", PS_ReadEquation)
      PS_win.EndHorizontal

  PS_win.EndBook
      PS_win.BeginHorizontal
        PS_win.AddButton("Update",         PS_Update)
        PS_win.AddButton("Close",          PS_Close)
      PS_win.EndHorizontal
  PS_win.update
  PS_win.Display
}

PS_init()
PS_gui()

