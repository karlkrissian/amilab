
//
// Add a sphere to an image
//

if (!exists(AddSphereClass)) {

  Class AddSphereClass \
  {
    ::class_name ="global::AddSphereClass"
    proc ::AddSphere( IMAGE im, NUM x, NUM y, NUM z, NUM rad ) {
    //   ---------
      rad2=2*rad
      if (im.tz>1) {
        sph = im[x-rad2:x+rad2,y-rad2:y+rad2,z-rad2:z+rad2]
        px = (FLOAT) Xpos(sph)-rad2
        py = (FLOAT) Ypos(sph)-rad2
        pz = (FLOAT) Zpos(sph)-rad2
        sph = sqrt(px*px+py*py+pz*pz)-rad
        sph = (sph<rad)*sph+(sph>=rad)*rad
        im.putimage(sph)
      } else {
       sph = im[x-rad2:x+rad2,y-rad2:y+rad2,0:0]
        px = (FLOAT) Xpos(sph)-rad2
        py = (FLOAT) Ypos(sph)-rad2
        sph = sqrt(px*px+py*py)-rad
        sph = (sph<rad)*sph+(sph>=rad)*rad
        im.putimage(sph)
      }
    }

    //
    // take into account the voxel size and create a sphere
    // with the radius in mm
    //
    proc ::AddBrightSphere_mm( IMAGE im, NUM x, NUM y, NUM z, NUM rad, NUM I1, NUM I2 ) {
    //   ---------------
      vx = im.vx
      vy = im.vy
      vz = im.vz
      dx = x-(INT)x
      dy = y-(INT)y
      dz = z-(INT)z
      radx=(INT) (2*(rad+0.99)/vx)
      rady=(INT) (2*(rad+0.99)/vy)
      radz=(INT) (2*(rad+0.99)/vz)
      if (im.tz>1) {
        sph = im[x-radx:x+radx,y-rady:y+rady,z-radz:z+radz]
        px = (FLOAT) Xpos(sph)-(radx+dx)
        py = (FLOAT) Ypos(sph)-(rady+dy)
        pz = (FLOAT) Zpos(sph)-(radz+dz)
        px = px*vx
        py = py*vy
        pz = pz*vz
        r2 = px*px+py*py+pz*pz;
        sph = r2/(2*rad*rad)
        sph =  exp(-sph*sph)*(I2-I1) + I1
        // set as max
        sim = im[sph]
        sim = max(sim,sph)
        im.putimage(sim)
      } else {
        sph = im[x-radx:x+radx,y-rady:y+rady,0:0]
        px = (FLOAT) Xpos(sph)-radx-dx
        py = (FLOAT) Ypos(sph)-rady-dy
        px = px*vx
        py = py*vy
        r2 = px*px+py*py;
        sph = r2/(2*rad*rad)
        sph =  exp(-sph)*(I2-I1) + I1
        sim = im[sph]
        sim = max(sim,sph)
        im.putimage(sim)
      }
    }


    # add sphere using the global coordinate system for the points
    proc ::AddBrightSphereGlobal_mm( \
                IMAGE im,\
                NUM x, NUM y, NUM z,\
                NUM rad, NUM I1, NUM I2 ) \
    {
      ::AddBrightSphere_mm(&im,\
        (x-im.trx)/im.vx,\
        (y-im.try)/im.vy,\
        (z-im.trz)/im.vz,\
        rad, I1, I2)
    }


    //
    proc ::AddBrightSphere( IMAGE im, NUM x, NUM y, NUM z, NUM rad ) {
    //   ---------------
      dx = x-(INT)x
      dy = y-(INT)y
      dz = z-(INT)z
      rad2=2*rad
      if (im.tz>1) {
        sph = im[x-rad2:x+rad2,y-rad2:y+rad2,z-rad2:z+rad2]
        px = ((FLOAT) Xpos(sph))-(rad2+dx)
        py = ((FLOAT) Ypos(sph))-(rad2+dy)
        pz = ((FLOAT) Zpos(sph))-(rad2+dz)
        sph = sqrt(px*px+py*py+pz*pz)-rad
        sph = (sph<rad)*sph+(sph>=rad)*rad
        sph=-sph
        im.putimage(sph)
      } else {
       sph = im[x-rad2:x+rad2,y-rad2:y+rad2,0:0]
        px = ((FLOAT) Xpos(sph))-(rad2+dx)
        py = ((FLOAT) Ypos(sph))-(rad2+dy)
        sph = sqrt(px*px+py*py)-rad
        sph = (sph<rad)*sph+(sph>=rad)*rad
        sph=-sph
        im.putimage(sph)
      }
    }


    proc ::AddSphereCursor( IMAGE im, IMAGEDRAW imdraw, NUM rad ) {
    //   ---------------
      print "*\n"
      x=imdraw.GetXPos
      y=imdraw.GetYPos
      z=imdraw.GetZPos
      rad2=2*rad
      if (im.tz>1) {
        sph = im[x-rad2:x+rad2,y-rad2:y+rad2,z-rad2:z+rad2]
        px = (FLOAT) Xpos(sph)-rad2
        py = (FLOAT) Ypos(sph)-rad2
        pz = (FLOAT) Zpos(sph)-rad2
        sph = sqrt(px*px+py*py+pz*pz)-rad
        sph = (sph<rad)*sph+(sph>=rad)*rad
        sph=-sph
        im.putimage(sph)
      } else {
       sph = im[x-rad2:x+rad2,y-rad2:y+rad2,0:0]
        px = (FLOAT) Xpos(sph)-rad2
        py = (FLOAT) Ypos(sph)-rad2
        sph = sqrt(px*px+py*py)-rad
        sph = (sph<rad)*sph+(sph>=rad)*rad
        sph=-sph
        im.putimage(sph)
      }
    }


    //
    // Add a black sphere to an image
    //
    proc ::AddBlackSphere( IMAGE im, NUM x, NUM y, NUM z, NUM rad ) {
    //   --------------
      rad2=2*rad
      if (im.tz>1) {
        im0 = im[x-rad2:x+rad2,y-rad2:y+rad2,z-rad2:z+rad2]
        px = (FLOAT) Xpos(im0)-rad2
        py = (FLOAT) Ypos(im0)-rad2
        pz = (FLOAT) Zpos(im0)-rad2
        sph = sqrt(px*px+py*py+pz*pz)-rad
        im0 = im0*(sph>0)
        im.putimage(im0)
      } else {
        im0 = im[x-rad2:x+rad2,y-rad2:y+rad2,0:0]
        px = (FLOAT) Xpos(im0)-rad2
        py = (FLOAT) Ypos(im0)-rad2
        sph = sqrt(px*px+py*py)-rad
        im0 = im0*(sph>0)
        im.putimage(im0)
      }
    }
    
    proc ::Close() \
    {
      delvars GetObjectName(::Close)
    }
    ::Close.Comments("Will close the interface and delete the corresponding object named '"+GetObjectName(::Close)+"'.")
  
    proc ::CloseAll() {
      eval boost_format( "if (exists(%1%)) { del %1%; };" ) % ::class_name 
      ::Close
    }
    ::CloseAll.Comments("Call ::Close() method and delete the class variable")
    
  }
}
